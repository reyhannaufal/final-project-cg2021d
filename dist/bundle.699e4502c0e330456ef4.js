/*! For license information please see bundle.699e4502c0e330456ef4.js.LICENSE.txt */
(() => {
  "use strict";
  const e = 100,
    t = 1e3,
    n = 1001,
    i = 1002,
    r = 1003,
    o = 1004,
    s = 1005,
    a = 1006,
    c = 1008,
    l = 1012,
    h = 1014,
    u = 1015,
    d = 1016,
    p = 1020,
    f = 1022,
    m = 1023,
    g = 1026,
    v = 1027,
    y = 2300,
    x = 2301,
    _ = 2302,
    b = 2400,
    w = 2401,
    M = 2402,
    S = 3e3,
    E = 3001,
    T = 7680,
    A = 35044,
    L = 35048,
    R = "300 es";
  function C() {}
  Object.assign(C.prototype, {
    addEventListener: function (e, t) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
    },
    hasEventListener: function (e, t) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[e] && -1 !== n[e].indexOf(t);
    },
    removeEventListener: function (e, t) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[e];
      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }
    },
    dispatchEvent: function (e) {
      if (void 0 === this._listeners) return;
      const t = this._listeners[e.type];
      if (void 0 !== t) {
        e.target = this;
        const n = t.slice(0);
        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
      }
    },
  });
  const P = [];
  for (let e = 0; e < 256; e++) P[e] = (e < 16 ? "0" : "") + e.toString(16);
  let O = 1234567;
  const I = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function () {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0;
      return (
        P[255 & e] +
        P[(e >> 8) & 255] +
        P[(e >> 16) & 255] +
        P[(e >> 24) & 255] +
        "-" +
        P[255 & t] +
        P[(t >> 8) & 255] +
        "-" +
        P[((t >> 16) & 15) | 64] +
        P[(t >> 24) & 255] +
        "-" +
        P[(63 & n) | 128] +
        P[(n >> 8) & 255] +
        "-" +
        P[(n >> 16) & 255] +
        P[(n >> 24) & 255] +
        P[255 & i] +
        P[(i >> 8) & 255] +
        P[(i >> 16) & 255] +
        P[(i >> 24) & 255]
      ).toUpperCase();
    },
    clamp: function (e, t, n) {
      return Math.max(t, Math.min(n, e));
    },
    euclideanModulo: function (e, t) {
      return ((e % t) + t) % t;
    },
    mapLinear: function (e, t, n, i, r) {
      return i + ((e - t) * (r - i)) / (n - t);
    },
    lerp: function (e, t, n) {
      return (1 - n) * e + n * t;
    },
    smoothstep: function (e, t, n) {
      return e <= t
        ? 0
        : e >= n
        ? 1
        : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
    },
    smootherstep: function (e, t, n) {
      return e <= t
        ? 0
        : e >= n
        ? 1
        : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
    },
    randInt: function (e, t) {
      return e + Math.floor(Math.random() * (t - e + 1));
    },
    randFloat: function (e, t) {
      return e + Math.random() * (t - e);
    },
    randFloatSpread: function (e) {
      return e * (0.5 - Math.random());
    },
    seededRandom: function (e) {
      return (
        void 0 !== e && (O = e % 2147483647),
        (O = (16807 * O) % 2147483647),
        (O - 1) / 2147483646
      );
    },
    degToRad: function (e) {
      return e * I.DEG2RAD;
    },
    radToDeg: function (e) {
      return e * I.RAD2DEG;
    },
    isPowerOfTwo: function (e) {
      return 0 == (e & (e - 1)) && 0 !== e;
    },
    ceilPowerOfTwo: function (e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    },
    floorPowerOfTwo: function (e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    },
    setQuaternionFromProperEuler: function (e, t, n, i, r) {
      const o = Math.cos,
        s = Math.sin,
        a = o(n / 2),
        c = s(n / 2),
        l = o((t + i) / 2),
        h = s((t + i) / 2),
        u = o((t - i) / 2),
        d = s((t - i) / 2),
        p = o((i - t) / 2),
        f = s((i - t) / 2);
      switch (r) {
        case "XYX":
          e.set(a * h, c * u, c * d, a * l);
          break;
        case "YZY":
          e.set(c * d, a * h, c * u, a * l);
          break;
        case "ZXZ":
          e.set(c * u, c * d, a * h, a * l);
          break;
        case "XZX":
          e.set(a * h, c * f, c * p, a * l);
          break;
        case "YXY":
          e.set(c * p, a * h, c * f, a * l);
          break;
        case "ZYZ":
          e.set(c * f, c * p, a * h, a * l);
          break;
        default:
          console.warn(
            "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
              r
          );
      }
    },
  };
  class N {
    constructor(e = 0, t = 0) {
      Object.defineProperty(this, "isVector2", { value: !0 }),
        (this.x = e),
        (this.y = t);
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), this;
    }
    add(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(e, t))
        : ((this.x += e.x), (this.y += e.y), this);
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
      return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
      return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(e, t))
        : ((this.x -= e.x), (this.y -= e.y), this);
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
      return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x,
        n = this.y,
        i = e.elements;
      return (
        (this.x = i[0] * t + i[3] * n + i[6]),
        (this.y = i[1] * t + i[4] * n + i[7]),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        this
      );
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(e, Math.min(t, n))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        n = this.y - e.y;
      return t * t + n * n;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
      );
    }
    lerpVectors(e, t, n) {
      return (
        (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
      );
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t, n) {
      return (
        void 0 !== n &&
          console.warn(
            "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = e.getX(t)),
        (this.y = e.getY(t)),
        this
      );
    }
    rotateAround(e, t) {
      const n = Math.cos(t),
        i = Math.sin(t),
        r = this.x - e.x,
        o = this.y - e.y;
      return (
        (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
  }
  class D {
    constructor() {
      Object.defineProperty(this, "isMatrix3", { value: !0 }),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    set(e, t, n, i, r, o, s, a, c) {
      const l = this.elements;
      return (
        (l[0] = e),
        (l[1] = i),
        (l[2] = s),
        (l[3] = t),
        (l[4] = r),
        (l[5] = a),
        (l[6] = n),
        (l[7] = o),
        (l[8] = c),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements,
        n = e.elements;
      return (
        (t[0] = n[0]),
        (t[1] = n[1]),
        (t[2] = n[2]),
        (t[3] = n[3]),
        (t[4] = n[4]),
        (t[5] = n[5]),
        (t[6] = n[6]),
        (t[7] = n[7]),
        (t[8] = n[8]),
        this
      );
    }
    extractBasis(e, t, n) {
      return (
        e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return (
        this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements,
        i = t.elements,
        r = this.elements,
        o = n[0],
        s = n[3],
        a = n[6],
        c = n[1],
        l = n[4],
        h = n[7],
        u = n[2],
        d = n[5],
        p = n[8],
        f = i[0],
        m = i[3],
        g = i[6],
        v = i[1],
        y = i[4],
        x = i[7],
        _ = i[2],
        b = i[5],
        w = i[8];
      return (
        (r[0] = o * f + s * v + a * _),
        (r[3] = o * m + s * y + a * b),
        (r[6] = o * g + s * x + a * w),
        (r[1] = c * f + l * v + h * _),
        (r[4] = c * m + l * y + h * b),
        (r[7] = c * g + l * x + h * w),
        (r[2] = u * f + d * v + p * _),
        (r[5] = u * m + d * y + p * b),
        (r[8] = u * g + d * x + p * w),
        this
      );
    }
    multiplyScalar(e) {
      const t = this.elements;
      return (
        (t[0] *= e),
        (t[3] *= e),
        (t[6] *= e),
        (t[1] *= e),
        (t[4] *= e),
        (t[7] *= e),
        (t[2] *= e),
        (t[5] *= e),
        (t[8] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        n = e[1],
        i = e[2],
        r = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        c = e[7],
        l = e[8];
      return (
        t * o * l - t * s * c - n * r * l + n * s * a + i * r * c - i * o * a
      );
    }
    invert() {
      const e = this.elements,
        t = e[0],
        n = e[1],
        i = e[2],
        r = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        c = e[7],
        l = e[8],
        h = l * o - s * c,
        u = s * a - l * r,
        d = c * r - o * a,
        p = t * h + n * u + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (e[0] = h * f),
        (e[1] = (i * c - l * n) * f),
        (e[2] = (s * n - i * o) * f),
        (e[3] = u * f),
        (e[4] = (l * t - i * a) * f),
        (e[5] = (i * r - s * t) * f),
        (e[6] = d * f),
        (e[7] = (n * a - c * t) * f),
        (e[8] = (o * t - n * r) * f),
        this
      );
    }
    transpose() {
      let e;
      const t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[3]),
        (t[3] = e),
        (e = t[2]),
        (t[2] = t[6]),
        (t[6] = e),
        (e = t[5]),
        (t[5] = t[7]),
        (t[7] = e),
        this
      );
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).copy(this).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return (
        (e[0] = t[0]),
        (e[1] = t[3]),
        (e[2] = t[6]),
        (e[3] = t[1]),
        (e[4] = t[4]),
        (e[5] = t[7]),
        (e[6] = t[2]),
        (e[7] = t[5]),
        (e[8] = t[8]),
        this
      );
    }
    setUvTransform(e, t, n, i, r, o, s) {
      const a = Math.cos(r),
        c = Math.sin(r);
      return (
        this.set(
          n * a,
          n * c,
          -n * (a * o + c * s) + o + e,
          -i * c,
          i * a,
          -i * (-c * o + a * s) + s + t,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(e, t) {
      const n = this.elements;
      return (
        (n[0] *= e),
        (n[3] *= e),
        (n[6] *= e),
        (n[1] *= t),
        (n[4] *= t),
        (n[7] *= t),
        this
      );
    }
    rotate(e) {
      const t = Math.cos(e),
        n = Math.sin(e),
        i = this.elements,
        r = i[0],
        o = i[3],
        s = i[6],
        a = i[1],
        c = i[4],
        l = i[7];
      return (
        (i[0] = t * r + n * a),
        (i[3] = t * o + n * c),
        (i[6] = t * s + n * l),
        (i[1] = -n * r + t * a),
        (i[4] = -n * o + t * c),
        (i[7] = -n * s + t * l),
        this
      );
    }
    translate(e, t) {
      const n = this.elements;
      return (
        (n[0] += e * n[2]),
        (n[3] += e * n[5]),
        (n[6] += e * n[8]),
        (n[1] += t * n[2]),
        (n[4] += t * n[5]),
        (n[7] += t * n[8]),
        this
      );
    }
    equals(e) {
      const t = this.elements,
        n = e.elements;
      for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return (
        (e[t] = n[0]),
        (e[t + 1] = n[1]),
        (e[t + 2] = n[2]),
        (e[t + 3] = n[3]),
        (e[t + 4] = n[4]),
        (e[t + 5] = n[5]),
        (e[t + 6] = n[6]),
        (e[t + 7] = n[7]),
        (e[t + 8] = n[8]),
        e
      );
    }
  }
  let F;
  const U = {
    getDataURL: function (e) {
      if (/^data:/i.test(e.src)) return e.src;
      if ("undefined" == typeof HTMLCanvasElement) return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        void 0 === F &&
          (F = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas"
          )),
          (F.width = e.width),
          (F.height = e.height);
        const n = F.getContext("2d");
        e instanceof ImageData
          ? n.putImageData(e, 0, 0)
          : n.drawImage(e, 0, 0, e.width, e.height),
          (t = F);
      }
      return t.width > 2048 || t.height > 2048
        ? t.toDataURL("image/jpeg", 0.6)
        : t.toDataURL("image/png");
    },
  };
  let k = 0;
  function B(
    e = B.DEFAULT_IMAGE,
    t = B.DEFAULT_MAPPING,
    n = 1001,
    i = 1001,
    r = 1006,
    o = 1008,
    s = 1023,
    a = 1009,
    c = 1,
    l = 3e3
  ) {
    Object.defineProperty(this, "id", { value: k++ }),
      (this.uuid = I.generateUUID()),
      (this.name = ""),
      (this.image = e),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = s),
      (this.internalFormat = null),
      (this.type = a),
      (this.offset = new N(0, 0)),
      (this.repeat = new N(1, 1)),
      (this.center = new N(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new D()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = l),
      (this.version = 0),
      (this.onUpdate = null);
  }
  function z(e) {
    return ("undefined" != typeof HTMLImageElement &&
      e instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        e instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
      ? U.getDataURL(e)
      : e.data
      ? {
          data: Array.prototype.slice.call(e.data),
          width: e.width,
          height: e.height,
          type: e.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  (B.DEFAULT_IMAGE = void 0),
    (B.DEFAULT_MAPPING = 300),
    (B.prototype = Object.assign(Object.create(C.prototype), {
      constructor: B,
      isTexture: !0,
      updateMatrix: function () {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (e) {
        return (
          (this.name = e.name),
          (this.image = e.image),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          this
        );
      },
      toJSON: function (e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
          return e.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          const i = this.image;
          if (
            (void 0 === i.uuid && (i.uuid = I.generateUUID()),
            !t && void 0 === e.images[i.uuid])
          ) {
            let t;
            if (Array.isArray(i)) {
              t = [];
              for (let e = 0, n = i.length; e < n; e++)
                i[e].isDataTexture ? t.push(z(i[e].image)) : t.push(z(i[e]));
            } else t = z(i);
            e.images[i.uuid] = { uuid: i.uuid, url: t };
          }
          n.image = i.uuid;
        }
        return t || (e.textures[this.uuid] = n), n;
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
      transformUv: function (e) {
        if (300 !== this.mapping) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case t:
              e.x = e.x - Math.floor(e.x);
              break;
            case n:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case i:
              1 === Math.abs(Math.floor(e.x) % 2)
                ? (e.x = Math.ceil(e.x) - e.x)
                : (e.x = e.x - Math.floor(e.x));
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case t:
              e.y = e.y - Math.floor(e.y);
              break;
            case n:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case i:
              1 === Math.abs(Math.floor(e.y) % 2)
                ? (e.y = Math.ceil(e.y) - e.y)
                : (e.y = e.y - Math.floor(e.y));
          }
        return this.flipY && (e.y = 1 - e.y), e;
      },
    })),
    Object.defineProperty(B.prototype, "needsUpdate", {
      set: function (e) {
        !0 === e && this.version++;
      },
    });
  class H {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      Object.defineProperty(this, "isVector4", { value: !0 }),
        (this.x = e),
        (this.y = t),
        (this.z = n),
        (this.w = i);
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, n, i) {
      return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setW(e) {
      return (this.w = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.z = e.z),
        (this.w = void 0 !== e.w ? e.w : 1),
        this
      );
    }
    add(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(e, t))
        : ((this.x += e.x),
          (this.y += e.y),
          (this.z += e.z),
          (this.w += e.w),
          this);
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x),
        (this.y = e.y + t.y),
        (this.z = e.z + t.z),
        (this.w = e.w + t.w),
        this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t),
        (this.y += e.y * t),
        (this.z += e.z * t),
        (this.w += e.w * t),
        this
      );
    }
    sub(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(e, t))
        : ((this.x -= e.x),
          (this.y -= e.y),
          (this.z -= e.z),
          (this.w -= e.w),
          this);
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x),
        (this.y = e.y - t.y),
        (this.z = e.z - t.z),
        (this.w = e.w - t.w),
        this
      );
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
      const t = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        o = e.elements;
      return (
        (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
        (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
        (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
        (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
        this
      );
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return (
        t < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(e) {
      let t, n, i, r;
      const o = 0.01,
        s = 0.1,
        a = e.elements,
        c = a[0],
        l = a[4],
        h = a[8],
        u = a[1],
        d = a[5],
        p = a[9],
        f = a[2],
        m = a[6],
        g = a[10];
      if (Math.abs(l - u) < o && Math.abs(h - f) < o && Math.abs(p - m) < o) {
        if (
          Math.abs(l + u) < s &&
          Math.abs(h + f) < s &&
          Math.abs(p + m) < s &&
          Math.abs(c + d + g - 3) < s
        )
          return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        const e = (c + 1) / 2,
          a = (d + 1) / 2,
          v = (g + 1) / 2,
          y = (l + u) / 4,
          x = (h + f) / 4,
          _ = (p + m) / 4;
        return (
          e > a && e > v
            ? e < o
              ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
              : ((n = Math.sqrt(e)), (i = y / n), (r = x / n))
            : a > v
            ? a < o
              ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
              : ((i = Math.sqrt(a)), (n = y / i), (r = _ / i))
            : v < o
            ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
            : ((r = Math.sqrt(v)), (n = x / r), (i = _ / r)),
          this.set(n, i, r, t),
          this
        );
      }
      let v = Math.sqrt(
        (m - p) * (m - p) + (h - f) * (h - f) + (u - l) * (u - l)
      );
      return (
        Math.abs(v) < 0.001 && (v = 1),
        (this.x = (m - p) / v),
        (this.y = (h - f) / v),
        (this.z = (u - l) / v),
        (this.w = Math.acos((c + d + g - 1) / 2)),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        (this.w = Math.min(this.w, e.w)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        (this.w = Math.max(this.w, e.w)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        (this.w = Math.max(e.w, Math.min(t.w, this.w))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        (this.w = Math.max(e, Math.min(t, this.w))),
        this
      );
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(e, Math.min(t, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        (this.w += (e.w - this.w) * t),
        this
      );
    }
    lerpVectors(e, t, n) {
      return (
        (this.x = e.x + (t.x - e.x) * n),
        (this.y = e.y + (t.y - e.y) * n),
        (this.z = e.z + (t.z - e.z) * n),
        (this.w = e.w + (t.w - e.w) * n),
        this
      );
    }
    equals(e) {
      return (
        e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this.x = e[t]),
        (this.y = e[t + 1]),
        (this.z = e[t + 2]),
        (this.w = e[t + 3]),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this.x),
        (e[t + 1] = this.y),
        (e[t + 2] = this.z),
        (e[t + 3] = this.w),
        e
      );
    }
    fromBufferAttribute(e, t, n) {
      return (
        void 0 !== n &&
          console.warn(
            "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = e.getX(t)),
        (this.y = e.getY(t)),
        (this.z = e.getZ(t)),
        (this.w = e.getW(t)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
  }
  function G(e, t, n) {
    (this.width = e),
      (this.height = t),
      (this.scissor = new H(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new H(0, 0, e, t)),
      (n = n || {}),
      (this.texture = new B(
        void 0,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.encoding
      )),
      (this.texture.image = {}),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.generateMipmaps =
        void 0 !== n.generateMipmaps && n.generateMipmaps),
      (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : a),
      (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
      (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
      (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
  }
  function V(e, t, n) {
    G.call(this, e, t, n), (this.samples = 4);
  }
  (G.prototype = Object.assign(Object.create(C.prototype), {
    constructor: G,
    isWebGLRenderTarget: !0,
    setSize: function (e, t) {
      (this.width === e && this.height === t) ||
        ((this.width = e),
        (this.height = t),
        (this.texture.image.width = e),
        (this.texture.image.height = t),
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t);
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (e) {
      return (
        (this.width = e.width),
        (this.height = e.height),
        this.viewport.copy(e.viewport),
        (this.texture = e.texture.clone()),
        (this.depthBuffer = e.depthBuffer),
        (this.stencilBuffer = e.stencilBuffer),
        (this.depthTexture = e.depthTexture),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    (V.prototype = Object.assign(Object.create(G.prototype), {
      constructor: V,
      isWebGLMultisampleRenderTarget: !0,
      copy: function (e) {
        return G.prototype.copy.call(this, e), (this.samples = e.samples), this;
      },
    }));
  class j {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      Object.defineProperty(this, "isQuaternion", { value: !0 }),
        (this._x = e),
        (this._y = t),
        (this._z = n),
        (this._w = i);
    }
    static slerp(e, t, n, i) {
      return n.copy(e).slerp(t, i);
    }
    static slerpFlat(e, t, n, i, r, o, s) {
      let a = n[i + 0],
        c = n[i + 1],
        l = n[i + 2],
        h = n[i + 3];
      const u = r[o + 0],
        d = r[o + 1],
        p = r[o + 2],
        f = r[o + 3];
      if (h !== f || a !== u || c !== d || l !== p) {
        let e = 1 - s;
        const t = a * u + c * d + l * p + h * f,
          n = t >= 0 ? 1 : -1,
          i = 1 - t * t;
        if (i > Number.EPSILON) {
          const r = Math.sqrt(i),
            o = Math.atan2(r, t * n);
          (e = Math.sin(e * o) / r), (s = Math.sin(s * o) / r);
        }
        const r = s * n;
        if (
          ((a = a * e + u * r),
          (c = c * e + d * r),
          (l = l * e + p * r),
          (h = h * e + f * r),
          e === 1 - s)
        ) {
          const e = 1 / Math.sqrt(a * a + c * c + l * l + h * h);
          (a *= e), (c *= e), (l *= e), (h *= e);
        }
      }
      (e[t] = a), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = h);
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, o) {
      const s = n[i],
        a = n[i + 1],
        c = n[i + 2],
        l = n[i + 3],
        h = r[o],
        u = r[o + 1],
        d = r[o + 2],
        p = r[o + 3];
      return (
        (e[t] = s * p + l * h + a * d - c * u),
        (e[t + 1] = a * p + l * u + c * h - s * d),
        (e[t + 2] = c * p + l * d + s * u - a * h),
        (e[t + 3] = l * p - s * h - a * u - c * d),
        e
      );
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      (this._w = e), this._onChangeCallback();
    }
    set(e, t, n, i) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = n),
        (this._w = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return (
        (this._x = e.x),
        (this._y = e.y),
        (this._z = e.z),
        (this._w = e.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(e, t) {
      if (!e || !e.isEuler)
        throw new Error(
          "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
        );
      const n = e._x,
        i = e._y,
        r = e._z,
        o = e._order,
        s = Math.cos,
        a = Math.sin,
        c = s(n / 2),
        l = s(i / 2),
        h = s(r / 2),
        u = a(n / 2),
        d = a(i / 2),
        p = a(r / 2);
      switch (o) {
        case "XYZ":
          (this._x = u * l * h + c * d * p),
            (this._y = c * d * h - u * l * p),
            (this._z = c * l * p + u * d * h),
            (this._w = c * l * h - u * d * p);
          break;
        case "YXZ":
          (this._x = u * l * h + c * d * p),
            (this._y = c * d * h - u * l * p),
            (this._z = c * l * p - u * d * h),
            (this._w = c * l * h + u * d * p);
          break;
        case "ZXY":
          (this._x = u * l * h - c * d * p),
            (this._y = c * d * h + u * l * p),
            (this._z = c * l * p + u * d * h),
            (this._w = c * l * h - u * d * p);
          break;
        case "ZYX":
          (this._x = u * l * h - c * d * p),
            (this._y = c * d * h + u * l * p),
            (this._z = c * l * p - u * d * h),
            (this._w = c * l * h + u * d * p);
          break;
        case "YZX":
          (this._x = u * l * h + c * d * p),
            (this._y = c * d * h + u * l * p),
            (this._z = c * l * p - u * d * h),
            (this._w = c * l * h - u * d * p);
          break;
        case "XZY":
          (this._x = u * l * h - c * d * p),
            (this._y = c * d * h - u * l * p),
            (this._z = c * l * p + u * d * h),
            (this._w = c * l * h + u * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              o
          );
      }
      return !1 !== t && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      const n = t / 2,
        i = Math.sin(n);
      return (
        (this._x = e.x * i),
        (this._y = e.y * i),
        (this._z = e.z * i),
        (this._w = Math.cos(n)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e) {
      const t = e.elements,
        n = t[0],
        i = t[4],
        r = t[8],
        o = t[1],
        s = t[5],
        a = t[9],
        c = t[2],
        l = t[6],
        h = t[10],
        u = n + s + h;
      if (u > 0) {
        const e = 0.5 / Math.sqrt(u + 1);
        (this._w = 0.25 / e),
          (this._x = (l - a) * e),
          (this._y = (r - c) * e),
          (this._z = (o - i) * e);
      } else if (n > s && n > h) {
        const e = 2 * Math.sqrt(1 + n - s - h);
        (this._w = (l - a) / e),
          (this._x = 0.25 * e),
          (this._y = (i + o) / e),
          (this._z = (r + c) / e);
      } else if (s > h) {
        const e = 2 * Math.sqrt(1 + s - n - h);
        (this._w = (r - c) / e),
          (this._x = (i + o) / e),
          (this._y = 0.25 * e),
          (this._z = (a + l) / e);
      } else {
        const e = 2 * Math.sqrt(1 + h - n - s);
        (this._w = (o - i) / e),
          (this._x = (r + c) / e),
          (this._y = (a + l) / e),
          (this._z = 0.25 * e);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let n = e.dot(t) + 1;
      return (
        n < 1e-6
          ? ((n = 0),
            Math.abs(e.x) > Math.abs(e.z)
              ? ((this._x = -e.y),
                (this._y = e.x),
                (this._z = 0),
                (this._w = n))
              : ((this._x = 0),
                (this._y = -e.z),
                (this._z = e.y),
                (this._w = n)))
          : ((this._x = e.y * t.z - e.z * t.y),
            (this._y = e.z * t.x - e.x * t.z),
            (this._z = e.x * t.y - e.y * t.x),
            (this._w = n)),
        this.normalize()
      );
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(I.clamp(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      const n = this.angleTo(e);
      if (0 === n) return this;
      const i = Math.min(1, t / n);
      return this.slerp(e, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let e = this.length();
      return (
        0 === e
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((e = 1 / e),
            (this._x = this._x * e),
            (this._y = this._y * e),
            (this._z = this._z * e),
            (this._w = this._w * e)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
          ),
          this.multiplyQuaternions(e, t))
        : this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      const n = e._x,
        i = e._y,
        r = e._z,
        o = e._w,
        s = t._x,
        a = t._y,
        c = t._z,
        l = t._w;
      return (
        (this._x = n * l + o * s + i * c - r * a),
        (this._y = i * l + o * a + r * s - n * c),
        (this._z = r * l + o * c + n * a - i * s),
        (this._w = o * l - n * s - i * a - r * c),
        this._onChangeCallback(),
        this
      );
    }
    slerp(e, t) {
      if (0 === t) return this;
      if (1 === t) return this.copy(e);
      const n = this._x,
        i = this._y,
        r = this._z,
        o = this._w;
      let s = o * e._w + n * e._x + i * e._y + r * e._z;
      if (
        (s < 0
          ? ((this._w = -e._w),
            (this._x = -e._x),
            (this._y = -e._y),
            (this._z = -e._z),
            (s = -s))
          : this.copy(e),
        s >= 1)
      )
        return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
      const a = 1 - s * s;
      if (a <= Number.EPSILON) {
        const e = 1 - t;
        return (
          (this._w = e * o + t * this._w),
          (this._x = e * n + t * this._x),
          (this._y = e * i + t * this._y),
          (this._z = e * r + t * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      }
      const c = Math.sqrt(a),
        l = Math.atan2(c, s),
        h = Math.sin((1 - t) * l) / c,
        u = Math.sin(t * l) / c;
      return (
        (this._w = o * h + this._w * u),
        (this._x = n * h + this._x * u),
        (this._y = i * h + this._y * u),
        (this._z = r * h + this._z * u),
        this._onChangeCallback(),
        this
      );
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._w === this._w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this._x = e[t]),
        (this._y = e[t + 1]),
        (this._z = e[t + 2]),
        (this._w = e[t + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._w),
        e
      );
    }
    fromBufferAttribute(e, t) {
      return (
        (this._x = e.getX(t)),
        (this._y = e.getY(t)),
        (this._z = e.getZ(t)),
        (this._w = e.getW(t)),
        this
      );
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
  }
  class W {
    constructor(e = 0, t = 0, n = 0) {
      Object.defineProperty(this, "isVector3", { value: !0 }),
        (this.x = e),
        (this.y = t),
        (this.z = n);
    }
    set(e, t, n) {
      return (
        void 0 === n && (n = this.z),
        (this.x = e),
        (this.y = t),
        (this.z = n),
        this
      );
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
          ),
          this.addVectors(e, t))
        : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
      );
    }
    sub(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
          ),
          this.subVectors(e, t))
        : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
      );
    }
    multiply(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
          ),
          this.multiplyVectors(e, t))
        : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
      return (
        (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
      );
    }
    applyEuler(e) {
      return (
        (e && e.isEuler) ||
          console.error(
            "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
          ),
        this.applyQuaternion(q.setFromEuler(e))
      );
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(q.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      const t = this.x,
        n = this.y,
        i = this.z,
        r = e.elements;
      return (
        (this.x = r[0] * t + r[3] * n + r[6] * i),
        (this.y = r[1] * t + r[4] * n + r[7] * i),
        (this.z = r[2] * t + r[5] * n + r[8] * i),
        this
      );
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      const t = this.x,
        n = this.y,
        i = this.z,
        r = e.elements,
        o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o),
        (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o),
        (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o),
        this
      );
    }
    applyQuaternion(e) {
      const t = this.x,
        n = this.y,
        i = this.z,
        r = e.x,
        o = e.y,
        s = e.z,
        a = e.w,
        c = a * t + o * i - s * n,
        l = a * n + s * t - r * i,
        h = a * i + r * n - o * t,
        u = -r * t - o * n - s * i;
      return (
        (this.x = c * a + u * -r + l * -s - h * -o),
        (this.y = l * a + u * -o + h * -r - c * -s),
        (this.z = h * a + u * -s + c * -o - l * -r),
        this
      );
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
        e.projectionMatrix
      );
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
        e.matrixWorld
      );
    }
    transformDirection(e) {
      const t = this.x,
        n = this.y,
        i = this.z,
        r = e.elements;
      return (
        (this.x = r[0] * t + r[4] * n + r[8] * i),
        (this.y = r[1] * t + r[5] * n + r[9] * i),
        (this.z = r[2] * t + r[6] * n + r[10] * i),
        this.normalize()
      );
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        this
      );
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(e, Math.min(t, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        this
      );
    }
    lerpVectors(e, t, n) {
      return (
        (this.x = e.x + (t.x - e.x) * n),
        (this.y = e.y + (t.y - e.y) * n),
        (this.z = e.z + (t.z - e.z) * n),
        this
      );
    }
    cross(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
          ),
          this.crossVectors(e, t))
        : this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      const n = e.x,
        i = e.y,
        r = e.z,
        o = t.x,
        s = t.y,
        a = t.z;
      return (
        (this.x = i * a - r * s),
        (this.y = r * o - n * a),
        (this.z = n * s - i * o),
        this
      );
    }
    projectOnVector(e) {
      const t = e.lengthSq();
      if (0 === t) return this.set(0, 0, 0);
      const n = e.dot(this) / t;
      return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
      return X.copy(this).projectOnVector(e), this.sub(X);
    }
    reflect(e) {
      return this.sub(X.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (0 === t) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(I.clamp(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        n = this.y - e.y,
        i = this.z - e.z;
      return t * t + n * n + i * i;
    }
    manhattanDistanceTo(e) {
      return (
        Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
      );
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
      const i = Math.sin(t) * e;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(t) * e),
        (this.z = i * Math.cos(n)),
        this
      );
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
      return (
        (this.x = e * Math.sin(t)),
        (this.y = n),
        (this.z = e * Math.cos(t)),
        this
      );
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(),
        n = this.setFromMatrixColumn(e, 1).length(),
        i = this.setFromMatrixColumn(e, 2).length();
      return (this.x = t), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, 4 * t);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, 3 * t);
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t, n) {
      return (
        void 0 !== n &&
          console.warn(
            "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
          ),
        (this.x = e.getX(t)),
        (this.y = e.getY(t)),
        (this.z = e.getZ(t)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
  }
  const X = new W(),
    q = new j();
  class Y {
    constructor(e, t) {
      Object.defineProperty(this, "isBox3", { value: !0 }),
        (this.min = void 0 !== e ? e : new W(1 / 0, 1 / 0, 1 / 0)),
        (this.max = void 0 !== t ? t : new W(-1 / 0, -1 / 0, -1 / 0));
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      let t = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        o = -1 / 0,
        s = -1 / 0;
      for (let a = 0, c = e.length; a < c; a += 3) {
        const c = e[a],
          l = e[a + 1],
          h = e[a + 2];
        c < t && (t = c),
          l < n && (n = l),
          h < i && (i = h),
          c > r && (r = c),
          l > o && (o = l),
          h > s && (s = h);
      }
      return this.min.set(t, n, i), this.max.set(r, o, s), this;
    }
    setFromBufferAttribute(e) {
      let t = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        o = -1 / 0,
        s = -1 / 0;
      for (let a = 0, c = e.count; a < c; a++) {
        const c = e.getX(a),
          l = e.getY(a),
          h = e.getZ(a);
        c < t && (t = c),
          l < n && (n = l),
          h < i && (i = h),
          c > r && (r = c),
          l > o && (o = l),
          h > s && (s = h);
      }
      return this.min.set(t, n, i), this.max.set(r, o, s), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = K.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    setFromObject(e) {
      return this.makeEmpty(), this.expandByObject(e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(e) {
      return (
        void 0 === e &&
          (console.warn("THREE.Box3: .getCenter() target is now required"),
          (e = new W())),
        this.isEmpty()
          ? e.set(0, 0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5)
      );
    }
    getSize(e) {
      return (
        void 0 === e &&
          (console.warn("THREE.Box3: .getSize() target is now required"),
          (e = new W())),
        this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
      );
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e) {
      e.updateWorldMatrix(!1, !1);
      const t = e.geometry;
      void 0 !== t &&
        (null === t.boundingBox && t.computeBoundingBox(),
        Q.copy(t.boundingBox),
        Q.applyMatrix4(e.matrixWorld),
        this.union(Q));
      const n = e.children;
      for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
      return this;
    }
    containsPoint(e) {
      return !(
        e.x < this.min.x ||
        e.x > this.max.x ||
        e.y < this.min.y ||
        e.y > this.max.y ||
        e.z < this.min.z ||
        e.z > this.max.z
      );
    }
    containsBox(e) {
      return (
        this.min.x <= e.min.x &&
        e.max.x <= this.max.x &&
        this.min.y <= e.min.y &&
        e.max.y <= this.max.y &&
        this.min.z <= e.min.z &&
        e.max.z <= this.max.z
      );
    }
    getParameter(e, t) {
      return (
        void 0 === t &&
          (console.warn("THREE.Box3: .getParameter() target is now required"),
          (t = new W())),
        t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y),
          (e.z - this.min.z) / (this.max.z - this.min.z)
        )
      );
    }
    intersectsBox(e) {
      return !(
        e.max.x < this.min.x ||
        e.min.x > this.max.x ||
        e.max.y < this.min.y ||
        e.min.y > this.max.y ||
        e.max.z < this.min.z ||
        e.min.z > this.max.z
      );
    }
    intersectsSphere(e) {
      return (
        this.clampPoint(e.center, K),
        K.distanceToSquared(e.center) <= e.radius * e.radius
      );
    }
    intersectsPlane(e) {
      let t, n;
      return (
        e.normal.x > 0
          ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
          : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
        e.normal.y > 0
          ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
          : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
        e.normal.z > 0
          ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
          : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
        t <= -e.constant && n >= -e.constant
      );
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return !1;
      this.getCenter(oe),
        se.subVectors(this.max, oe),
        $.subVectors(e.a, oe),
        ee.subVectors(e.b, oe),
        te.subVectors(e.c, oe),
        ne.subVectors(ee, $),
        ie.subVectors(te, ee),
        re.subVectors($, te);
      let t = [
        0,
        -ne.z,
        ne.y,
        0,
        -ie.z,
        ie.y,
        0,
        -re.z,
        re.y,
        ne.z,
        0,
        -ne.x,
        ie.z,
        0,
        -ie.x,
        re.z,
        0,
        -re.x,
        -ne.y,
        ne.x,
        0,
        -ie.y,
        ie.x,
        0,
        -re.y,
        re.x,
        0,
      ];
      return (
        !!Z(t, $, ee, te, se) &&
        ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!Z(t, $, ee, te, se) &&
          (ae.crossVectors(ne, ie),
          (t = [ae.x, ae.y, ae.z]),
          Z(t, $, ee, te, se)))
      );
    }
    clampPoint(e, t) {
      return (
        void 0 === t &&
          (console.warn("THREE.Box3: .clampPoint() target is now required"),
          (t = new W())),
        t.copy(e).clamp(this.min, this.max)
      );
    }
    distanceToPoint(e) {
      return K.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    getBoundingSphere(e) {
      return (
        void 0 === e &&
          console.error(
            "THREE.Box3: .getBoundingSphere() target is now required"
          ),
        this.getCenter(e.center),
        (e.radius = 0.5 * this.getSize(K).length()),
        e
      );
    }
    intersect(e) {
      return (
        this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return (
        this.isEmpty() ||
          (J[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
          J[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
          J[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
          J[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
          J[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
          J[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
          J[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
          J[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
          this.setFromPoints(J)),
        this
      );
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  function Z(e, t, n, i, r) {
    for (let o = 0, s = e.length - 3; o <= s; o += 3) {
      ce.fromArray(e, o);
      const s =
          r.x * Math.abs(ce.x) + r.y * Math.abs(ce.y) + r.z * Math.abs(ce.z),
        a = t.dot(ce),
        c = n.dot(ce),
        l = i.dot(ce);
      if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1;
    }
    return !0;
  }
  const J = [
      new W(),
      new W(),
      new W(),
      new W(),
      new W(),
      new W(),
      new W(),
      new W(),
    ],
    K = new W(),
    Q = new Y(),
    $ = new W(),
    ee = new W(),
    te = new W(),
    ne = new W(),
    ie = new W(),
    re = new W(),
    oe = new W(),
    se = new W(),
    ae = new W(),
    ce = new W(),
    le = new Y();
  class he {
    constructor(e, t) {
      (this.center = void 0 !== e ? e : new W()),
        (this.radius = void 0 !== t ? t : -1);
    }
    set(e, t) {
      return this.center.copy(e), (this.radius = t), this;
    }
    setFromPoints(e, t) {
      const n = this.center;
      void 0 !== t ? n.copy(t) : le.setFromPoints(e).getCenter(n);
      let i = 0;
      for (let t = 0, r = e.length; t < r; t++)
        i = Math.max(i, n.distanceToSquared(e[t]));
      return (this.radius = Math.sqrt(i)), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.center.copy(e.center), (this.radius = e.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const n = this.center.distanceToSquared(e);
      return (
        void 0 === t &&
          (console.warn("THREE.Sphere: .clampPoint() target is now required"),
          (t = new W())),
        t.copy(e),
        n > this.radius * this.radius &&
          (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
        t
      );
    }
    getBoundingBox(e) {
      return (
        void 0 === e &&
          (console.warn(
            "THREE.Sphere: .getBoundingBox() target is now required"
          ),
          (e = new Y())),
        this.isEmpty()
          ? (e.makeEmpty(), e)
          : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
      );
    }
    applyMatrix4(e) {
      return (
        this.center.applyMatrix4(e),
        (this.radius = this.radius * e.getMaxScaleOnAxis()),
        this
      );
    }
    translate(e) {
      return this.center.add(e), this;
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
  }
  const ue = new W(),
    de = new W(),
    pe = new W(),
    fe = new W(),
    me = new W(),
    ge = new W(),
    ve = new W();
  class ye {
    constructor(e, t) {
      (this.origin = void 0 !== e ? e : new W()),
        (this.direction = void 0 !== t ? t : new W(0, 0, -1));
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return (
        void 0 === t &&
          (console.warn("THREE.Ray: .at() target is now required"),
          (t = new W())),
        t.copy(this.direction).multiplyScalar(e).add(this.origin)
      );
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, ue)), this;
    }
    closestPointToPoint(e, t) {
      void 0 === t &&
        (console.warn(
          "THREE.Ray: .closestPointToPoint() target is now required"
        ),
        (t = new W())),
        t.subVectors(e, this.origin);
      const n = t.dot(this.direction);
      return n < 0
        ? t.copy(this.origin)
        : t.copy(this.direction).multiplyScalar(n).add(this.origin);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      const t = ue.subVectors(e, this.origin).dot(this.direction);
      return t < 0
        ? this.origin.distanceToSquared(e)
        : (ue.copy(this.direction).multiplyScalar(t).add(this.origin),
          ue.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, n, i) {
      de.copy(e).add(t).multiplyScalar(0.5),
        pe.copy(t).sub(e).normalize(),
        fe.copy(this.origin).sub(de);
      const r = 0.5 * e.distanceTo(t),
        o = -this.direction.dot(pe),
        s = fe.dot(this.direction),
        a = -fe.dot(pe),
        c = fe.lengthSq(),
        l = Math.abs(1 - o * o);
      let h, u, d, p;
      if (l > 0)
        if (((h = o * a - s), (u = o * s - a), (p = r * l), h >= 0))
          if (u >= -p)
            if (u <= p) {
              const e = 1 / l;
              (h *= e),
                (u *= e),
                (d = h * (h + o * u + 2 * s) + u * (o * h + u + 2 * a) + c);
            } else
              (u = r),
                (h = Math.max(0, -(o * u + s))),
                (d = -h * h + u * (u + 2 * a) + c);
          else
            (u = -r),
              (h = Math.max(0, -(o * u + s))),
              (d = -h * h + u * (u + 2 * a) + c);
        else
          u <= -p
            ? ((h = Math.max(0, -(-o * r + s))),
              (u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)),
              (d = -h * h + u * (u + 2 * a) + c))
            : u <= p
            ? ((h = 0),
              (u = Math.min(Math.max(-r, -a), r)),
              (d = u * (u + 2 * a) + c))
            : ((h = Math.max(0, -(o * r + s))),
              (u = h > 0 ? r : Math.min(Math.max(-r, -a), r)),
              (d = -h * h + u * (u + 2 * a) + c));
      else
        (u = o > 0 ? -r : r),
          (h = Math.max(0, -(o * u + s))),
          (d = -h * h + u * (u + 2 * a) + c);
      return (
        n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
        i && i.copy(pe).multiplyScalar(u).add(de),
        d
      );
    }
    intersectSphere(e, t) {
      ue.subVectors(e.center, this.origin);
      const n = ue.dot(this.direction),
        i = ue.dot(ue) - n * n,
        r = e.radius * e.radius;
      if (i > r) return null;
      const o = Math.sqrt(r - i),
        s = n - o,
        a = n + o;
      return s < 0 && a < 0 ? null : s < 0 ? this.at(a, t) : this.at(s, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(e.normal) + e.constant) / t;
      return n >= 0 ? n : null;
    }
    intersectPlane(e, t) {
      const n = this.distanceToPlane(e);
      return null === n ? null : this.at(n, t);
    }
    intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return 0 === t || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let n, i, r, o, s, a;
      const c = 1 / this.direction.x,
        l = 1 / this.direction.y,
        h = 1 / this.direction.z,
        u = this.origin;
      return (
        c >= 0
          ? ((n = (e.min.x - u.x) * c), (i = (e.max.x - u.x) * c))
          : ((n = (e.max.x - u.x) * c), (i = (e.min.x - u.x) * c)),
        l >= 0
          ? ((r = (e.min.y - u.y) * l), (o = (e.max.y - u.y) * l))
          : ((r = (e.max.y - u.y) * l), (o = (e.min.y - u.y) * l)),
        n > o || r > i
          ? null
          : ((r > n || n != n) && (n = r),
            (o < i || i != i) && (i = o),
            h >= 0
              ? ((s = (e.min.z - u.z) * h), (a = (e.max.z - u.z) * h))
              : ((s = (e.max.z - u.z) * h), (a = (e.min.z - u.z) * h)),
            n > a || s > i
              ? null
              : ((s > n || n != n) && (n = s),
                (a < i || i != i) && (i = a),
                i < 0 ? null : this.at(n >= 0 ? n : i, t)))
      );
    }
    intersectsBox(e) {
      return null !== this.intersectBox(e, ue);
    }
    intersectTriangle(e, t, n, i, r) {
      me.subVectors(t, e), ge.subVectors(n, e), ve.crossVectors(me, ge);
      let o,
        s = this.direction.dot(ve);
      if (s > 0) {
        if (i) return null;
        o = 1;
      } else {
        if (!(s < 0)) return null;
        (o = -1), (s = -s);
      }
      fe.subVectors(this.origin, e);
      const a = o * this.direction.dot(ge.crossVectors(fe, ge));
      if (a < 0) return null;
      const c = o * this.direction.dot(me.cross(fe));
      if (c < 0) return null;
      if (a + c > s) return null;
      const l = -o * fe.dot(ve);
      return l < 0 ? null : this.at(l / s, r);
    }
    applyMatrix4(e) {
      return (
        this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
      );
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
  }
  class xe {
    constructor() {
      Object.defineProperty(this, "isMatrix4", { value: !0 }),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    set(e, t, n, i, r, o, s, a, c, l, h, u, d, p, f, m) {
      const g = this.elements;
      return (
        (g[0] = e),
        (g[4] = t),
        (g[8] = n),
        (g[12] = i),
        (g[1] = r),
        (g[5] = o),
        (g[9] = s),
        (g[13] = a),
        (g[2] = c),
        (g[6] = l),
        (g[10] = h),
        (g[14] = u),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new xe().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements,
        n = e.elements;
      return (
        (t[0] = n[0]),
        (t[1] = n[1]),
        (t[2] = n[2]),
        (t[3] = n[3]),
        (t[4] = n[4]),
        (t[5] = n[5]),
        (t[6] = n[6]),
        (t[7] = n[7]),
        (t[8] = n[8]),
        (t[9] = n[9]),
        (t[10] = n[10]),
        (t[11] = n[11]),
        (t[12] = n[12]),
        (t[13] = n[13]),
        (t[14] = n[14]),
        (t[15] = n[15]),
        this
      );
    }
    copyPosition(e) {
      const t = this.elements,
        n = e.elements;
      return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
    }
    extractBasis(e, t, n) {
      return (
        e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(e, t, n) {
      return (
        this.set(
          e.x,
          t.x,
          n.x,
          0,
          e.y,
          t.y,
          n.y,
          0,
          e.z,
          t.z,
          n.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(e) {
      const t = this.elements,
        n = e.elements,
        i = 1 / _e.setFromMatrixColumn(e, 0).length(),
        r = 1 / _e.setFromMatrixColumn(e, 1).length(),
        o = 1 / _e.setFromMatrixColumn(e, 2).length();
      return (
        (t[0] = n[0] * i),
        (t[1] = n[1] * i),
        (t[2] = n[2] * i),
        (t[3] = 0),
        (t[4] = n[4] * r),
        (t[5] = n[5] * r),
        (t[6] = n[6] * r),
        (t[7] = 0),
        (t[8] = n[8] * o),
        (t[9] = n[9] * o),
        (t[10] = n[10] * o),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromEuler(e) {
      (e && e.isEuler) ||
        console.error(
          "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
        );
      const t = this.elements,
        n = e.x,
        i = e.y,
        r = e.z,
        o = Math.cos(n),
        s = Math.sin(n),
        a = Math.cos(i),
        c = Math.sin(i),
        l = Math.cos(r),
        h = Math.sin(r);
      if ("XYZ" === e.order) {
        const e = o * l,
          n = o * h,
          i = s * l,
          r = s * h;
        (t[0] = a * l),
          (t[4] = -a * h),
          (t[8] = c),
          (t[1] = n + i * c),
          (t[5] = e - r * c),
          (t[9] = -s * a),
          (t[2] = r - e * c),
          (t[6] = i + n * c),
          (t[10] = o * a);
      } else if ("YXZ" === e.order) {
        const e = a * l,
          n = a * h,
          i = c * l,
          r = c * h;
        (t[0] = e + r * s),
          (t[4] = i * s - n),
          (t[8] = o * c),
          (t[1] = o * h),
          (t[5] = o * l),
          (t[9] = -s),
          (t[2] = n * s - i),
          (t[6] = r + e * s),
          (t[10] = o * a);
      } else if ("ZXY" === e.order) {
        const e = a * l,
          n = a * h,
          i = c * l,
          r = c * h;
        (t[0] = e - r * s),
          (t[4] = -o * h),
          (t[8] = i + n * s),
          (t[1] = n + i * s),
          (t[5] = o * l),
          (t[9] = r - e * s),
          (t[2] = -o * c),
          (t[6] = s),
          (t[10] = o * a);
      } else if ("ZYX" === e.order) {
        const e = o * l,
          n = o * h,
          i = s * l,
          r = s * h;
        (t[0] = a * l),
          (t[4] = i * c - n),
          (t[8] = e * c + r),
          (t[1] = a * h),
          (t[5] = r * c + e),
          (t[9] = n * c - i),
          (t[2] = -c),
          (t[6] = s * a),
          (t[10] = o * a);
      } else if ("YZX" === e.order) {
        const e = o * a,
          n = o * c,
          i = s * a,
          r = s * c;
        (t[0] = a * l),
          (t[4] = r - e * h),
          (t[8] = i * h + n),
          (t[1] = h),
          (t[5] = o * l),
          (t[9] = -s * l),
          (t[2] = -c * l),
          (t[6] = n * h + i),
          (t[10] = e - r * h);
      } else if ("XZY" === e.order) {
        const e = o * a,
          n = o * c,
          i = s * a,
          r = s * c;
        (t[0] = a * l),
          (t[4] = -h),
          (t[8] = c * l),
          (t[1] = e * h + r),
          (t[5] = o * l),
          (t[9] = n * h - i),
          (t[2] = i * h - n),
          (t[6] = s * l),
          (t[10] = r * h + e);
      }
      return (
        (t[3] = 0),
        (t[7] = 0),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(e) {
      return this.compose(we, e, Me);
    }
    lookAt(e, t, n) {
      const i = this.elements;
      return (
        Te.subVectors(e, t),
        0 === Te.lengthSq() && (Te.z = 1),
        Te.normalize(),
        Se.crossVectors(n, Te),
        0 === Se.lengthSq() &&
          (1 === Math.abs(n.z) ? (Te.x += 1e-4) : (Te.z += 1e-4),
          Te.normalize(),
          Se.crossVectors(n, Te)),
        Se.normalize(),
        Ee.crossVectors(Te, Se),
        (i[0] = Se.x),
        (i[4] = Ee.x),
        (i[8] = Te.x),
        (i[1] = Se.y),
        (i[5] = Ee.y),
        (i[9] = Te.y),
        (i[2] = Se.z),
        (i[6] = Ee.z),
        (i[10] = Te.z),
        this
      );
    }
    multiply(e, t) {
      return void 0 !== t
        ? (console.warn(
            "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
          ),
          this.multiplyMatrices(e, t))
        : this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements,
        i = t.elements,
        r = this.elements,
        o = n[0],
        s = n[4],
        a = n[8],
        c = n[12],
        l = n[1],
        h = n[5],
        u = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        g = n[14],
        v = n[3],
        y = n[7],
        x = n[11],
        _ = n[15],
        b = i[0],
        w = i[4],
        M = i[8],
        S = i[12],
        E = i[1],
        T = i[5],
        A = i[9],
        L = i[13],
        R = i[2],
        C = i[6],
        P = i[10],
        O = i[14],
        I = i[3],
        N = i[7],
        D = i[11],
        F = i[15];
      return (
        (r[0] = o * b + s * E + a * R + c * I),
        (r[4] = o * w + s * T + a * C + c * N),
        (r[8] = o * M + s * A + a * P + c * D),
        (r[12] = o * S + s * L + a * O + c * F),
        (r[1] = l * b + h * E + u * R + d * I),
        (r[5] = l * w + h * T + u * C + d * N),
        (r[9] = l * M + h * A + u * P + d * D),
        (r[13] = l * S + h * L + u * O + d * F),
        (r[2] = p * b + f * E + m * R + g * I),
        (r[6] = p * w + f * T + m * C + g * N),
        (r[10] = p * M + f * A + m * P + g * D),
        (r[14] = p * S + f * L + m * O + g * F),
        (r[3] = v * b + y * E + x * R + _ * I),
        (r[7] = v * w + y * T + x * C + _ * N),
        (r[11] = v * M + y * A + x * P + _ * D),
        (r[15] = v * S + y * L + x * O + _ * F),
        this
      );
    }
    multiplyScalar(e) {
      const t = this.elements;
      return (
        (t[0] *= e),
        (t[4] *= e),
        (t[8] *= e),
        (t[12] *= e),
        (t[1] *= e),
        (t[5] *= e),
        (t[9] *= e),
        (t[13] *= e),
        (t[2] *= e),
        (t[6] *= e),
        (t[10] *= e),
        (t[14] *= e),
        (t[3] *= e),
        (t[7] *= e),
        (t[11] *= e),
        (t[15] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        n = e[4],
        i = e[8],
        r = e[12],
        o = e[1],
        s = e[5],
        a = e[9],
        c = e[13],
        l = e[2],
        h = e[6],
        u = e[10],
        d = e[14];
      return (
        e[3] *
          (+r * a * h -
            i * c * h -
            r * s * u +
            n * c * u +
            i * s * d -
            n * a * d) +
        e[7] *
          (+t * a * d -
            t * c * u +
            r * o * u -
            i * o * d +
            i * c * l -
            r * a * l) +
        e[11] *
          (+t * c * h -
            t * s * d -
            r * o * h +
            n * o * d +
            r * s * l -
            n * c * l) +
        e[15] *
          (-i * s * l -
            t * a * h +
            t * s * u +
            i * o * h -
            n * o * u +
            n * a * l)
      );
    }
    transpose() {
      const e = this.elements;
      let t;
      return (
        (t = e[1]),
        (e[1] = e[4]),
        (e[4] = t),
        (t = e[2]),
        (e[2] = e[8]),
        (e[8] = t),
        (t = e[6]),
        (e[6] = e[9]),
        (e[9] = t),
        (t = e[3]),
        (e[3] = e[12]),
        (e[12] = t),
        (t = e[7]),
        (e[7] = e[13]),
        (e[13] = t),
        (t = e[11]),
        (e[11] = e[14]),
        (e[14] = t),
        this
      );
    }
    setPosition(e, t, n) {
      const i = this.elements;
      return (
        e.isVector3
          ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
          : ((i[12] = e), (i[13] = t), (i[14] = n)),
        this
      );
    }
    invert() {
      const e = this.elements,
        t = e[0],
        n = e[1],
        i = e[2],
        r = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        c = e[7],
        l = e[8],
        h = e[9],
        u = e[10],
        d = e[11],
        p = e[12],
        f = e[13],
        m = e[14],
        g = e[15],
        v =
          h * m * c - f * u * c + f * a * d - s * m * d - h * a * g + s * u * g,
        y =
          p * u * c - l * m * c - p * a * d + o * m * d + l * a * g - o * u * g,
        x =
          l * f * c - p * h * c + p * s * d - o * f * d - l * s * g + o * h * g,
        _ =
          p * h * a - l * f * a - p * s * u + o * f * u + l * s * m - o * h * m,
        b = t * v + n * y + i * x + r * _;
      if (0 === b)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const w = 1 / b;
      return (
        (e[0] = v * w),
        (e[1] =
          (f * u * r -
            h * m * r -
            f * i * d +
            n * m * d +
            h * i * g -
            n * u * g) *
          w),
        (e[2] =
          (s * m * r -
            f * a * r +
            f * i * c -
            n * m * c -
            s * i * g +
            n * a * g) *
          w),
        (e[3] =
          (h * a * r -
            s * u * r -
            h * i * c +
            n * u * c +
            s * i * d -
            n * a * d) *
          w),
        (e[4] = y * w),
        (e[5] =
          (l * m * r -
            p * u * r +
            p * i * d -
            t * m * d -
            l * i * g +
            t * u * g) *
          w),
        (e[6] =
          (p * a * r -
            o * m * r -
            p * i * c +
            t * m * c +
            o * i * g -
            t * a * g) *
          w),
        (e[7] =
          (o * u * r -
            l * a * r +
            l * i * c -
            t * u * c -
            o * i * d +
            t * a * d) *
          w),
        (e[8] = x * w),
        (e[9] =
          (p * h * r -
            l * f * r -
            p * n * d +
            t * f * d +
            l * n * g -
            t * h * g) *
          w),
        (e[10] =
          (o * f * r -
            p * s * r +
            p * n * c -
            t * f * c -
            o * n * g +
            t * s * g) *
          w),
        (e[11] =
          (l * s * r -
            o * h * r -
            l * n * c +
            t * h * c +
            o * n * d -
            t * s * d) *
          w),
        (e[12] = _ * w),
        (e[13] =
          (l * f * i -
            p * h * i +
            p * n * u -
            t * f * u -
            l * n * m +
            t * h * m) *
          w),
        (e[14] =
          (p * s * i -
            o * f * i -
            p * n * a +
            t * f * a +
            o * n * m -
            t * s * m) *
          w),
        (e[15] =
          (o * h * i -
            l * s * i +
            l * n * a -
            t * h * a -
            o * n * u +
            t * s * u) *
          w),
        this
      );
    }
    scale(e) {
      const t = this.elements,
        n = e.x,
        i = e.y,
        r = e.z;
      return (
        (t[0] *= n),
        (t[4] *= i),
        (t[8] *= r),
        (t[1] *= n),
        (t[5] *= i),
        (t[9] *= r),
        (t[2] *= n),
        (t[6] *= i),
        (t[10] *= r),
        (t[3] *= n),
        (t[7] *= i),
        (t[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const e = this.elements,
        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, n, i));
    }
    makeTranslation(e, t, n) {
      return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      const t = Math.cos(e),
        n = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      const t = Math.cos(e),
        n = Math.sin(e);
      return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      const t = Math.cos(e),
        n = Math.sin(e);
      return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      const n = Math.cos(t),
        i = Math.sin(t),
        r = 1 - n,
        o = e.x,
        s = e.y,
        a = e.z,
        c = r * o,
        l = r * s;
      return (
        this.set(
          c * o + n,
          c * s - i * a,
          c * a + i * s,
          0,
          c * s + i * a,
          l * s + n,
          l * a - i * o,
          0,
          c * a - i * s,
          l * a + i * o,
          r * a * a + n,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(e, t, n) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, n) {
      return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, n) {
      const i = this.elements,
        r = t._x,
        o = t._y,
        s = t._z,
        a = t._w,
        c = r + r,
        l = o + o,
        h = s + s,
        u = r * c,
        d = r * l,
        p = r * h,
        f = o * l,
        m = o * h,
        g = s * h,
        v = a * c,
        y = a * l,
        x = a * h,
        _ = n.x,
        b = n.y,
        w = n.z;
      return (
        (i[0] = (1 - (f + g)) * _),
        (i[1] = (d + x) * _),
        (i[2] = (p - y) * _),
        (i[3] = 0),
        (i[4] = (d - x) * b),
        (i[5] = (1 - (u + g)) * b),
        (i[6] = (m + v) * b),
        (i[7] = 0),
        (i[8] = (p + y) * w),
        (i[9] = (m - v) * w),
        (i[10] = (1 - (u + f)) * w),
        (i[11] = 0),
        (i[12] = e.x),
        (i[13] = e.y),
        (i[14] = e.z),
        (i[15] = 1),
        this
      );
    }
    decompose(e, t, n) {
      const i = this.elements;
      let r = _e.set(i[0], i[1], i[2]).length();
      const o = _e.set(i[4], i[5], i[6]).length(),
        s = _e.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (e.x = i[12]),
        (e.y = i[13]),
        (e.z = i[14]),
        be.copy(this);
      const a = 1 / r,
        c = 1 / o,
        l = 1 / s;
      return (
        (be.elements[0] *= a),
        (be.elements[1] *= a),
        (be.elements[2] *= a),
        (be.elements[4] *= c),
        (be.elements[5] *= c),
        (be.elements[6] *= c),
        (be.elements[8] *= l),
        (be.elements[9] *= l),
        (be.elements[10] *= l),
        t.setFromRotationMatrix(be),
        (n.x = r),
        (n.y = o),
        (n.z = s),
        this
      );
    }
    makePerspective(e, t, n, i, r, o) {
      void 0 === o &&
        console.warn(
          "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
        );
      const s = this.elements,
        a = (2 * r) / (t - e),
        c = (2 * r) / (n - i),
        l = (t + e) / (t - e),
        h = (n + i) / (n - i),
        u = -(o + r) / (o - r),
        d = (-2 * o * r) / (o - r);
      return (
        (s[0] = a),
        (s[4] = 0),
        (s[8] = l),
        (s[12] = 0),
        (s[1] = 0),
        (s[5] = c),
        (s[9] = h),
        (s[13] = 0),
        (s[2] = 0),
        (s[6] = 0),
        (s[10] = u),
        (s[14] = d),
        (s[3] = 0),
        (s[7] = 0),
        (s[11] = -1),
        (s[15] = 0),
        this
      );
    }
    makeOrthographic(e, t, n, i, r, o) {
      const s = this.elements,
        a = 1 / (t - e),
        c = 1 / (n - i),
        l = 1 / (o - r),
        h = (t + e) * a,
        u = (n + i) * c,
        d = (o + r) * l;
      return (
        (s[0] = 2 * a),
        (s[4] = 0),
        (s[8] = 0),
        (s[12] = -h),
        (s[1] = 0),
        (s[5] = 2 * c),
        (s[9] = 0),
        (s[13] = -u),
        (s[2] = 0),
        (s[6] = 0),
        (s[10] = -2 * l),
        (s[14] = -d),
        (s[3] = 0),
        (s[7] = 0),
        (s[11] = 0),
        (s[15] = 1),
        this
      );
    }
    equals(e) {
      const t = this.elements,
        n = e.elements;
      for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return (
        (e[t] = n[0]),
        (e[t + 1] = n[1]),
        (e[t + 2] = n[2]),
        (e[t + 3] = n[3]),
        (e[t + 4] = n[4]),
        (e[t + 5] = n[5]),
        (e[t + 6] = n[6]),
        (e[t + 7] = n[7]),
        (e[t + 8] = n[8]),
        (e[t + 9] = n[9]),
        (e[t + 10] = n[10]),
        (e[t + 11] = n[11]),
        (e[t + 12] = n[12]),
        (e[t + 13] = n[13]),
        (e[t + 14] = n[14]),
        (e[t + 15] = n[15]),
        e
      );
    }
  }
  const _e = new W(),
    be = new xe(),
    we = new W(0, 0, 0),
    Me = new W(1, 1, 1),
    Se = new W(),
    Ee = new W(),
    Te = new W();
  class Ae {
    constructor(e = 0, t = 0, n = 0, i = Ae.DefaultOrder) {
      Object.defineProperty(this, "isEuler", { value: !0 }),
        (this._x = e),
        (this._y = t),
        (this._z = n),
        (this._order = i);
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      (this._order = e), this._onChangeCallback();
    }
    set(e, t, n, i) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = n),
        (this._order = i || this._order),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return (
        (this._x = e._x),
        (this._y = e._y),
        (this._z = e._z),
        (this._order = e._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e, t, n) {
      const i = I.clamp,
        r = e.elements,
        o = r[0],
        s = r[4],
        a = r[8],
        c = r[1],
        l = r[5],
        h = r[9],
        u = r[2],
        d = r[6],
        p = r[10];
      switch ((t = t || this._order)) {
        case "XYZ":
          (this._y = Math.asin(i(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-s, o)))
              : ((this._x = Math.atan2(d, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-i(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(c, l)))
              : ((this._y = Math.atan2(-u, o)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(i(d, -1, 1))),
            Math.abs(d) < 0.9999999
              ? ((this._y = Math.atan2(-u, p)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(c, o)));
          break;
        case "ZYX":
          (this._y = Math.asin(-i(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, o)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(i(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-u, o)))
              : ((this._x = 0), (this._y = Math.atan2(a, p)));
          break;
        case "XZY":
          (this._z = Math.asin(-i(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, o)))
              : ((this._x = Math.atan2(-h, p)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              t
          );
      }
      return (this._order = t), !1 !== n && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, n) {
      return (
        Le.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Le, t, n)
      );
    }
    setFromVector3(e, t) {
      return this.set(e.x, e.y, e.z, t || this._order);
    }
    reorder(e) {
      return Re.setFromEuler(this), this.setFromQuaternion(Re, e);
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._order === this._order
      );
    }
    fromArray(e) {
      return (
        (this._x = e[0]),
        (this._y = e[1]),
        (this._z = e[2]),
        void 0 !== e[3] && (this._order = e[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._order),
        e
      );
    }
    toVector3(e) {
      return e
        ? e.set(this._x, this._y, this._z)
        : new W(this._x, this._y, this._z);
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
  }
  (Ae.DefaultOrder = "XYZ"),
    (Ae.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
  const Le = new xe(),
    Re = new j();
  class Ce {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = (1 << e) | 0;
    }
    enable(e) {
      this.mask |= (1 << e) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= (1 << e) | 0;
    }
    disable(e) {
      this.mask &= ~((1 << e) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return 0 != (this.mask & e.mask);
    }
  }
  let Pe = 0;
  const Oe = new W(),
    Ie = new j(),
    Ne = new xe(),
    De = new W(),
    Fe = new W(),
    Ue = new W(),
    ke = new j(),
    Be = new W(1, 0, 0),
    ze = new W(0, 1, 0),
    He = new W(0, 0, 1),
    Ge = { type: "added" },
    Ve = { type: "removed" };
  function je() {
    Object.defineProperty(this, "id", { value: Pe++ }),
      (this.uuid = I.generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = je.DefaultUp.clone());
    const e = new W(),
      t = new Ae(),
      n = new j(),
      i = new W(1, 1, 1);
    t._onChange(function () {
      n.setFromEuler(t, !1);
    }),
      n._onChange(function () {
        t.setFromQuaternion(n, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new xe() },
        normalMatrix: { value: new D() },
      }),
      (this.matrix = new xe()),
      (this.matrixWorld = new xe()),
      (this.matrixAutoUpdate = je.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Ce()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  (je.DefaultUp = new W(0, 1, 0)),
    (je.DefaultMatrixAutoUpdate = !0),
    (je.prototype = Object.assign(Object.create(C.prototype), {
      constructor: je,
      isObject3D: !0,
      onBeforeRender: function () {},
      onAfterRender: function () {},
      applyMatrix4: function (e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function (e) {
        return this.quaternion.premultiply(e), this;
      },
      setRotationFromAxisAngle: function (e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      },
      setRotationFromEuler: function (e) {
        this.quaternion.setFromEuler(e, !0);
      },
      setRotationFromMatrix: function (e) {
        this.quaternion.setFromRotationMatrix(e);
      },
      setRotationFromQuaternion: function (e) {
        this.quaternion.copy(e);
      },
      rotateOnAxis: function (e, t) {
        return Ie.setFromAxisAngle(e, t), this.quaternion.multiply(Ie), this;
      },
      rotateOnWorldAxis: function (e, t) {
        return Ie.setFromAxisAngle(e, t), this.quaternion.premultiply(Ie), this;
      },
      rotateX: function (e) {
        return this.rotateOnAxis(Be, e);
      },
      rotateY: function (e) {
        return this.rotateOnAxis(ze, e);
      },
      rotateZ: function (e) {
        return this.rotateOnAxis(He, e);
      },
      translateOnAxis: function (e, t) {
        return (
          Oe.copy(e).applyQuaternion(this.quaternion),
          this.position.add(Oe.multiplyScalar(t)),
          this
        );
      },
      translateX: function (e) {
        return this.translateOnAxis(Be, e);
      },
      translateY: function (e) {
        return this.translateOnAxis(ze, e);
      },
      translateZ: function (e) {
        return this.translateOnAxis(He, e);
      },
      localToWorld: function (e) {
        return e.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function (e) {
        return e.applyMatrix4(Ne.copy(this.matrixWorld).invert());
      },
      lookAt: function (e, t, n) {
        e.isVector3 ? De.copy(e) : De.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
          Fe.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? Ne.lookAt(Fe, De, this.up)
            : Ne.lookAt(De, Fe, this.up),
          this.quaternion.setFromRotationMatrix(Ne),
          i &&
            (Ne.extractRotation(i.matrixWorld),
            Ie.setFromRotationMatrix(Ne),
            this.quaternion.premultiply(Ie.invert()));
      },
      add: function (e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              e
            ),
            this)
          : (e && e.isObject3D
              ? (null !== e.parent && e.parent.remove(e),
                (e.parent = this),
                this.children.push(e),
                e.dispatchEvent(Ge))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  e
                ),
            this);
      },
      remove: function (e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return (
          -1 !== t &&
            ((e.parent = null),
            this.children.splice(t, 1),
            e.dispatchEvent(Ve)),
          this
        );
      },
      clear: function () {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          (t.parent = null), t.dispatchEvent(Ve);
        }
        return (this.children.length = 0), this;
      },
      attach: function (e) {
        return (
          this.updateWorldMatrix(!0, !1),
          Ne.copy(this.matrixWorld).invert(),
          null !== e.parent &&
            (e.parent.updateWorldMatrix(!0, !1),
            Ne.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(Ne),
          e.updateWorldMatrix(!1, !1),
          this.add(e),
          this
        );
      },
      getObjectById: function (e) {
        return this.getObjectByProperty("id", e);
      },
      getObjectByName: function (e) {
        return this.getObjectByProperty("name", e);
      },
      getObjectByProperty: function (e, t) {
        if (this[e] === t) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
          const i = this.children[n].getObjectByProperty(e, t);
          if (void 0 !== i) return i;
        }
      },
      getWorldPosition: function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldPosition() target is now required"
            ),
            (e = new W())),
          this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      },
      getWorldQuaternion: function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldQuaternion() target is now required"
            ),
            (e = new j())),
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Fe, e, Ue),
          e
        );
      },
      getWorldScale: function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Object3D: .getWorldScale() target is now required"
            ),
            (e = new W())),
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(Fe, ke, e),
          e
        );
      },
      getWorldDirection: function (e) {
        void 0 === e &&
          (console.warn(
            "THREE.Object3D: .getWorldDirection() target is now required"
          ),
          (e = new W())),
          this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      },
      raycast: function () {},
      traverse: function (e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
      },
      traverseVisible: function (e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
      },
      traverseAncestors: function (e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      },
      updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      },
      updateMatrixWorld: function (e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
      },
      updateWorldMatrix: function (e, t) {
        const n = this.parent;
        if (
          (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, n = e.length; t < n; t++)
            e[t].updateWorldMatrix(!1, !0);
        }
      },
      toJSON: function (e) {
        const t = void 0 === e || "string" == typeof e,
          n = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const i = {};
        function r(t, n) {
          return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = "InstancedMesh"),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON())),
          this.isMesh || this.isLine || this.isPoints)
        ) {
          i.geometry = r(e.geometries, this.geometry);
          const t = this.geometry.parameters;
          if (void 0 !== t && void 0 !== t.shapes) {
            const n = t.shapes;
            if (Array.isArray(n))
              for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                r(e.shapes, i);
              }
            else r(e.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((i.bindMode = this.bindMode),
            (i.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (r(e.skeletons, this.skeleton),
              (i.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const t = [];
            for (let n = 0, i = this.material.length; n < i; n++)
              t.push(r(e.materials, this.material[n]));
            i.material = t;
          } else i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (let t = 0; t < this.children.length; t++)
            i.children.push(this.children[t].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          i.animations = [];
          for (let t = 0; t < this.animations.length; t++) {
            const n = this.animations[t];
            i.animations.push(r(e.animations, n));
          }
        }
        if (t) {
          const t = o(e.geometries),
            i = o(e.materials),
            r = o(e.textures),
            s = o(e.images),
            a = o(e.shapes),
            c = o(e.skeletons),
            l = o(e.animations);
          t.length > 0 && (n.geometries = t),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            s.length > 0 && (n.images = s),
            a.length > 0 && (n.shapes = a),
            c.length > 0 && (n.skeletons = c),
            l.length > 0 && (n.animations = l);
        }
        return (n.object = i), n;
        function o(e) {
          const t = [];
          for (const n in e) {
            const i = e[n];
            delete i.metadata, t.push(i);
          }
          return t;
        }
      },
      clone: function (e) {
        return new this.constructor().copy(this, e);
      },
      copy: function (e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) {
            const n = e.children[t];
            this.add(n.clone());
          }
        return this;
      },
    }));
  const We = new W(),
    Xe = new W(),
    qe = new D();
  class Ye {
    constructor(e, t) {
      Object.defineProperty(this, "isPlane", { value: !0 }),
        (this.normal = void 0 !== e ? e : new W(1, 0, 0)),
        (this.constant = void 0 !== t ? t : 0);
    }
    set(e, t) {
      return this.normal.copy(e), (this.constant = t), this;
    }
    setComponents(e, t, n, i) {
      return this.normal.set(e, t, n), (this.constant = i), this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    }
    setFromCoplanarPoints(e, t, n) {
      const i = We.subVectors(n, t).cross(Xe.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, e), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.normal.copy(e.normal), (this.constant = e.constant), this;
    }
    normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), (this.constant *= e), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return (
        void 0 === t &&
          (console.warn("THREE.Plane: .projectPoint() target is now required"),
          (t = new W())),
        t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
      );
    }
    intersectLine(e, t) {
      void 0 === t &&
        (console.warn("THREE.Plane: .intersectLine() target is now required"),
        (t = new W()));
      const n = e.delta(We),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
      const r = -(e.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? void 0 : t.copy(n).multiplyScalar(r).add(e.start);
    }
    intersectsLine(e) {
      const t = this.distanceToPoint(e.start),
        n = this.distanceToPoint(e.end);
      return (t < 0 && n > 0) || (n < 0 && t > 0);
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return (
        void 0 === e &&
          (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
          (e = new W())),
        e.copy(this.normal).multiplyScalar(-this.constant)
      );
    }
    applyMatrix4(e, t) {
      const n = t || qe.getNormalMatrix(e),
        i = this.coplanarPoint(We).applyMatrix4(e),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    }
    translate(e) {
      return (this.constant -= e.dot(this.normal)), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
  }
  const Ze = new W(),
    Je = new W(),
    Ke = new W(),
    Qe = new W(),
    $e = new W(),
    et = new W(),
    tt = new W(),
    nt = new W(),
    it = new W(),
    rt = new W();
  class ot {
    constructor(e, t, n) {
      (this.a = void 0 !== e ? e : new W()),
        (this.b = void 0 !== t ? t : new W()),
        (this.c = void 0 !== n ? n : new W());
    }
    static getNormal(e, t, n, i) {
      void 0 === i &&
        (console.warn("THREE.Triangle: .getNormal() target is now required"),
        (i = new W())),
        i.subVectors(n, t),
        Ze.subVectors(e, t),
        i.cross(Ze);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(e, t, n, i, r) {
      Ze.subVectors(i, t), Je.subVectors(n, t), Ke.subVectors(e, t);
      const o = Ze.dot(Ze),
        s = Ze.dot(Je),
        a = Ze.dot(Ke),
        c = Je.dot(Je),
        l = Je.dot(Ke),
        h = o * c - s * s;
      if (
        (void 0 === r &&
          (console.warn(
            "THREE.Triangle: .getBarycoord() target is now required"
          ),
          (r = new W())),
        0 === h)
      )
        return r.set(-2, -1, -1);
      const u = 1 / h,
        d = (c * a - s * l) * u,
        p = (o * l - s * a) * u;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(e, t, n, i) {
      return (
        this.getBarycoord(e, t, n, i, Qe),
        Qe.x >= 0 && Qe.y >= 0 && Qe.x + Qe.y <= 1
      );
    }
    static getUV(e, t, n, i, r, o, s, a) {
      return (
        this.getBarycoord(e, t, n, i, Qe),
        a.set(0, 0),
        a.addScaledVector(r, Qe.x),
        a.addScaledVector(o, Qe.y),
        a.addScaledVector(s, Qe.z),
        a
      );
    }
    static isFrontFacing(e, t, n, i) {
      return Ze.subVectors(n, t), Je.subVectors(e, t), Ze.cross(Je).dot(i) < 0;
    }
    set(e, t, n) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    }
    setFromPointsAndIndices(e, t, n, i) {
      return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return (
        Ze.subVectors(this.c, this.b),
        Je.subVectors(this.a, this.b),
        0.5 * Ze.cross(Je).length()
      );
    }
    getMidpoint(e) {
      return (
        void 0 === e &&
          (console.warn(
            "THREE.Triangle: .getMidpoint() target is now required"
          ),
          (e = new W())),
        e
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3)
      );
    }
    getNormal(e) {
      return ot.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return (
        void 0 === e &&
          (console.warn("THREE.Triangle: .getPlane() target is now required"),
          (e = new Ye())),
        e.setFromCoplanarPoints(this.a, this.b, this.c)
      );
    }
    getBarycoord(e, t) {
      return ot.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, n, i, r) {
      return ot.getUV(e, this.a, this.b, this.c, t, n, i, r);
    }
    containsPoint(e) {
      return ot.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return ot.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      void 0 === t &&
        (console.warn(
          "THREE.Triangle: .closestPointToPoint() target is now required"
        ),
        (t = new W()));
      const n = this.a,
        i = this.b,
        r = this.c;
      let o, s;
      $e.subVectors(i, n), et.subVectors(r, n), nt.subVectors(e, n);
      const a = $e.dot(nt),
        c = et.dot(nt);
      if (a <= 0 && c <= 0) return t.copy(n);
      it.subVectors(e, i);
      const l = $e.dot(it),
        h = et.dot(it);
      if (l >= 0 && h <= l) return t.copy(i);
      const u = a * h - l * c;
      if (u <= 0 && a >= 0 && l <= 0)
        return (o = a / (a - l)), t.copy(n).addScaledVector($e, o);
      rt.subVectors(e, r);
      const d = $e.dot(rt),
        p = et.dot(rt);
      if (p >= 0 && d <= p) return t.copy(r);
      const f = d * c - a * p;
      if (f <= 0 && c >= 0 && p <= 0)
        return (s = c / (c - p)), t.copy(n).addScaledVector(et, s);
      const m = l * p - d * h;
      if (m <= 0 && h - l >= 0 && d - p >= 0)
        return (
          tt.subVectors(r, i),
          (s = (h - l) / (h - l + (d - p))),
          t.copy(i).addScaledVector(tt, s)
        );
      const g = 1 / (m + f + u);
      return (
        (o = f * g),
        (s = u * g),
        t.copy(n).addScaledVector($e, o).addScaledVector(et, s)
      );
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  }
  const st = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    at = { h: 0, s: 0, l: 0 },
    ct = { h: 0, s: 0, l: 0 };
  function lt(e, t, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? e + 6 * (t - e) * n
        : n < 0.5
        ? t
        : n < 2 / 3
        ? e + 6 * (t - e) * (2 / 3 - n)
        : e
    );
  }
  function ht(e) {
    return e < 0.04045
      ? 0.0773993808 * e
      : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
  }
  function ut(e) {
    return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
  }
  class dt {
    constructor(e, t, n) {
      return (
        Object.defineProperty(this, "isColor", { value: !0 }),
        void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
      );
    }
    set(e) {
      return (
        e && e.isColor
          ? this.copy(e)
          : "number" == typeof e
          ? this.setHex(e)
          : "string" == typeof e && this.setStyle(e),
        this
      );
    }
    setScalar(e) {
      return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e) {
      return (
        (e = Math.floor(e)),
        (this.r = ((e >> 16) & 255) / 255),
        (this.g = ((e >> 8) & 255) / 255),
        (this.b = (255 & e) / 255),
        this
      );
    }
    setRGB(e, t, n) {
      return (this.r = e), (this.g = t), (this.b = n), this;
    }
    setHSL(e, t, n) {
      if (
        ((e = I.euclideanModulo(e, 1)),
        (t = I.clamp(t, 0, 1)),
        (n = I.clamp(n, 0, 1)),
        0 === t)
      )
        this.r = this.g = this.b = n;
      else {
        const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
          r = 2 * n - i;
        (this.r = lt(r, i, e + 1 / 3)),
          (this.g = lt(r, i, e)),
          (this.b = lt(r, i, e - 1 / 3));
      }
      return this;
    }
    setStyle(e) {
      function t(t) {
        void 0 !== t &&
          parseFloat(t) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + e + " will be ignored."
          );
      }
      let n;
      if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
        let e;
        const i = n[1],
          r = n[2];
        switch (i) {
          case "rgb":
          case "rgba":
            if (
              (e =
                /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                t(e[4]),
                this
              );
            if (
              (e =
                /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                t(e[4]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (e =
                /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  r
                ))
            ) {
              const n = parseFloat(e[1]) / 360,
                i = parseInt(e[2], 10) / 100,
                r = parseInt(e[3], 10) / 100;
              return t(e[4]), this.setHSL(n, i, r);
            }
        }
      } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
        const e = n[1],
          t = e.length;
        if (3 === t)
          return (
            (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
            (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
            (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
            this
          );
        if (6 === t)
          return (
            (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
            (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
            (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
            this
          );
      }
      return e && e.length > 0 ? this.setColorName(e) : this;
    }
    setColorName(e) {
      const t = st[e];
      return (
        void 0 !== t
          ? this.setHex(t)
          : console.warn("THREE.Color: Unknown color " + e),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copyGammaToLinear(e, t = 2) {
      return (
        (this.r = Math.pow(e.r, t)),
        (this.g = Math.pow(e.g, t)),
        (this.b = Math.pow(e.b, t)),
        this
      );
    }
    copyLinearToGamma(e, t = 2) {
      const n = t > 0 ? 1 / t : 1;
      return (
        (this.r = Math.pow(e.r, n)),
        (this.g = Math.pow(e.g, n)),
        (this.b = Math.pow(e.b, n)),
        this
      );
    }
    convertGammaToLinear(e) {
      return this.copyGammaToLinear(this, e), this;
    }
    convertLinearToGamma(e) {
      return this.copyLinearToGamma(this, e), this;
    }
    copySRGBToLinear(e) {
      return (this.r = ht(e.r)), (this.g = ht(e.g)), (this.b = ht(e.b)), this;
    }
    copyLinearToSRGB(e) {
      return (this.r = ut(e.r)), (this.g = ut(e.g)), (this.b = ut(e.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex() {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(e) {
      void 0 === e &&
        (console.warn("THREE.Color: .getHSL() target is now required"),
        (e = { h: 0, s: 0, l: 0 }));
      const t = this.r,
        n = this.g,
        i = this.b,
        r = Math.max(t, n, i),
        o = Math.min(t, n, i);
      let s, a;
      const c = (o + r) / 2;
      if (o === r) (s = 0), (a = 0);
      else {
        const e = r - o;
        switch (((a = c <= 0.5 ? e / (r + o) : e / (2 - r - o)), r)) {
          case t:
            s = (n - i) / e + (n < i ? 6 : 0);
            break;
          case n:
            s = (i - t) / e + 2;
            break;
          case i:
            s = (t - n) / e + 4;
        }
        s /= 6;
      }
      return (e.h = s), (e.s = a), (e.l = c), e;
    }
    getStyle() {
      return (
        "rgb(" +
        ((255 * this.r) | 0) +
        "," +
        ((255 * this.g) | 0) +
        "," +
        ((255 * this.b) | 0) +
        ")"
      );
    }
    offsetHSL(e, t, n) {
      return (
        this.getHSL(at),
        (at.h += e),
        (at.s += t),
        (at.l += n),
        this.setHSL(at.h, at.s, at.l),
        this
      );
    }
    add(e) {
      return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
      return (
        (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
      );
    }
    addScalar(e) {
      return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
      return (
        (this.r = Math.max(0, this.r - e.r)),
        (this.g = Math.max(0, this.g - e.g)),
        (this.b = Math.max(0, this.b - e.b)),
        this
      );
    }
    multiply(e) {
      return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
      return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
      return (
        (this.r += (e.r - this.r) * t),
        (this.g += (e.g - this.g) * t),
        (this.b += (e.b - this.b) * t),
        this
      );
    }
    lerpHSL(e, t) {
      this.getHSL(at), e.getHSL(ct);
      const n = I.lerp(at.h, ct.h, t),
        i = I.lerp(at.s, ct.s, t),
        r = I.lerp(at.l, ct.l, t);
      return this.setHSL(n, i, r), this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
      return (
        (this.r = e.getX(t)),
        (this.g = e.getY(t)),
        (this.b = e.getZ(t)),
        !0 === e.normalized &&
          ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
        this
      );
    }
    toJSON() {
      return this.getHex();
    }
  }
  (dt.NAMES = st),
    (dt.prototype.r = 1),
    (dt.prototype.g = 1),
    (dt.prototype.b = 1);
  class pt {
    constructor(e, t, n, i, r, o = 0) {
      (this.a = e),
        (this.b = t),
        (this.c = n),
        (this.normal = i && i.isVector3 ? i : new W()),
        (this.vertexNormals = Array.isArray(i) ? i : []),
        (this.color = r && r.isColor ? r : new dt()),
        (this.vertexColors = Array.isArray(r) ? r : []),
        (this.materialIndex = o);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.a = e.a),
        (this.b = e.b),
        (this.c = e.c),
        this.normal.copy(e.normal),
        this.color.copy(e.color),
        (this.materialIndex = e.materialIndex);
      for (let t = 0, n = e.vertexNormals.length; t < n; t++)
        this.vertexNormals[t] = e.vertexNormals[t].clone();
      for (let t = 0, n = e.vertexColors.length; t < n; t++)
        this.vertexColors[t] = e.vertexColors[t].clone();
      return this;
    }
  }
  let ft = 0;
  function mt() {
    Object.defineProperty(this, "id", { value: ft++ }),
      (this.uuid = I.generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = 1),
      (this.side = 0),
      (this.flatShading = !1),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = e),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = T),
      (this.stencilZFail = T),
      (this.stencilZPass = T),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaTest = 0),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0);
  }
  function gt(e) {
    mt.call(this),
      (this.type = "MeshBasicMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      this.setValues(e);
  }
  (mt.prototype = Object.assign(Object.create(C.prototype), {
    constructor: mt,
    isMaterial: !0,
    onBeforeCompile: function () {},
    customProgramCacheKey: function () {
      return this.onBeforeCompile.toString();
    },
    setValues: function (e) {
      if (void 0 !== e)
        for (const t in e) {
          const n = e[t];
          if (void 0 === n) {
            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            continue;
          }
          if ("shading" === t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === n);
            continue;
          }
          const i = this[t];
          void 0 !== i
            ? i && i.isColor
              ? i.set(n)
              : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[t] = n)
            : console.warn(
                "THREE." +
                  this.type +
                  ": '" +
                  t +
                  "' is not a property of this material."
              );
        }
    },
    toJSON: function (e) {
      const t = void 0 === e || "string" == typeof e;
      t && (e = { textures: {}, images: {} });
      const n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function i(e) {
        const t = [];
        for (const n in e) {
          const i = e[n];
          delete i.metadata, t.push(i);
        }
        return t;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          (n.lightMap = this.lightMap.toJSON(e).uuid),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(e).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(e).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(e).uuid),
          (n.reflectivity = this.reflectivity),
          (n.refractionRatio = this.refractionRatio),
          void 0 !== this.combine && (n.combine = this.combine),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity)),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        void 0 !== this.size && (n.size = this.size),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        0 !== this.side && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        (n.depthFunc = this.depthFunc),
        (n.depthTest = this.depthTest),
        (n.depthWrite = this.depthWrite),
        (n.stencilWrite = this.stencilWrite),
        (n.stencilWriteMask = this.stencilWriteMask),
        (n.stencilFunc = this.stencilFunc),
        (n.stencilRef = this.stencilRef),
        (n.stencilFuncMask = this.stencilFuncMask),
        (n.stencilFail = this.stencilFail),
        (n.stencilZFail = this.stencilZFail),
        (n.stencilZPass = this.stencilZPass),
        this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha &&
          (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.morphTargets && (n.morphTargets = !0),
        !0 === this.morphNormals && (n.morphNormals = !0),
        !0 === this.skinning && (n.skinning = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        t)
      ) {
        const t = i(e.textures),
          r = i(e.images);
        t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
      }
      return n;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (e) {
      (this.name = e.name),
        (this.fog = e.fog),
        (this.blending = e.blending),
        (this.side = e.side),
        (this.flatShading = e.flatShading),
        (this.vertexColors = e.vertexColors),
        (this.opacity = e.opacity),
        (this.transparent = e.transparent),
        (this.blendSrc = e.blendSrc),
        (this.blendDst = e.blendDst),
        (this.blendEquation = e.blendEquation),
        (this.blendSrcAlpha = e.blendSrcAlpha),
        (this.blendDstAlpha = e.blendDstAlpha),
        (this.blendEquationAlpha = e.blendEquationAlpha),
        (this.depthFunc = e.depthFunc),
        (this.depthTest = e.depthTest),
        (this.depthWrite = e.depthWrite),
        (this.stencilWriteMask = e.stencilWriteMask),
        (this.stencilFunc = e.stencilFunc),
        (this.stencilRef = e.stencilRef),
        (this.stencilFuncMask = e.stencilFuncMask),
        (this.stencilFail = e.stencilFail),
        (this.stencilZFail = e.stencilZFail),
        (this.stencilZPass = e.stencilZPass),
        (this.stencilWrite = e.stencilWrite);
      const t = e.clippingPlanes;
      let n = null;
      if (null !== t) {
        const e = t.length;
        n = new Array(e);
        for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = e.clipIntersection),
        (this.clipShadows = e.clipShadows),
        (this.shadowSide = e.shadowSide),
        (this.colorWrite = e.colorWrite),
        (this.precision = e.precision),
        (this.polygonOffset = e.polygonOffset),
        (this.polygonOffsetFactor = e.polygonOffsetFactor),
        (this.polygonOffsetUnits = e.polygonOffsetUnits),
        (this.dithering = e.dithering),
        (this.alphaTest = e.alphaTest),
        (this.premultipliedAlpha = e.premultipliedAlpha),
        (this.visible = e.visible),
        (this.toneMapped = e.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    Object.defineProperty(mt.prototype, "needsUpdate", {
      set: function (e) {
        !0 === e && this.version++;
      },
    }),
    (gt.prototype = Object.create(mt.prototype)),
    (gt.prototype.constructor = gt),
    (gt.prototype.isMeshBasicMaterial = !0),
    (gt.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        (this.specularMap = e.specularMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.combine = e.combine),
        (this.reflectivity = e.reflectivity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        this
      );
    });
  const vt = new W(),
    yt = new N();
  function xt(e, t, n) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.normalized = !0 === n),
      (this.usage = A),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  function _t(e, t, n) {
    xt.call(this, new Int8Array(e), t, n);
  }
  function bt(e, t, n) {
    xt.call(this, new Uint8Array(e), t, n);
  }
  function wt(e, t, n) {
    xt.call(this, new Uint8ClampedArray(e), t, n);
  }
  function Mt(e, t, n) {
    xt.call(this, new Int16Array(e), t, n);
  }
  function St(e, t, n) {
    xt.call(this, new Uint16Array(e), t, n);
  }
  function Et(e, t, n) {
    xt.call(this, new Int32Array(e), t, n);
  }
  function Tt(e, t, n) {
    xt.call(this, new Uint32Array(e), t, n);
  }
  function At(e, t, n) {
    xt.call(this, new Uint16Array(e), t, n);
  }
  function Lt(e, t, n) {
    xt.call(this, new Float32Array(e), t, n);
  }
  function Rt(e, t, n) {
    xt.call(this, new Float64Array(e), t, n);
  }
  Object.defineProperty(xt.prototype, "needsUpdate", {
    set: function (e) {
      !0 === e && this.version++;
    },
  }),
    Object.assign(xt.prototype, {
      isBufferAttribute: !0,
      onUploadCallback: function () {},
      setUsage: function (e) {
        return (this.usage = e), this;
      },
      copy: function (e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      },
      copyAt: function (e, t, n) {
        (e *= this.itemSize), (n *= t.itemSize);
        for (let i = 0, r = this.itemSize; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      },
      copyArray: function (e) {
        return this.array.set(e), this;
      },
      copyColorsArray: function (e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              i
            ),
            (r = new dt())),
            (t[n++] = r.r),
            (t[n++] = r.g),
            (t[n++] = r.b);
        }
        return this;
      },
      copyVector2sArray: function (e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              i
            ),
            (r = new N())),
            (t[n++] = r.x),
            (t[n++] = r.y);
        }
        return this;
      },
      copyVector3sArray: function (e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              i
            ),
            (r = new W())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z);
        }
        return this;
      },
      copyVector4sArray: function (e) {
        const t = this.array;
        let n = 0;
        for (let i = 0, r = e.length; i < r; i++) {
          let r = e[i];
          void 0 === r &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              i
            ),
            (r = new H())),
            (t[n++] = r.x),
            (t[n++] = r.y),
            (t[n++] = r.z),
            (t[n++] = r.w);
        }
        return this;
      },
      applyMatrix3: function (e) {
        if (2 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            yt.fromBufferAttribute(this, t),
              yt.applyMatrix3(e),
              this.setXY(t, yt.x, yt.y);
        else if (3 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            vt.fromBufferAttribute(this, t),
              vt.applyMatrix3(e),
              this.setXYZ(t, vt.x, vt.y, vt.z);
        return this;
      },
      applyMatrix4: function (e) {
        for (let t = 0, n = this.count; t < n; t++)
          (vt.x = this.getX(t)),
            (vt.y = this.getY(t)),
            (vt.z = this.getZ(t)),
            vt.applyMatrix4(e),
            this.setXYZ(t, vt.x, vt.y, vt.z);
        return this;
      },
      applyNormalMatrix: function (e) {
        for (let t = 0, n = this.count; t < n; t++)
          (vt.x = this.getX(t)),
            (vt.y = this.getY(t)),
            (vt.z = this.getZ(t)),
            vt.applyNormalMatrix(e),
            this.setXYZ(t, vt.x, vt.y, vt.z);
        return this;
      },
      transformDirection: function (e) {
        for (let t = 0, n = this.count; t < n; t++)
          (vt.x = this.getX(t)),
            (vt.y = this.getY(t)),
            (vt.z = this.getZ(t)),
            vt.transformDirection(e),
            this.setXYZ(t, vt.x, vt.y, vt.z);
        return this;
      },
      set: function (e, t = 0) {
        return this.array.set(e, t), this;
      },
      getX: function (e) {
        return this.array[e * this.itemSize];
      },
      setX: function (e, t) {
        return (this.array[e * this.itemSize] = t), this;
      },
      getY: function (e) {
        return this.array[e * this.itemSize + 1];
      },
      setY: function (e, t) {
        return (this.array[e * this.itemSize + 1] = t), this;
      },
      getZ: function (e) {
        return this.array[e * this.itemSize + 2];
      },
      setZ: function (e, t) {
        return (this.array[e * this.itemSize + 2] = t), this;
      },
      getW: function (e) {
        return this.array[e * this.itemSize + 3];
      },
      setW: function (e, t) {
        return (this.array[e * this.itemSize + 3] = t), this;
      },
      setXY: function (e, t, n) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          this
        );
      },
      setXYZ: function (e, t, n, i) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          this
        );
      },
      setXYZW: function (e, t, n, i, r) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = i),
          (this.array[e + 3] = r),
          this
        );
      },
      onUpload: function (e) {
        return (this.onUploadCallback = e), this;
      },
      clone: function () {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
      toJSON: function () {
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
      },
    }),
    (_t.prototype = Object.create(xt.prototype)),
    (_t.prototype.constructor = _t),
    (bt.prototype = Object.create(xt.prototype)),
    (bt.prototype.constructor = bt),
    (wt.prototype = Object.create(xt.prototype)),
    (wt.prototype.constructor = wt),
    (Mt.prototype = Object.create(xt.prototype)),
    (Mt.prototype.constructor = Mt),
    (St.prototype = Object.create(xt.prototype)),
    (St.prototype.constructor = St),
    (Et.prototype = Object.create(xt.prototype)),
    (Et.prototype.constructor = Et),
    (Tt.prototype = Object.create(xt.prototype)),
    (Tt.prototype.constructor = Tt),
    (At.prototype = Object.create(xt.prototype)),
    (At.prototype.constructor = At),
    (At.prototype.isFloat16BufferAttribute = !0),
    (Lt.prototype = Object.create(xt.prototype)),
    (Lt.prototype.constructor = Lt),
    (Rt.prototype = Object.create(xt.prototype)),
    (Rt.prototype.constructor = Rt);
  class Ct {
    constructor() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    computeGroups(e) {
      const t = [];
      let n, i, r;
      const o = e.faces;
      for (i = 0; i < o.length; i++) {
        const e = o[i];
        e.materialIndex !== r &&
          ((r = e.materialIndex),
          void 0 !== n && ((n.count = 3 * i - n.start), t.push(n)),
          (n = { start: 3 * i, materialIndex: r }));
      }
      void 0 !== n && ((n.count = 3 * i - n.start), t.push(n)),
        (this.groups = t);
    }
    fromGeometry(e) {
      const t = e.faces,
        n = e.vertices,
        i = e.faceVertexUvs,
        r = i[0] && i[0].length > 0,
        o = i[1] && i[1].length > 0,
        s = e.morphTargets,
        a = s.length;
      let c;
      if (a > 0) {
        c = [];
        for (let e = 0; e < a; e++) c[e] = { name: s[e].name, data: [] };
        this.morphTargets.position = c;
      }
      const l = e.morphNormals,
        h = l.length;
      let u;
      if (h > 0) {
        u = [];
        for (let e = 0; e < h; e++) u[e] = { name: l[e].name, data: [] };
        this.morphTargets.normal = u;
      }
      const d = e.skinIndices,
        p = e.skinWeights,
        f = d.length === n.length,
        m = p.length === n.length;
      n.length > 0 &&
        0 === t.length &&
        console.error(
          "THREE.DirectGeometry: Faceless geometries are not supported."
        );
      for (let e = 0; e < t.length; e++) {
        const g = t[e];
        this.vertices.push(n[g.a], n[g.b], n[g.c]);
        const v = g.vertexNormals;
        if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
        else {
          const e = g.normal;
          this.normals.push(e, e, e);
        }
        const y = g.vertexColors;
        if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
        else {
          const e = g.color;
          this.colors.push(e, e, e);
        }
        if (!0 === r) {
          const t = i[0][e];
          void 0 !== t
            ? this.uvs.push(t[0], t[1], t[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                e
              ),
              this.uvs.push(new N(), new N(), new N()));
        }
        if (!0 === o) {
          const t = i[1][e];
          void 0 !== t
            ? this.uvs2.push(t[0], t[1], t[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                e
              ),
              this.uvs2.push(new N(), new N(), new N()));
        }
        for (let e = 0; e < a; e++) {
          const t = s[e].vertices;
          c[e].data.push(t[g.a], t[g.b], t[g.c]);
        }
        for (let t = 0; t < h; t++) {
          const n = l[t].vertexNormals[e];
          u[t].data.push(n.a, n.b, n.c);
        }
        f && this.skinIndices.push(d[g.a], d[g.b], d[g.c]),
          m && this.skinWeights.push(p[g.a], p[g.b], p[g.c]);
      }
      return (
        this.computeGroups(e),
        (this.verticesNeedUpdate = e.verticesNeedUpdate),
        (this.normalsNeedUpdate = e.normalsNeedUpdate),
        (this.colorsNeedUpdate = e.colorsNeedUpdate),
        (this.uvsNeedUpdate = e.uvsNeedUpdate),
        (this.groupsNeedUpdate = e.groupsNeedUpdate),
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        this
      );
    }
  }
  function Pt(e) {
    if (0 === e.length) return -1 / 0;
    let t = e[0];
    for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
    return t;
  }
  const Ot = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray:
      "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
  };
  function It(e, t) {
    return new Ot[e](t);
  }
  let Nt = 1;
  const Dt = new xe(),
    Ft = new je(),
    Ut = new W(),
    kt = new Y(),
    Bt = new Y(),
    zt = new W();
  function Ht() {
    Object.defineProperty(this, "id", { value: (Nt += 2) }),
      (this.uuid = I.generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  Ht.prototype = Object.assign(Object.create(C.prototype), {
    constructor: Ht,
    isBufferGeometry: !0,
    getIndex: function () {
      return this.index;
    },
    setIndex: function (e) {
      return (
        Array.isArray(e)
          ? (this.index = new (Pt(e) > 65535 ? Tt : St)(e, 1))
          : (this.index = e),
        this
      );
    },
    getAttribute: function (e) {
      return this.attributes[e];
    },
    setAttribute: function (e, t) {
      return (this.attributes[e] = t), this;
    },
    deleteAttribute: function (e) {
      return delete this.attributes[e], this;
    },
    hasAttribute: function (e) {
      return void 0 !== this.attributes[e];
    },
    addGroup: function (e, t, n = 0) {
      this.groups.push({ start: e, count: t, materialIndex: n });
    },
    clearGroups: function () {
      this.groups = [];
    },
    setDrawRange: function (e, t) {
      (this.drawRange.start = e), (this.drawRange.count = t);
    },
    applyMatrix4: function (e) {
      const t = this.attributes.position;
      void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const t = new D().getNormalMatrix(e);
        n.applyNormalMatrix(t), (n.needsUpdate = !0);
      }
      const i = this.attributes.tangent;
      return (
        void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    },
    rotateX: function (e) {
      return Dt.makeRotationX(e), this.applyMatrix4(Dt), this;
    },
    rotateY: function (e) {
      return Dt.makeRotationY(e), this.applyMatrix4(Dt), this;
    },
    rotateZ: function (e) {
      return Dt.makeRotationZ(e), this.applyMatrix4(Dt), this;
    },
    translate: function (e, t, n) {
      return Dt.makeTranslation(e, t, n), this.applyMatrix4(Dt), this;
    },
    scale: function (e, t, n) {
      return Dt.makeScale(e, t, n), this.applyMatrix4(Dt), this;
    },
    lookAt: function (e) {
      return (
        Ft.lookAt(e), Ft.updateMatrix(), this.applyMatrix4(Ft.matrix), this
      );
    },
    center: function () {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Ut).negate(),
        this.translate(Ut.x, Ut.y, Ut.z),
        this
      );
    },
    setFromObject: function (e) {
      const t = e.geometry;
      if (e.isPoints || e.isLine) {
        const e = new Lt(3 * t.vertices.length, 3),
          n = new Lt(3 * t.colors.length, 3);
        if (
          (this.setAttribute("position", e.copyVector3sArray(t.vertices)),
          this.setAttribute("color", n.copyColorsArray(t.colors)),
          t.lineDistances && t.lineDistances.length === t.vertices.length)
        ) {
          const e = new Lt(t.lineDistances.length, 1);
          this.setAttribute("lineDistance", e.copyArray(t.lineDistances));
        }
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone());
      } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
      return this;
    },
    setFromPoints: function (e) {
      const t = [];
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        t.push(i.x, i.y, i.z || 0);
      }
      return this.setAttribute("position", new Lt(t, 3)), this;
    },
    updateFromObject: function (e) {
      let t = e.geometry;
      if (e.isMesh) {
        let e = t.__directGeometry;
        if (
          (!0 === t.elementsNeedUpdate &&
            ((e = void 0), (t.elementsNeedUpdate = !1)),
          void 0 === e)
        )
          return this.fromGeometry(t);
        (e.verticesNeedUpdate = t.verticesNeedUpdate),
          (e.normalsNeedUpdate = t.normalsNeedUpdate),
          (e.colorsNeedUpdate = t.colorsNeedUpdate),
          (e.uvsNeedUpdate = t.uvsNeedUpdate),
          (e.groupsNeedUpdate = t.groupsNeedUpdate),
          (t.verticesNeedUpdate = !1),
          (t.normalsNeedUpdate = !1),
          (t.colorsNeedUpdate = !1),
          (t.uvsNeedUpdate = !1),
          (t.groupsNeedUpdate = !1),
          (t = e);
      }
      if (!0 === t.verticesNeedUpdate) {
        const e = this.attributes.position;
        void 0 !== e && (e.copyVector3sArray(t.vertices), (e.needsUpdate = !0)),
          (t.verticesNeedUpdate = !1);
      }
      if (!0 === t.normalsNeedUpdate) {
        const e = this.attributes.normal;
        void 0 !== e && (e.copyVector3sArray(t.normals), (e.needsUpdate = !0)),
          (t.normalsNeedUpdate = !1);
      }
      if (!0 === t.colorsNeedUpdate) {
        const e = this.attributes.color;
        void 0 !== e && (e.copyColorsArray(t.colors), (e.needsUpdate = !0)),
          (t.colorsNeedUpdate = !1);
      }
      if (t.uvsNeedUpdate) {
        const e = this.attributes.uv;
        void 0 !== e && (e.copyVector2sArray(t.uvs), (e.needsUpdate = !0)),
          (t.uvsNeedUpdate = !1);
      }
      if (t.lineDistancesNeedUpdate) {
        const e = this.attributes.lineDistance;
        void 0 !== e && (e.copyArray(t.lineDistances), (e.needsUpdate = !0)),
          (t.lineDistancesNeedUpdate = !1);
      }
      return (
        t.groupsNeedUpdate &&
          (t.computeGroups(e.geometry),
          (this.groups = t.groups),
          (t.groupsNeedUpdate = !1)),
        this
      );
    },
    fromGeometry: function (e) {
      return (
        (e.__directGeometry = new Ct().fromGeometry(e)),
        this.fromDirectGeometry(e.__directGeometry)
      );
    },
    fromDirectGeometry: function (e) {
      const t = new Float32Array(3 * e.vertices.length);
      if (
        (this.setAttribute(
          "position",
          new xt(t, 3).copyVector3sArray(e.vertices)
        ),
        e.normals.length > 0)
      ) {
        const t = new Float32Array(3 * e.normals.length);
        this.setAttribute("normal", new xt(t, 3).copyVector3sArray(e.normals));
      }
      if (e.colors.length > 0) {
        const t = new Float32Array(3 * e.colors.length);
        this.setAttribute("color", new xt(t, 3).copyColorsArray(e.colors));
      }
      if (e.uvs.length > 0) {
        const t = new Float32Array(2 * e.uvs.length);
        this.setAttribute("uv", new xt(t, 2).copyVector2sArray(e.uvs));
      }
      if (e.uvs2.length > 0) {
        const t = new Float32Array(2 * e.uvs2.length);
        this.setAttribute("uv2", new xt(t, 2).copyVector2sArray(e.uvs2));
      }
      this.groups = e.groups;
      for (const t in e.morphTargets) {
        const n = [],
          i = e.morphTargets[t];
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e],
            r = new Lt(3 * t.data.length, 3);
          (r.name = t.name), n.push(r.copyVector3sArray(t.data));
        }
        this.morphAttributes[t] = n;
      }
      if (e.skinIndices.length > 0) {
        const t = new Lt(4 * e.skinIndices.length, 4);
        this.setAttribute("skinIndex", t.copyVector4sArray(e.skinIndices));
      }
      if (e.skinWeights.length > 0) {
        const t = new Lt(4 * e.skinWeights.length, 4);
        this.setAttribute("skinWeight", t.copyVector4sArray(e.skinWeights));
      }
      return (
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        this
      );
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Y());
      const e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingBox.set(
            new W(-1 / 0, -1 / 0, -1 / 0),
            new W(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== e) {
        if ((this.boundingBox.setFromBufferAttribute(e), t))
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            kt.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (zt.addVectors(this.boundingBox.min, kt.min),
                  this.boundingBox.expandByPoint(zt),
                  zt.addVectors(this.boundingBox.max, kt.max),
                  this.boundingBox.expandByPoint(zt))
                : (this.boundingBox.expandByPoint(kt.min),
                  this.boundingBox.expandByPoint(kt.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new he());
      const e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingSphere.set(new W(), 1 / 0)
        );
      if (e) {
        const n = this.boundingSphere.center;
        if ((kt.setFromBufferAttribute(e), t))
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            Bt.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (zt.addVectors(kt.min, Bt.min),
                  kt.expandByPoint(zt),
                  zt.addVectors(kt.max, Bt.max),
                  kt.expandByPoint(zt))
                : (kt.expandByPoint(Bt.min), kt.expandByPoint(Bt.max));
          }
        kt.getCenter(n);
        let i = 0;
        for (let t = 0, r = e.count; t < r; t++)
          zt.fromBufferAttribute(e, t),
            (i = Math.max(i, n.distanceToSquared(zt)));
        if (t)
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r],
              s = this.morphTargetsRelative;
            for (let t = 0, r = o.count; t < r; t++)
              zt.fromBufferAttribute(o, t),
                s && (Ut.fromBufferAttribute(e, t), zt.add(Ut)),
                (i = Math.max(i, n.distanceToSquared(zt)));
          }
        (this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    },
    computeFaceNormals: function () {},
    computeVertexNormals: function () {
      const e = this.index,
        t = this.getAttribute("position");
      if (void 0 !== t) {
        let n = this.getAttribute("normal");
        if (void 0 === n)
          (n = new xt(new Float32Array(3 * t.count), 3)),
            this.setAttribute("normal", n);
        else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
        const i = new W(),
          r = new W(),
          o = new W(),
          s = new W(),
          a = new W(),
          c = new W(),
          l = new W(),
          h = new W();
        if (e)
          for (let u = 0, d = e.count; u < d; u += 3) {
            const d = e.getX(u + 0),
              p = e.getX(u + 1),
              f = e.getX(u + 2);
            i.fromBufferAttribute(t, d),
              r.fromBufferAttribute(t, p),
              o.fromBufferAttribute(t, f),
              l.subVectors(o, r),
              h.subVectors(i, r),
              l.cross(h),
              s.fromBufferAttribute(n, d),
              a.fromBufferAttribute(n, p),
              c.fromBufferAttribute(n, f),
              s.add(l),
              a.add(l),
              c.add(l),
              n.setXYZ(d, s.x, s.y, s.z),
              n.setXYZ(p, a.x, a.y, a.z),
              n.setXYZ(f, c.x, c.y, c.z);
          }
        else
          for (let e = 0, s = t.count; e < s; e += 3)
            i.fromBufferAttribute(t, e + 0),
              r.fromBufferAttribute(t, e + 1),
              o.fromBufferAttribute(t, e + 2),
              l.subVectors(o, r),
              h.subVectors(i, r),
              l.cross(h),
              n.setXYZ(e + 0, l.x, l.y, l.z),
              n.setXYZ(e + 1, l.x, l.y, l.z),
              n.setXYZ(e + 2, l.x, l.y, l.z);
        this.normalizeNormals(), (n.needsUpdate = !0);
      }
    },
    merge: function (e, t) {
      if (!e || !e.isBufferGeometry)
        return void console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          e
        );
      void 0 === t &&
        ((t = 0),
        console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        ));
      const n = this.attributes;
      for (const i in n) {
        if (void 0 === e.attributes[i]) continue;
        const r = n[i].array,
          o = e.attributes[i],
          s = o.array,
          a = o.itemSize * t,
          c = Math.min(s.length, r.length - a);
        for (let e = 0, t = a; e < c; e++, t++) r[t] = s[e];
      }
      return this;
    },
    normalizeNormals: function () {
      const e = this.attributes.normal;
      for (let t = 0, n = e.count; t < n; t++)
        zt.fromBufferAttribute(e, t),
          zt.normalize(),
          e.setXYZ(t, zt.x, zt.y, zt.z);
    },
    toNonIndexed: function () {
      function e(e, t) {
        const n = e.array,
          i = e.itemSize,
          r = e.normalized,
          o = new n.constructor(t.length * i);
        let s = 0,
          a = 0;
        for (let e = 0, r = t.length; e < r; e++) {
          s = t[e] * i;
          for (let e = 0; e < i; e++) o[a++] = n[s++];
        }
        return new xt(o, i, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
          ),
          this
        );
      const t = new Ht(),
        n = this.index.array,
        i = this.attributes;
      for (const r in i) {
        const o = e(i[r], n);
        t.setAttribute(r, o);
      }
      const r = this.morphAttributes;
      for (const i in r) {
        const o = [],
          s = r[i];
        for (let t = 0, i = s.length; t < i; t++) {
          const i = e(s[t], n);
          o.push(i);
        }
        t.morphAttributes[i] = o;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let e = 0, n = o.length; e < n; e++) {
        const n = o[e];
        t.addGroup(n.start, n.count, n.materialIndex);
      }
      return t;
    },
    toJSON: function () {
      const e = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((e.uuid = this.uuid),
        (e.type = this.type),
        "" !== this.name && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const t = this.parameters;
        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
        return e;
      }
      e.data = { attributes: {} };
      const t = this.index;
      null !== t &&
        (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array),
        });
      const n = this.attributes;
      for (const t in n) {
        const i = n[t],
          r = i.toJSON(e.data);
        "" !== i.name && (r.name = i.name), (e.data.attributes[t] = r);
      }
      const i = {};
      let r = !1;
      for (const t in this.morphAttributes) {
        const n = this.morphAttributes[t],
          o = [];
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t],
            r = i.toJSON(e.data);
          "" !== i.name && (r.name = i.name), o.push(r);
        }
        o.length > 0 && ((i[t] = o), (r = !0));
      }
      r &&
        ((e.data.morphAttributes = i),
        (e.data.morphTargetsRelative = this.morphTargetsRelative));
      const o = this.groups;
      o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
      const s = this.boundingSphere;
      return (
        null !== s &&
          (e.data.boundingSphere = {
            center: s.center.toArray(),
            radius: s.radius,
          }),
        e
      );
    },
    clone: function () {
      return new Ht().copy(this);
    },
    copy: function (e) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const t = {};
      this.name = e.name;
      const n = e.index;
      null !== n && this.setIndex(n.clone(t));
      const i = e.attributes;
      for (const e in i) {
        const n = i[e];
        this.setAttribute(e, n.clone(t));
      }
      const r = e.morphAttributes;
      for (const e in r) {
        const n = [],
          i = r[e];
        for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
        this.morphAttributes[e] = n;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const o = e.groups;
      for (let e = 0, t = o.length; e < t; e++) {
        const t = o[e];
        this.addGroup(t.start, t.count, t.materialIndex);
      }
      const s = e.boundingBox;
      null !== s && (this.boundingBox = s.clone());
      const a = e.boundingSphere;
      return (
        null !== a && (this.boundingSphere = a.clone()),
        (this.drawRange.start = e.drawRange.start),
        (this.drawRange.count = e.drawRange.count),
        (this.userData = e.userData),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  });
  const Gt = new xe(),
    Vt = new ye(),
    jt = new he(),
    Wt = new W(),
    Xt = new W(),
    qt = new W(),
    Yt = new W(),
    Zt = new W(),
    Jt = new W(),
    Kt = new W(),
    Qt = new W(),
    $t = new W(),
    en = new N(),
    tn = new N(),
    nn = new N(),
    rn = new W(),
    on = new W();
  function sn(e = new Ht(), t = new gt()) {
    je.call(this),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  function an(e, t, n, i, r, o, s, a) {
    let c;
    if (
      ((c =
        1 === t.side
          ? i.intersectTriangle(s, o, r, !0, a)
          : i.intersectTriangle(r, o, s, 2 !== t.side, a)),
      null === c)
    )
      return null;
    on.copy(a), on.applyMatrix4(e.matrixWorld);
    const l = n.ray.origin.distanceTo(on);
    return l < n.near || l > n.far
      ? null
      : { distance: l, point: on.clone(), object: e };
  }
  function cn(e, t, n, i, r, o, s, a, c, l, h, u) {
    Wt.fromBufferAttribute(r, l),
      Xt.fromBufferAttribute(r, h),
      qt.fromBufferAttribute(r, u);
    const d = e.morphTargetInfluences;
    if (t.morphTargets && o && d) {
      Kt.set(0, 0, 0), Qt.set(0, 0, 0), $t.set(0, 0, 0);
      for (let e = 0, t = o.length; e < t; e++) {
        const t = d[e],
          n = o[e];
        0 !== t &&
          (Yt.fromBufferAttribute(n, l),
          Zt.fromBufferAttribute(n, h),
          Jt.fromBufferAttribute(n, u),
          s
            ? (Kt.addScaledVector(Yt, t),
              Qt.addScaledVector(Zt, t),
              $t.addScaledVector(Jt, t))
            : (Kt.addScaledVector(Yt.sub(Wt), t),
              Qt.addScaledVector(Zt.sub(Xt), t),
              $t.addScaledVector(Jt.sub(qt), t)));
      }
      Wt.add(Kt), Xt.add(Qt), qt.add($t);
    }
    e.isSkinnedMesh &&
      (e.boneTransform(l, Wt), e.boneTransform(h, Xt), e.boneTransform(u, qt));
    const p = an(e, t, n, i, Wt, Xt, qt, rn);
    if (p) {
      a &&
        (en.fromBufferAttribute(a, l),
        tn.fromBufferAttribute(a, h),
        nn.fromBufferAttribute(a, u),
        (p.uv = ot.getUV(rn, Wt, Xt, qt, en, tn, nn, new N()))),
        c &&
          (en.fromBufferAttribute(c, l),
          tn.fromBufferAttribute(c, h),
          nn.fromBufferAttribute(c, u),
          (p.uv2 = ot.getUV(rn, Wt, Xt, qt, en, tn, nn, new N())));
      const e = new pt(l, h, u);
      ot.getNormal(Wt, Xt, qt, e.normal), (p.face = e);
    }
    return p;
  }
  sn.prototype = Object.assign(Object.create(je.prototype), {
    constructor: sn,
    isMesh: !0,
    copy: function (e) {
      return (
        je.prototype.copy.call(this, e),
        void 0 !== e.morphTargetInfluences &&
          (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        void 0 !== e.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            e.morphTargetDictionary
          )),
        (this.material = e.material),
        (this.geometry = e.geometry),
        this
      );
    },
    updateMorphTargets: function () {
      const e = this.geometry;
      if (e.isBufferGeometry) {
        const t = e.morphAttributes,
          n = Object.keys(t);
        if (n.length > 0) {
          const e = t[n[0]];
          if (void 0 !== e) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t].name || String(t);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[n] = t);
            }
          }
        }
      } else {
        const t = e.morphTargets;
        void 0 !== t &&
          t.length > 0 &&
          console.error(
            "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    },
    raycast: function (e, t) {
      const n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 === i) return;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        jt.copy(n.boundingSphere),
        jt.applyMatrix4(r),
        !1 === e.ray.intersectsSphere(jt))
      )
        return;
      if (
        (Gt.copy(r).invert(),
        Vt.copy(e.ray).applyMatrix4(Gt),
        null !== n.boundingBox && !1 === Vt.intersectsBox(n.boundingBox))
      )
        return;
      let o;
      if (n.isBufferGeometry) {
        const r = n.index,
          s = n.attributes.position,
          a = n.morphAttributes.position,
          c = n.morphTargetsRelative,
          l = n.attributes.uv,
          h = n.attributes.uv2,
          u = n.groups,
          d = n.drawRange;
        if (null !== r)
          if (Array.isArray(i))
            for (let n = 0, p = u.length; n < p; n++) {
              const p = u[n],
                f = i[p.materialIndex];
              for (
                let n = Math.max(p.start, d.start),
                  i = Math.min(p.start + p.count, d.start + d.count);
                n < i;
                n += 3
              ) {
                const i = r.getX(n),
                  u = r.getX(n + 1),
                  d = r.getX(n + 2);
                (o = cn(this, f, e, Vt, s, a, c, l, h, i, u, d)),
                  o &&
                    ((o.faceIndex = Math.floor(n / 3)),
                    (o.face.materialIndex = p.materialIndex),
                    t.push(o));
              }
            }
          else
            for (
              let n = Math.max(0, d.start),
                u = Math.min(r.count, d.start + d.count);
              n < u;
              n += 3
            ) {
              const u = r.getX(n),
                d = r.getX(n + 1),
                p = r.getX(n + 2);
              (o = cn(this, i, e, Vt, s, a, c, l, h, u, d, p)),
                o && ((o.faceIndex = Math.floor(n / 3)), t.push(o));
            }
        else if (void 0 !== s)
          if (Array.isArray(i))
            for (let n = 0, r = u.length; n < r; n++) {
              const r = u[n],
                p = i[r.materialIndex];
              for (
                let n = Math.max(r.start, d.start),
                  i = Math.min(r.start + r.count, d.start + d.count);
                n < i;
                n += 3
              )
                (o = cn(this, p, e, Vt, s, a, c, l, h, n, n + 1, n + 2)),
                  o &&
                    ((o.faceIndex = Math.floor(n / 3)),
                    (o.face.materialIndex = r.materialIndex),
                    t.push(o));
            }
          else
            for (
              let n = Math.max(0, d.start),
                r = Math.min(s.count, d.start + d.count);
              n < r;
              n += 3
            )
              (o = cn(this, i, e, Vt, s, a, c, l, h, n, n + 1, n + 2)),
                o && ((o.faceIndex = Math.floor(n / 3)), t.push(o));
      } else if (n.isGeometry) {
        const r = Array.isArray(i),
          s = n.vertices,
          a = n.faces;
        let c;
        const l = n.faceVertexUvs[0];
        l.length > 0 && (c = l);
        for (let n = 0, l = a.length; n < l; n++) {
          const l = a[n],
            h = r ? i[l.materialIndex] : i;
          if (void 0 === h) continue;
          const u = s[l.a],
            d = s[l.b],
            p = s[l.c];
          if (((o = an(this, h, e, Vt, u, d, p, rn)), o)) {
            if (c && c[n]) {
              const e = c[n];
              en.copy(e[0]),
                tn.copy(e[1]),
                nn.copy(e[2]),
                (o.uv = ot.getUV(rn, u, d, p, en, tn, nn, new N()));
            }
            (o.face = l), (o.faceIndex = n), t.push(o);
          }
        }
      }
    },
  });
  class ln extends Ht {
    constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
      super(),
        (this.type = "BoxBufferGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: o,
        });
      const s = this;
      (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
      const a = [],
        c = [],
        l = [],
        h = [];
      let u = 0,
        d = 0;
      function p(e, t, n, i, r, o, p, f, m, g, v) {
        const y = o / m,
          x = p / g,
          _ = o / 2,
          b = p / 2,
          w = f / 2,
          M = m + 1,
          S = g + 1;
        let E = 0,
          T = 0;
        const A = new W();
        for (let o = 0; o < S; o++) {
          const s = o * x - b;
          for (let a = 0; a < M; a++) {
            const u = a * y - _;
            (A[e] = u * i),
              (A[t] = s * r),
              (A[n] = w),
              c.push(A.x, A.y, A.z),
              (A[e] = 0),
              (A[t] = 0),
              (A[n] = f > 0 ? 1 : -1),
              l.push(A.x, A.y, A.z),
              h.push(a / m),
              h.push(1 - o / g),
              (E += 1);
          }
        }
        for (let e = 0; e < g; e++)
          for (let t = 0; t < m; t++) {
            const n = u + t + M * e,
              i = u + t + M * (e + 1),
              r = u + (t + 1) + M * (e + 1),
              o = u + (t + 1) + M * e;
            a.push(n, i, o), a.push(i, r, o), (T += 6);
          }
        s.addGroup(d, T, v), (d += T), (u += E);
      }
      p("z", "y", "x", -1, -1, n, t, e, o, r, 0),
        p("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
        p("x", "z", "y", 1, 1, e, n, t, i, o, 2),
        p("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
        p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
        p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
        this.setIndex(a),
        this.setAttribute("position", new Lt(c, 3)),
        this.setAttribute("normal", new Lt(l, 3)),
        this.setAttribute("uv", new Lt(h, 2));
    }
  }
  function hn(e) {
    const t = {};
    for (const n in e) {
      t[n] = {};
      for (const i in e[n]) {
        const r = e[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture)
          ? (t[n][i] = r.clone())
          : Array.isArray(r)
          ? (t[n][i] = r.slice())
          : (t[n][i] = r);
      }
    }
    return t;
  }
  function un(e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const i = hn(e[n]);
      for (const e in i) t[e] = i[e];
    }
    return t;
  }
  const dn = { clone: hn, merge: un };
  function pn(e) {
    mt.call(this),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
      (this.fragmentShader =
        "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== e &&
        (void 0 !== e.attributes &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
          ),
        this.setValues(e));
  }
  function fn() {
    je.call(this),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new xe()),
      (this.projectionMatrix = new xe()),
      (this.projectionMatrixInverse = new xe());
  }
  function mn(e = 50, t = 1, n = 0.1, i = 2e3) {
    fn.call(this),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  (pn.prototype = Object.create(mt.prototype)),
    (pn.prototype.constructor = pn),
    (pn.prototype.isShaderMaterial = !0),
    (pn.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        (this.fragmentShader = e.fragmentShader),
        (this.vertexShader = e.vertexShader),
        (this.uniforms = hn(e.uniforms)),
        (this.defines = Object.assign({}, e.defines)),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.lights = e.lights),
        (this.clipping = e.clipping),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        (this.extensions = Object.assign({}, e.extensions)),
        (this.glslVersion = e.glslVersion),
        this
      );
    }),
    (pn.prototype.toJSON = function (e) {
      const t = mt.prototype.toJSON.call(this, e);
      (t.glslVersion = this.glslVersion), (t.uniforms = {});
      for (const n in this.uniforms) {
        const i = this.uniforms[n].value;
        i && i.isTexture
          ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
          : i && i.isColor
          ? (t.uniforms[n] = { type: "c", value: i.getHex() })
          : i && i.isVector2
          ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
          : i && i.isVector3
          ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
          : i && i.isVector4
          ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
          : i && i.isMatrix3
          ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
          : i && i.isMatrix4
          ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
          : (t.uniforms[n] = { value: i });
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        (t.vertexShader = this.vertexShader),
        (t.fragmentShader = this.fragmentShader);
      const n = {};
      for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
      return Object.keys(n).length > 0 && (t.extensions = n), t;
    }),
    (fn.prototype = Object.assign(Object.create(je.prototype), {
      constructor: fn,
      isCamera: !0,
      copy: function (e, t) {
        return (
          je.prototype.copy.call(this, e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      },
      getWorldDirection: function (e) {
        void 0 === e &&
          (console.warn(
            "THREE.Camera: .getWorldDirection() target is now required"
          ),
          (e = new W())),
          this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      },
      updateMatrixWorld: function (e) {
        je.prototype.updateMatrixWorld.call(this, e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      },
      updateWorldMatrix: function (e, t) {
        je.prototype.updateWorldMatrix.call(this, e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (mn.prototype = Object.assign(Object.create(fn.prototype), {
      constructor: mn,
      isPerspectiveCamera: !0,
      copy: function (e, t) {
        return (
          fn.prototype.copy.call(this, e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      },
      setFocalLength: function (e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = 2 * I.RAD2DEG * Math.atan(t)),
          this.updateProjectionMatrix();
      },
      getFocalLength: function () {
        const e = Math.tan(0.5 * I.DEG2RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      },
      getEffectiveFOV: function () {
        return (
          2 *
          I.RAD2DEG *
          Math.atan(Math.tan(0.5 * I.DEG2RAD * this.fov) / this.zoom)
        );
      },
      getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function (e, t, n, i, r, o) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = o),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        const e = this.near;
        let t = (e * Math.tan(0.5 * I.DEG2RAD * this.fov)) / this.zoom,
          n = 2 * t,
          i = this.aspect * n,
          r = -0.5 * i;
        const o = this.view;
        if (null !== this.view && this.view.enabled) {
          const e = o.fullWidth,
            s = o.fullHeight;
          (r += (o.offsetX * i) / e),
            (t -= (o.offsetY * n) / s),
            (i *= o.width / e),
            (n *= o.height / s);
        }
        const s = this.filmOffset;
        0 !== s && (r += (e * s) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            t,
            t - n,
            e,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      },
      toJSON: function (e) {
        const t = je.prototype.toJSON.call(this, e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      },
    }));
  const gn = 90;
  function vn(e, t, n) {
    if (
      (je.call(this),
      (this.type = "CubeCamera"),
      !0 !== n.isWebGLCubeRenderTarget)
    )
      return void console.error(
        "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
      );
    this.renderTarget = n;
    const i = new mn(gn, 1, e, t);
    (i.layers = this.layers),
      i.up.set(0, -1, 0),
      i.lookAt(new W(1, 0, 0)),
      this.add(i);
    const r = new mn(gn, 1, e, t);
    (r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new W(-1, 0, 0)),
      this.add(r);
    const o = new mn(gn, 1, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(new W(0, 1, 0)),
      this.add(o);
    const s = new mn(gn, 1, e, t);
    (s.layers = this.layers),
      s.up.set(0, 0, -1),
      s.lookAt(new W(0, -1, 0)),
      this.add(s);
    const a = new mn(gn, 1, e, t);
    (a.layers = this.layers),
      a.up.set(0, -1, 0),
      a.lookAt(new W(0, 0, 1)),
      this.add(a);
    const c = new mn(gn, 1, e, t);
    (c.layers = this.layers),
      c.up.set(0, -1, 0),
      c.lookAt(new W(0, 0, -1)),
      this.add(c),
      (this.update = function (e, t) {
        null === this.parent && this.updateMatrixWorld();
        const l = e.xr.enabled,
          h = e.getRenderTarget();
        e.xr.enabled = !1;
        const u = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          e.setRenderTarget(n, 0),
          e.render(t, i),
          e.setRenderTarget(n, 1),
          e.render(t, r),
          e.setRenderTarget(n, 2),
          e.render(t, o),
          e.setRenderTarget(n, 3),
          e.render(t, s),
          e.setRenderTarget(n, 4),
          e.render(t, a),
          (n.texture.generateMipmaps = u),
          e.setRenderTarget(n, 5),
          e.render(t, c),
          e.setRenderTarget(h),
          (e.xr.enabled = l);
      });
  }
  function yn(e, t, n, i, r, o, s, a, c, l) {
    (e = void 0 !== e ? e : []),
      (t = void 0 !== t ? t : 301),
      (s = void 0 !== s ? s : f),
      B.call(this, e, t, n, i, r, o, s, a, c, l),
      (this.flipY = !1),
      (this._needsFlipEnvMap = !0);
  }
  function xn(e, t, n) {
    Number.isInteger(t) &&
      (console.warn(
        "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
      ),
      (t = n)),
      G.call(this, e, e, t),
      (t = t || {}),
      (this.texture = new yn(
        void 0,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.encoding
      )),
      (this.texture._needsFlipEnvMap = !1);
  }
  function _n(e, t, n, i, o, s, a, c, l, h, u, d) {
    B.call(this, null, s, a, c, l, h, i, o, u, d),
      (this.image = { data: e || null, width: t || 1, height: n || 1 }),
      (this.magFilter = void 0 !== l ? l : r),
      (this.minFilter = void 0 !== h ? h : r),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
  (vn.prototype = Object.create(je.prototype)),
    (vn.prototype.constructor = vn),
    (yn.prototype = Object.create(B.prototype)),
    (yn.prototype.constructor = yn),
    (yn.prototype.isCubeTexture = !0),
    Object.defineProperty(yn.prototype, "images", {
      get: function () {
        return this.image;
      },
      set: function (e) {
        this.image = e;
      },
    }),
    (xn.prototype = Object.create(G.prototype)),
    (xn.prototype.constructor = xn),
    (xn.prototype.isWebGLCubeRenderTarget = !0),
    (xn.prototype.fromEquirectangularTexture = function (e, t) {
      (this.texture.type = t.type),
        (this.texture.format = m),
        (this.texture.encoding = t.encoding),
        (this.texture.generateMipmaps = t.generateMipmaps),
        (this.texture.minFilter = t.minFilter),
        (this.texture.magFilter = t.magFilter);
      const n = { tEquirect: { value: null } },
        i =
          "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
        r =
          "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
        o = new ln(5, 5, 5),
        s = new pn({
          name: "CubemapFromEquirect",
          uniforms: hn(n),
          vertexShader: i,
          fragmentShader: r,
          side: 1,
          blending: 0,
        });
      s.uniforms.tEquirect.value = t;
      const l = new sn(o, s),
        h = t.minFilter;
      return (
        t.minFilter === c && (t.minFilter = a),
        new vn(1, 10, this).update(e, l),
        (t.minFilter = h),
        l.geometry.dispose(),
        l.material.dispose(),
        this
      );
    }),
    (xn.prototype.clear = function (e, t, n, i) {
      const r = e.getRenderTarget();
      for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
      e.setRenderTarget(r);
    }),
    (_n.prototype = Object.create(B.prototype)),
    (_n.prototype.constructor = _n),
    (_n.prototype.isDataTexture = !0);
  const bn = new he(),
    wn = new W();
  class Mn {
    constructor(e, t, n, i, r, o) {
      this.planes = [
        void 0 !== e ? e : new Ye(),
        void 0 !== t ? t : new Ye(),
        void 0 !== n ? n : new Ye(),
        void 0 !== i ? i : new Ye(),
        void 0 !== r ? r : new Ye(),
        void 0 !== o ? o : new Ye(),
      ];
    }
    set(e, t, n, i, r, o) {
      const s = this.planes;
      return (
        s[0].copy(e),
        s[1].copy(t),
        s[2].copy(n),
        s[3].copy(i),
        s[4].copy(r),
        s[5].copy(o),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
      return this;
    }
    setFromProjectionMatrix(e) {
      const t = this.planes,
        n = e.elements,
        i = n[0],
        r = n[1],
        o = n[2],
        s = n[3],
        a = n[4],
        c = n[5],
        l = n[6],
        h = n[7],
        u = n[8],
        d = n[9],
        p = n[10],
        f = n[11],
        m = n[12],
        g = n[13],
        v = n[14],
        y = n[15];
      return (
        t[0].setComponents(s - i, h - a, f - u, y - m).normalize(),
        t[1].setComponents(s + i, h + a, f + u, y + m).normalize(),
        t[2].setComponents(s + r, h + c, f + d, y + g).normalize(),
        t[3].setComponents(s - r, h - c, f - d, y - g).normalize(),
        t[4].setComponents(s - o, h - l, f - p, y - v).normalize(),
        t[5].setComponents(s + o, h + l, f + p, y + v).normalize(),
        this
      );
    }
    intersectsObject(e) {
      const t = e.geometry;
      return (
        null === t.boundingSphere && t.computeBoundingSphere(),
        bn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(bn)
      );
    }
    intersectsSprite(e) {
      return (
        bn.center.set(0, 0, 0),
        (bn.radius = 0.7071067811865476),
        bn.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(bn)
      );
    }
    intersectsSphere(e) {
      const t = this.planes,
        n = e.center,
        i = -e.radius;
      for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(n) < i) return !1;
      return !0;
    }
    intersectsBox(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = t[n];
        if (
          ((wn.x = i.normal.x > 0 ? e.max.x : e.min.x),
          (wn.y = i.normal.y > 0 ? e.max.y : e.min.y),
          (wn.z = i.normal.z > 0 ? e.max.z : e.min.z),
          i.distanceToPoint(wn) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
      return !0;
    }
  }
  function Sn() {
    let e = null,
      t = !1,
      n = null,
      i = null;
    function r(t, o) {
      n(t, o), (i = e.requestAnimationFrame(r));
    }
    return {
      start: function () {
        !0 !== t && null !== n && ((i = e.requestAnimationFrame(r)), (t = !0));
      },
      stop: function () {
        e.cancelAnimationFrame(i), (t = !1);
      },
      setAnimationLoop: function (e) {
        n = e;
      },
      setContext: function (t) {
        e = t;
      },
    };
  }
  function En(e, t) {
    const n = t.isWebGL2,
      i = new WeakMap();
    return {
      get: function (e) {
        return e.isInterleavedBufferAttribute && (e = e.data), i.get(e);
      },
      remove: function (t) {
        t.isInterleavedBufferAttribute && (t = t.data);
        const n = i.get(t);
        n && (e.deleteBuffer(n.buffer), i.delete(t));
      },
      update: function (t, r) {
        if (t.isGLBufferAttribute) {
          const e = i.get(t);
          return void (
            (!e || e.version < t.version) &&
            i.set(t, {
              buffer: t.buffer,
              type: t.type,
              bytesPerElement: t.elementSize,
              version: t.version,
            })
          );
        }
        t.isInterleavedBufferAttribute && (t = t.data);
        const o = i.get(t);
        void 0 === o
          ? i.set(
              t,
              (function (t, i) {
                const r = t.array,
                  o = t.usage,
                  s = e.createBuffer();
                e.bindBuffer(i, s), e.bufferData(i, r, o), t.onUploadCallback();
                let a = 5126;
                return (
                  r instanceof Float32Array
                    ? (a = 5126)
                    : r instanceof Float64Array
                    ? console.warn(
                        "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                      )
                    : r instanceof Uint16Array
                    ? t.isFloat16BufferAttribute
                      ? n
                        ? (a = 5131)
                        : console.warn(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          )
                      : (a = 5123)
                    : r instanceof Int16Array
                    ? (a = 5122)
                    : r instanceof Uint32Array
                    ? (a = 5125)
                    : r instanceof Int32Array
                    ? (a = 5124)
                    : r instanceof Int8Array
                    ? (a = 5120)
                    : r instanceof Uint8Array && (a = 5121),
                  {
                    buffer: s,
                    type: a,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: t.version,
                  }
                );
              })(t, r)
            )
          : o.version < t.version &&
            ((function (t, i, r) {
              const o = i.array,
                s = i.updateRange;
              e.bindBuffer(r, t),
                -1 === s.count
                  ? e.bufferSubData(r, 0, o)
                  : (n
                      ? e.bufferSubData(
                          r,
                          s.offset * o.BYTES_PER_ELEMENT,
                          o,
                          s.offset,
                          s.count
                        )
                      : e.bufferSubData(
                          r,
                          s.offset * o.BYTES_PER_ELEMENT,
                          o.subarray(s.offset, s.offset + s.count)
                        ),
                    (s.count = -1));
            })(o.buffer, t, r),
            (o.version = t.version));
      },
    };
  }
  class Tn extends Ht {
    constructor(e = 1, t = 1, n = 1, i = 1) {
      super(),
        (this.type = "PlaneBufferGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          widthSegments: n,
          heightSegments: i,
        });
      const r = e / 2,
        o = t / 2,
        s = Math.floor(n),
        a = Math.floor(i),
        c = s + 1,
        l = a + 1,
        h = e / s,
        u = t / a,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let e = 0; e < l; e++) {
        const t = e * u - o;
        for (let n = 0; n < c; n++) {
          const i = n * h - r;
          p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - e / a);
        }
      }
      for (let e = 0; e < a; e++)
        for (let t = 0; t < s; t++) {
          const n = t + c * e,
            i = t + c * (e + 1),
            r = t + 1 + c * (e + 1),
            o = t + 1 + c * e;
          d.push(n, i, o), d.push(i, r, o);
        }
      this.setIndex(d),
        this.setAttribute("position", new Lt(p, 3)),
        this.setAttribute("normal", new Lt(f, 3)),
        this.setAttribute("uv", new Lt(m, 2));
    }
  }
  const An = {
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      begin_vertex: "vec3 transformed = vec3( position );",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      encodings_pars_fragment:
        "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_vertex:
        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
      normal_fragment_begin:
        "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      normal_fragment_maps:
        "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmissionmap_fragment:
        "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
      transmissionmap_pars_fragment:
        "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
      uv_pars_fragment:
        "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
      uv_pars_vertex:
        "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
      uv_vertex:
        "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
      uv2_pars_fragment:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
      uv2_pars_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
      uv2_vertex:
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_frag:
        "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      cube_frag:
        "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      depth_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      normal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
      normal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    },
    Ln = {
      common: {
        diffuse: { value: new dt(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new D() },
        uv2Transform: { value: new D() },
        alphaMap: { value: null },
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 },
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new N(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new dt(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new dt(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new D() },
      },
      sprite: {
        diffuse: { value: new dt(15658734) },
        opacity: { value: 1 },
        center: { value: new N(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        uvTransform: { value: new D() },
      },
    },
    Rn = {
      basic: {
        uniforms: un([
          Ln.common,
          Ln.specularmap,
          Ln.envmap,
          Ln.aomap,
          Ln.lightmap,
          Ln.fog,
        ]),
        vertexShader: An.meshbasic_vert,
        fragmentShader: An.meshbasic_frag,
      },
      lambert: {
        uniforms: un([
          Ln.common,
          Ln.specularmap,
          Ln.envmap,
          Ln.aomap,
          Ln.lightmap,
          Ln.emissivemap,
          Ln.fog,
          Ln.lights,
          { emissive: { value: new dt(0) } },
        ]),
        vertexShader: An.meshlambert_vert,
        fragmentShader: An.meshlambert_frag,
      },
      phong: {
        uniforms: un([
          Ln.common,
          Ln.specularmap,
          Ln.envmap,
          Ln.aomap,
          Ln.lightmap,
          Ln.emissivemap,
          Ln.bumpmap,
          Ln.normalmap,
          Ln.displacementmap,
          Ln.fog,
          Ln.lights,
          {
            emissive: { value: new dt(0) },
            specular: { value: new dt(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: An.meshphong_vert,
        fragmentShader: An.meshphong_frag,
      },
      standard: {
        uniforms: un([
          Ln.common,
          Ln.envmap,
          Ln.aomap,
          Ln.lightmap,
          Ln.emissivemap,
          Ln.bumpmap,
          Ln.normalmap,
          Ln.displacementmap,
          Ln.roughnessmap,
          Ln.metalnessmap,
          Ln.fog,
          Ln.lights,
          {
            emissive: { value: new dt(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: An.meshphysical_vert,
        fragmentShader: An.meshphysical_frag,
      },
      toon: {
        uniforms: un([
          Ln.common,
          Ln.aomap,
          Ln.lightmap,
          Ln.emissivemap,
          Ln.bumpmap,
          Ln.normalmap,
          Ln.displacementmap,
          Ln.gradientmap,
          Ln.fog,
          Ln.lights,
          { emissive: { value: new dt(0) } },
        ]),
        vertexShader: An.meshtoon_vert,
        fragmentShader: An.meshtoon_frag,
      },
      matcap: {
        uniforms: un([
          Ln.common,
          Ln.bumpmap,
          Ln.normalmap,
          Ln.displacementmap,
          Ln.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: An.meshmatcap_vert,
        fragmentShader: An.meshmatcap_frag,
      },
      points: {
        uniforms: un([Ln.points, Ln.fog]),
        vertexShader: An.points_vert,
        fragmentShader: An.points_frag,
      },
      dashed: {
        uniforms: un([
          Ln.common,
          Ln.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: An.linedashed_vert,
        fragmentShader: An.linedashed_frag,
      },
      depth: {
        uniforms: un([Ln.common, Ln.displacementmap]),
        vertexShader: An.depth_vert,
        fragmentShader: An.depth_frag,
      },
      normal: {
        uniforms: un([
          Ln.common,
          Ln.bumpmap,
          Ln.normalmap,
          Ln.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: An.normal_vert,
        fragmentShader: An.normal_frag,
      },
      sprite: {
        uniforms: un([Ln.sprite, Ln.fog]),
        vertexShader: An.sprite_vert,
        fragmentShader: An.sprite_frag,
      },
      background: {
        uniforms: { uvTransform: { value: new D() }, t2D: { value: null } },
        vertexShader: An.background_vert,
        fragmentShader: An.background_frag,
      },
      cube: {
        uniforms: un([Ln.envmap, { opacity: { value: 1 } }]),
        vertexShader: An.cube_vert,
        fragmentShader: An.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: An.equirect_vert,
        fragmentShader: An.equirect_frag,
      },
      distanceRGBA: {
        uniforms: un([
          Ln.common,
          Ln.displacementmap,
          {
            referencePosition: { value: new W() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: An.distanceRGBA_vert,
        fragmentShader: An.distanceRGBA_frag,
      },
      shadow: {
        uniforms: un([
          Ln.lights,
          Ln.fog,
          { color: { value: new dt(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: An.shadow_vert,
        fragmentShader: An.shadow_frag,
      },
    };
  function Cn(e, t, n, i, r) {
    const o = new dt(0);
    let s,
      a,
      c = 0,
      l = null,
      h = 0,
      u = null;
    function d(e, t) {
      n.buffers.color.setClear(e.r, e.g, e.b, t, r);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (e, t = 1) {
        o.set(e), (c = t), d(o, c);
      },
      getClearAlpha: function () {
        return c;
      },
      setClearAlpha: function (e) {
        (c = e), d(o, c);
      },
      render: function (n, r, p, f) {
        let m = !0 === r.isScene ? r.background : null;
        m && m.isTexture && (m = t.get(m));
        const g = e.xr,
          v = g.getSession && g.getSession();
        v && "additive" === v.environmentBlendMode && (m = null),
          null === m ? d(o, c) : m && m.isColor && (d(m, 1), (f = !0)),
          (e.autoClear || f) &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          m &&
          (m.isCubeTexture || m.isWebGLCubeRenderTarget || 306 === m.mapping)
            ? (void 0 === a &&
                ((a = new sn(
                  new ln(1, 1, 1),
                  new pn({
                    name: "BackgroundCubeMaterial",
                    uniforms: hn(Rn.cube.uniforms),
                    vertexShader: Rn.cube.vertexShader,
                    fragmentShader: Rn.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                a.geometry.deleteAttribute("normal"),
                a.geometry.deleteAttribute("uv"),
                (a.onBeforeRender = function (e, t, n) {
                  this.matrixWorld.copyPosition(n.matrixWorld);
                }),
                Object.defineProperty(a.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                i.update(a)),
              m.isWebGLCubeRenderTarget && (m = m.texture),
              (a.material.uniforms.envMap.value = m),
              (a.material.uniforms.flipEnvMap.value =
                m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1),
              (l === m && h === m.version && u === e.toneMapping) ||
                ((a.material.needsUpdate = !0),
                (l = m),
                (h = m.version),
                (u = e.toneMapping)),
              n.unshift(a, a.geometry, a.material, 0, 0, null))
            : m &&
              m.isTexture &&
              (void 0 === s &&
                ((s = new sn(
                  new Tn(2, 2),
                  new pn({
                    name: "BackgroundMaterial",
                    uniforms: hn(Rn.background.uniforms),
                    vertexShader: Rn.background.vertexShader,
                    fragmentShader: Rn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                s.geometry.deleteAttribute("normal"),
                Object.defineProperty(s.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                i.update(s)),
              (s.material.uniforms.t2D.value = m),
              !0 === m.matrixAutoUpdate && m.updateMatrix(),
              s.material.uniforms.uvTransform.value.copy(m.matrix),
              (l === m && h === m.version && u === e.toneMapping) ||
                ((s.material.needsUpdate = !0),
                (l = m),
                (h = m.version),
                (u = e.toneMapping)),
              n.unshift(s, s.geometry, s.material, 0, 0, null));
      },
    };
  }
  function Pn(e, t, n, i) {
    const r = e.getParameter(34921),
      o = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
      s = i.isWebGL2 || null !== o,
      a = {},
      c = d(null);
    let l = c;
    function h(t) {
      return i.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t);
    }
    function u(t) {
      return i.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t);
    }
    function d(e) {
      const t = [],
        n = [],
        i = [];
      for (let e = 0; e < r; e++) (t[e] = 0), (n[e] = 0), (i[e] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: t,
        enabledAttributes: n,
        attributeDivisors: i,
        object: e,
        attributes: {},
        index: null,
      };
    }
    function p() {
      const e = l.newAttributes;
      for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
    }
    function f(e) {
      m(e, 0);
    }
    function m(n, r) {
      const o = l.newAttributes,
        s = l.enabledAttributes,
        a = l.attributeDivisors;
      (o[n] = 1),
        0 === s[n] && (e.enableVertexAttribArray(n), (s[n] = 1)),
        a[n] !== r &&
          ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
          (a[n] = r));
    }
    function g() {
      const t = l.newAttributes,
        n = l.enabledAttributes;
      for (let i = 0, r = n.length; i < r; i++)
        n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
    }
    function v(t, n, r, o, s, a) {
      !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
        ? e.vertexAttribPointer(t, n, r, o, s, a)
        : e.vertexAttribIPointer(t, n, r, s, a);
    }
    function y() {
      x(), l !== c && ((l = c), h(l.object));
    }
    function x() {
      (c.geometry = null), (c.program = null), (c.wireframe = !1);
    }
    return {
      setup: function (r, c, u, y, x) {
        let _ = !1;
        if (s) {
          const t = (function (t, n, r) {
            const s = !0 === r.wireframe;
            let c = a[t.id];
            void 0 === c && ((c = {}), (a[t.id] = c));
            let l = c[n.id];
            void 0 === l && ((l = {}), (c[n.id] = l));
            let h = l[s];
            return (
              void 0 === h &&
                ((h = d(
                  i.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()
                )),
                (l[s] = h)),
              h
            );
          })(y, u, c);
          l !== t && ((l = t), h(l.object)),
            (_ = (function (e, t) {
              const n = l.attributes,
                i = e.attributes;
              let r = 0;
              for (const e in i) {
                const t = n[e],
                  o = i[e];
                if (void 0 === t) return !0;
                if (t.attribute !== o) return !0;
                if (t.data !== o.data) return !0;
                r++;
              }
              return l.attributesNum !== r || l.index !== t;
            })(y, x)),
            _ &&
              (function (e, t) {
                const n = {},
                  i = e.attributes;
                let r = 0;
                for (const e in i) {
                  const t = i[e],
                    o = {};
                  (o.attribute = t),
                    t.data && (o.data = t.data),
                    (n[e] = o),
                    r++;
                }
                (l.attributes = n), (l.attributesNum = r), (l.index = t);
              })(y, x);
        } else {
          const e = !0 === c.wireframe;
          (l.geometry === y.id && l.program === u.id && l.wireframe === e) ||
            ((l.geometry = y.id),
            (l.program = u.id),
            (l.wireframe = e),
            (_ = !0));
        }
        !0 === r.isInstancedMesh && (_ = !0),
          null !== x && n.update(x, 34963),
          _ &&
            ((function (r, o, s, a) {
              if (
                !1 === i.isWebGL2 &&
                (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                null === t.get("ANGLE_instanced_arrays")
              )
                return;
              p();
              const c = a.attributes,
                l = s.getAttributes(),
                h = o.defaultAttributeValues;
              for (const t in l) {
                const i = l[t];
                if (i >= 0) {
                  const o = c[t];
                  if (void 0 !== o) {
                    const t = o.normalized,
                      r = o.itemSize,
                      s = n.get(o);
                    if (void 0 === s) continue;
                    const c = s.buffer,
                      l = s.type,
                      h = s.bytesPerElement;
                    if (o.isInterleavedBufferAttribute) {
                      const n = o.data,
                        s = n.stride,
                        u = o.offset;
                      n && n.isInstancedInterleavedBuffer
                        ? (m(i, n.meshPerAttribute),
                          void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              n.meshPerAttribute * n.count))
                        : f(i),
                        e.bindBuffer(34962, c),
                        v(i, r, l, t, s * h, u * h);
                    } else
                      o.isInstancedBufferAttribute
                        ? (m(i, o.meshPerAttribute),
                          void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              o.meshPerAttribute * o.count))
                        : f(i),
                        e.bindBuffer(34962, c),
                        v(i, r, l, t, 0, 0);
                  } else if ("instanceMatrix" === t) {
                    const t = n.get(r.instanceMatrix);
                    if (void 0 === t) continue;
                    const o = t.buffer,
                      s = t.type;
                    m(i + 0, 1),
                      m(i + 1, 1),
                      m(i + 2, 1),
                      m(i + 3, 1),
                      e.bindBuffer(34962, o),
                      e.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                      e.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                      e.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                      e.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
                  } else if ("instanceColor" === t) {
                    const t = n.get(r.instanceColor);
                    if (void 0 === t) continue;
                    const o = t.buffer,
                      s = t.type;
                    m(i, 1),
                      e.bindBuffer(34962, o),
                      e.vertexAttribPointer(i, 3, s, !1, 12, 0);
                  } else if (void 0 !== h) {
                    const n = h[t];
                    if (void 0 !== n)
                      switch (n.length) {
                        case 2:
                          e.vertexAttrib2fv(i, n);
                          break;
                        case 3:
                          e.vertexAttrib3fv(i, n);
                          break;
                        case 4:
                          e.vertexAttrib4fv(i, n);
                          break;
                        default:
                          e.vertexAttrib1fv(i, n);
                      }
                  }
                }
              }
              g();
            })(r, c, u, y),
            null !== x && e.bindBuffer(34963, n.get(x).buffer));
      },
      reset: y,
      resetDefaultState: x,
      dispose: function () {
        y();
        for (const e in a) {
          const t = a[e];
          for (const e in t) {
            const n = t[e];
            for (const e in n) u(n[e].object), delete n[e];
            delete t[e];
          }
          delete a[e];
        }
      },
      releaseStatesOfGeometry: function (e) {
        if (void 0 === a[e.id]) return;
        const t = a[e.id];
        for (const e in t) {
          const n = t[e];
          for (const e in n) u(n[e].object), delete n[e];
          delete t[e];
        }
        delete a[e.id];
      },
      releaseStatesOfProgram: function (e) {
        for (const t in a) {
          const n = a[t];
          if (void 0 === n[e.id]) continue;
          const i = n[e.id];
          for (const e in i) u(i[e].object), delete i[e];
          delete n[e.id];
        }
      },
      initAttributes: p,
      enableAttribute: f,
      disableUnusedAttributes: g,
    };
  }
  function On(e, t, n, i) {
    const r = i.isWebGL2;
    let o;
    (this.setMode = function (e) {
      o = e;
    }),
      (this.render = function (t, i) {
        e.drawArrays(o, t, i), n.update(i, o, 1);
      }),
      (this.renderInstances = function (i, s, a) {
        if (0 === a) return;
        let c, l;
        if (r) (c = e), (l = "drawArraysInstanced");
        else if (
          ((c = t.get("ANGLE_instanced_arrays")),
          (l = "drawArraysInstancedANGLE"),
          null === c)
        )
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        c[l](o, i, s, a), n.update(s, o, a);
      });
  }
  function In(e, t, n) {
    let i;
    function r(t) {
      if ("highp" === t) {
        if (
          e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
          e.getShaderPrecisionFormat(35632, 36338).precision > 0
        )
          return "highp";
        t = "mediump";
      }
      return "mediump" === t &&
        e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
        e.getShaderPrecisionFormat(35632, 36337).precision > 0
        ? "mediump"
        : "lowp";
    }
    const o =
      ("undefined" != typeof WebGL2RenderingContext &&
        e instanceof WebGL2RenderingContext) ||
      ("undefined" != typeof WebGL2ComputeRenderingContext &&
        e instanceof WebGL2ComputeRenderingContext);
    let s = void 0 !== n.precision ? n.precision : "highp";
    const a = r(s);
    a !== s &&
      (console.warn(
        "THREE.WebGLRenderer:",
        s,
        "not supported, using",
        a,
        "instead."
      ),
      (s = a));
    const c = !0 === n.logarithmicDepthBuffer,
      l = e.getParameter(34930),
      h = e.getParameter(35660),
      u = e.getParameter(3379),
      d = e.getParameter(34076),
      p = e.getParameter(34921),
      f = e.getParameter(36347),
      m = e.getParameter(36348),
      g = e.getParameter(36349),
      v = h > 0,
      y = o || !!t.get("OES_texture_float");
    return {
      isWebGL2: o,
      getMaxAnisotropy: function () {
        if (void 0 !== i) return i;
        const n = t.get("EXT_texture_filter_anisotropic");
        return (
          (i =
            null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0),
          i
        );
      },
      getMaxPrecision: r,
      precision: s,
      logarithmicDepthBuffer: c,
      maxTextures: l,
      maxVertexTextures: h,
      maxTextureSize: u,
      maxCubemapSize: d,
      maxAttributes: p,
      maxVertexUniforms: f,
      maxVaryings: m,
      maxFragmentUniforms: g,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y,
      maxSamples: o ? e.getParameter(36183) : 0,
    };
  }
  function Nn(e) {
    const t = this;
    let n = null,
      i = 0,
      r = !1,
      o = !1;
    const s = new Ye(),
      a = new D(),
      c = { value: null, needsUpdate: !1 };
    function l() {
      c.value !== n && ((c.value = n), (c.needsUpdate = i > 0)),
        (t.numPlanes = i),
        (t.numIntersection = 0);
    }
    function h(e, n, i, r) {
      const o = null !== e ? e.length : 0;
      let l = null;
      if (0 !== o) {
        if (((l = c.value), !0 !== r || null === l)) {
          const t = i + 4 * o,
            r = n.matrixWorldInverse;
          a.getNormalMatrix(r),
            (null === l || l.length < t) && (l = new Float32Array(t));
          for (let t = 0, n = i; t !== o; ++t, n += 4)
            s.copy(e[t]).applyMatrix4(r, a),
              s.normal.toArray(l, n),
              (l[n + 3] = s.constant);
        }
        (c.value = l), (c.needsUpdate = !0);
      }
      return (t.numPlanes = o), (t.numIntersection = 0), l;
    }
    (this.uniform = c),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (e, t, o) {
        const s = 0 !== e.length || t || 0 !== i || r;
        return (r = t), (n = h(e, o, 0)), (i = e.length), s;
      }),
      (this.beginShadows = function () {
        (o = !0), h(null);
      }),
      (this.endShadows = function () {
        (o = !1), l();
      }),
      (this.setState = function (t, s, a) {
        const u = t.clippingPlanes,
          d = t.clipIntersection,
          p = t.clipShadows,
          f = e.get(t);
        if (!r || null === u || 0 === u.length || (o && !p)) o ? h(null) : l();
        else {
          const e = o ? 0 : i,
            t = 4 * e;
          let r = f.clippingState || null;
          (c.value = r), (r = h(u, s, t, a));
          for (let e = 0; e !== t; ++e) r[e] = n[e];
          (f.clippingState = r),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += e);
        }
      });
  }
  function Dn(e) {
    let t = new WeakMap();
    function n(e, t) {
      return 303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e;
    }
    function i(e) {
      const n = e.target;
      n.removeEventListener("dispose", i);
      const r = t.get(n);
      void 0 !== r && (t.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const o = r.mapping;
          if (303 === o || 304 === o) {
            if (t.has(r)) return n(t.get(r).texture, r.mapping);
            {
              const o = r.image;
              if (o && o.height > 0) {
                const s = e.getRenderList(),
                  a = e.getRenderTarget(),
                  c = new xn(o.height / 2);
                return (
                  c.fromEquirectangularTexture(e, r),
                  t.set(r, c),
                  e.setRenderTarget(a),
                  e.setRenderList(s),
                  r.addEventListener("dispose", i),
                  n(c.texture, r.mapping)
                );
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Fn(e) {
    const t = {};
    return {
      has: function (n) {
        if (void 0 !== t[n]) return null !== t[n];
        let i;
        switch (n) {
          case "WEBGL_depth_texture":
            i =
              e.getExtension("WEBGL_depth_texture") ||
              e.getExtension("MOZ_WEBGL_depth_texture") ||
              e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            i =
              e.getExtension("EXT_texture_filter_anisotropic") ||
              e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            i =
              e.getExtension("WEBGL_compressed_texture_s3tc") ||
              e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            i =
              e.getExtension("WEBGL_compressed_texture_pvrtc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            i = e.getExtension(n);
        }
        return (t[n] = i), null !== i;
      },
      get: function (e) {
        return (
          this.has(e) ||
            console.warn(
              "THREE.WebGLRenderer: " + e + " extension not supported."
            ),
          t[e]
        );
      },
    };
  }
  function Un(e, t, n, i) {
    const r = new WeakMap(),
      o = new WeakMap();
    function s(e) {
      const a = e.target,
        c = r.get(a);
      null !== c.index && t.remove(c.index);
      for (const e in c.attributes) t.remove(c.attributes[e]);
      a.removeEventListener("dispose", s), r.delete(a);
      const l = o.get(c);
      l && (t.remove(l), o.delete(c)),
        i.releaseStatesOfGeometry(c),
        !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
        n.memory.geometries--;
    }
    function a(e) {
      const n = [],
        i = e.index,
        r = e.attributes.position;
      let s = 0;
      if (null !== i) {
        const e = i.array;
        s = i.version;
        for (let t = 0, i = e.length; t < i; t += 3) {
          const i = e[t + 0],
            r = e[t + 1],
            o = e[t + 2];
          n.push(i, r, r, o, o, i);
        }
      } else {
        const e = r.array;
        s = r.version;
        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
          const e = t + 0,
            i = t + 1,
            r = t + 2;
          n.push(e, i, i, r, r, e);
        }
      }
      const a = new (Pt(n) > 65535 ? Tt : St)(n, 1);
      a.version = s;
      const c = o.get(e);
      c && t.remove(c), o.set(e, a);
    }
    return {
      get: function (e, t) {
        let i = r.get(t);
        return (
          i ||
          (t.addEventListener("dispose", s),
          t.isBufferGeometry
            ? (i = t)
            : t.isGeometry &&
              (void 0 === t._bufferGeometry &&
                (t._bufferGeometry = new Ht().setFromObject(e)),
              (i = t._bufferGeometry)),
          r.set(t, i),
          n.memory.geometries++,
          i)
        );
      },
      update: function (e) {
        const n = e.attributes;
        for (const e in n) t.update(n[e], 34962);
        const i = e.morphAttributes;
        for (const e in i) {
          const n = i[e];
          for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962);
        }
      },
      getWireframeAttribute: function (e) {
        const t = o.get(e);
        if (t) {
          const n = e.index;
          null !== n && t.version < n.version && a(e);
        } else a(e);
        return o.get(e);
      },
    };
  }
  function kn(e, t, n, i) {
    const r = i.isWebGL2;
    let o, s, a;
    (this.setMode = function (e) {
      o = e;
    }),
      (this.setIndex = function (e) {
        (s = e.type), (a = e.bytesPerElement);
      }),
      (this.render = function (t, i) {
        e.drawElements(o, i, s, t * a), n.update(i, o, 1);
      }),
      (this.renderInstances = function (i, c, l) {
        if (0 === l) return;
        let h, u;
        if (r) (h = e), (u = "drawElementsInstanced");
        else if (
          ((h = t.get("ANGLE_instanced_arrays")),
          (u = "drawElementsInstancedANGLE"),
          null === h)
        )
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        h[u](o, c, s, i * a, l), n.update(c, o, l);
      });
  }
  function Bn(e) {
    const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: t,
      programs: null,
      autoReset: !0,
      reset: function () {
        t.frame++,
          (t.calls = 0),
          (t.triangles = 0),
          (t.points = 0),
          (t.lines = 0);
      },
      update: function (e, n, i) {
        switch ((t.calls++, n)) {
          case 4:
            t.triangles += i * (e / 3);
            break;
          case 1:
            t.lines += i * (e / 2);
            break;
          case 3:
            t.lines += i * (e - 1);
            break;
          case 2:
            t.lines += i * e;
            break;
          case 0:
            t.points += i * e;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      },
    };
  }
  function zn(e, t) {
    return e[0] - t[0];
  }
  function Hn(e, t) {
    return Math.abs(t[1]) - Math.abs(e[1]);
  }
  function Gn(e) {
    const t = {},
      n = new Float32Array(8),
      i = [];
    for (let e = 0; e < 8; e++) i[e] = [e, 0];
    return {
      update: function (r, o, s, a) {
        const c = r.morphTargetInfluences,
          l = void 0 === c ? 0 : c.length;
        let h = t[o.id];
        if (void 0 === h) {
          h = [];
          for (let e = 0; e < l; e++) h[e] = [e, 0];
          t[o.id] = h;
        }
        for (let e = 0; e < l; e++) {
          const t = h[e];
          (t[0] = e), (t[1] = c[e]);
        }
        h.sort(Hn);
        for (let e = 0; e < 8; e++)
          e < l && h[e][1]
            ? ((i[e][0] = h[e][0]), (i[e][1] = h[e][1]))
            : ((i[e][0] = Number.MAX_SAFE_INTEGER), (i[e][1] = 0));
        i.sort(zn);
        const u = s.morphTargets && o.morphAttributes.position,
          d = s.morphNormals && o.morphAttributes.normal;
        let p = 0;
        for (let e = 0; e < 8; e++) {
          const t = i[e],
            r = t[0],
            s = t[1];
          r !== Number.MAX_SAFE_INTEGER && s
            ? (u &&
                o.getAttribute("morphTarget" + e) !== u[r] &&
                o.setAttribute("morphTarget" + e, u[r]),
              d &&
                o.getAttribute("morphNormal" + e) !== d[r] &&
                o.setAttribute("morphNormal" + e, d[r]),
              (n[e] = s),
              (p += s))
            : (u &&
                !0 === o.hasAttribute("morphTarget" + e) &&
                o.deleteAttribute("morphTarget" + e),
              d &&
                !0 === o.hasAttribute("morphNormal" + e) &&
                o.deleteAttribute("morphNormal" + e),
              (n[e] = 0));
        }
        const f = o.morphTargetsRelative ? 1 : 1 - p;
        a.getUniforms().setValue(e, "morphTargetBaseInfluence", f),
          a.getUniforms().setValue(e, "morphTargetInfluences", n);
      },
    };
  }
  function Vn(e, t, n, i) {
    let r = new WeakMap();
    function o(e) {
      const t = e.target;
      t.removeEventListener("dispose", o),
        n.remove(t.instanceMatrix),
        null !== t.instanceColor && n.remove(t.instanceColor);
    }
    return {
      update: function (e) {
        const s = i.render.frame,
          a = e.geometry,
          c = t.get(e, a);
        return (
          r.get(c) !== s &&
            (a.isGeometry && c.updateFromObject(e), t.update(c), r.set(c, s)),
          e.isInstancedMesh &&
            (!1 === e.hasEventListener("dispose", o) &&
              e.addEventListener("dispose", o),
            n.update(e.instanceMatrix, 34962),
            null !== e.instanceColor && n.update(e.instanceColor, 34962)),
          c
        );
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  function jn(e = null, t = 1, i = 1, o = 1) {
    B.call(this, null),
      (this.image = { data: e, width: t, height: i, depth: o }),
      (this.magFilter = r),
      (this.minFilter = r),
      (this.wrapR = n),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.needsUpdate = !0);
  }
  function Wn(e = null, t = 1, i = 1, o = 1) {
    B.call(this, null),
      (this.image = { data: e, width: t, height: i, depth: o }),
      (this.magFilter = r),
      (this.minFilter = r),
      (this.wrapR = n),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.needsUpdate = !0);
  }
  (Rn.physical = {
    uniforms: un([
      Rn.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new N(1, 1) },
        clearcoatNormalMap: { value: null },
        sheen: { value: new dt(0) },
        transmission: { value: 0 },
        transmissionMap: { value: null },
      },
    ]),
    vertexShader: An.meshphysical_vert,
    fragmentShader: An.meshphysical_frag,
  }),
    (jn.prototype = Object.create(B.prototype)),
    (jn.prototype.constructor = jn),
    (jn.prototype.isDataTexture2DArray = !0),
    (Wn.prototype = Object.create(B.prototype)),
    (Wn.prototype.constructor = Wn),
    (Wn.prototype.isDataTexture3D = !0);
  const Xn = new B(),
    qn = new jn(),
    Yn = new Wn(),
    Zn = new yn(),
    Jn = [],
    Kn = [],
    Qn = new Float32Array(16),
    $n = new Float32Array(9),
    ei = new Float32Array(4);
  function ti(e, t, n) {
    const i = e[0];
    if (i <= 0 || i > 0) return e;
    const r = t * n;
    let o = Jn[r];
    if ((void 0 === o && ((o = new Float32Array(r)), (Jn[r] = o)), 0 !== t)) {
      i.toArray(o, 0);
      for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(o, r);
    }
    return o;
  }
  function ni(e, t) {
    if (e.length !== t.length) return !1;
    for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
    return !0;
  }
  function ii(e, t) {
    for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
  }
  function ri(e, t) {
    let n = Kn[t];
    void 0 === n && ((n = new Int32Array(t)), (Kn[t] = n));
    for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
    return n;
  }
  function oi(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
  }
  function si(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
      (n[0] === t.x && n[1] === t.y) ||
        (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
    else {
      if (ni(n, t)) return;
      e.uniform2fv(this.addr, t), ii(n, t);
    }
  }
  function ai(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
      (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
        (e.uniform3f(this.addr, t.x, t.y, t.z),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z));
    else if (void 0 !== t.r)
      (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
        (e.uniform3f(this.addr, t.r, t.g, t.b),
        (n[0] = t.r),
        (n[1] = t.g),
        (n[2] = t.b));
    else {
      if (ni(n, t)) return;
      e.uniform3fv(this.addr, t), ii(n, t);
    }
  }
  function ci(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
      (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
        (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        (n[0] = t.x),
        (n[1] = t.y),
        (n[2] = t.z),
        (n[3] = t.w));
    else {
      if (ni(n, t)) return;
      e.uniform4fv(this.addr, t), ii(n, t);
    }
  }
  function li(e, t) {
    const n = this.cache,
      i = t.elements;
    if (void 0 === i) {
      if (ni(n, t)) return;
      e.uniformMatrix2fv(this.addr, !1, t), ii(n, t);
    } else {
      if (ni(n, i)) return;
      ei.set(i), e.uniformMatrix2fv(this.addr, !1, ei), ii(n, i);
    }
  }
  function hi(e, t) {
    const n = this.cache,
      i = t.elements;
    if (void 0 === i) {
      if (ni(n, t)) return;
      e.uniformMatrix3fv(this.addr, !1, t), ii(n, t);
    } else {
      if (ni(n, i)) return;
      $n.set(i), e.uniformMatrix3fv(this.addr, !1, $n), ii(n, i);
    }
  }
  function ui(e, t) {
    const n = this.cache,
      i = t.elements;
    if (void 0 === i) {
      if (ni(n, t)) return;
      e.uniformMatrix4fv(this.addr, !1, t), ii(n, t);
    } else {
      if (ni(n, i)) return;
      Qn.set(i), e.uniformMatrix4fv(this.addr, !1, Qn), ii(n, i);
    }
  }
  function di(e, t, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
      n.safeSetTexture2D(t || Xn, r);
  }
  function pi(e, t, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(t || qn, r);
  }
  function fi(e, t, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(t || Yn, r);
  }
  function mi(e, t, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
      n.safeSetTextureCube(t || Zn, r);
  }
  function gi(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
  }
  function vi(e, t) {
    const n = this.cache;
    ni(n, t) || (e.uniform2iv(this.addr, t), ii(n, t));
  }
  function yi(e, t) {
    const n = this.cache;
    ni(n, t) || (e.uniform3iv(this.addr, t), ii(n, t));
  }
  function xi(e, t) {
    const n = this.cache;
    ni(n, t) || (e.uniform4iv(this.addr, t), ii(n, t));
  }
  function _i(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
  }
  function bi(e, t) {
    e.uniform1fv(this.addr, t);
  }
  function wi(e, t) {
    e.uniform1iv(this.addr, t);
  }
  function Mi(e, t) {
    e.uniform2iv(this.addr, t);
  }
  function Si(e, t) {
    e.uniform3iv(this.addr, t);
  }
  function Ei(e, t) {
    e.uniform4iv(this.addr, t);
  }
  function Ti(e, t) {
    const n = ti(t, this.size, 2);
    e.uniform2fv(this.addr, n);
  }
  function Ai(e, t) {
    const n = ti(t, this.size, 3);
    e.uniform3fv(this.addr, n);
  }
  function Li(e, t) {
    const n = ti(t, this.size, 4);
    e.uniform4fv(this.addr, n);
  }
  function Ri(e, t) {
    const n = ti(t, this.size, 4);
    e.uniformMatrix2fv(this.addr, !1, n);
  }
  function Ci(e, t) {
    const n = ti(t, this.size, 9);
    e.uniformMatrix3fv(this.addr, !1, n);
  }
  function Pi(e, t) {
    const n = ti(t, this.size, 16);
    e.uniformMatrix4fv(this.addr, !1, n);
  }
  function Oi(e, t, n) {
    const i = t.length,
      r = ri(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Xn, r[e]);
  }
  function Ii(e, t, n) {
    const i = t.length,
      r = ri(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Zn, r[e]);
  }
  function Ni(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return oi;
          case 35664:
            return si;
          case 35665:
            return ai;
          case 35666:
            return ci;
          case 35674:
            return li;
          case 35675:
            return hi;
          case 35676:
            return ui;
          case 5124:
          case 35670:
            return gi;
          case 35667:
          case 35671:
            return vi;
          case 35668:
          case 35672:
            return yi;
          case 35669:
          case 35673:
            return xi;
          case 5125:
            return _i;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return di;
          case 35679:
          case 36299:
          case 36307:
            return fi;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return mi;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return pi;
        }
      })(t.type));
  }
  function Di(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return bi;
          case 35664:
            return Ti;
          case 35665:
            return Ai;
          case 35666:
            return Li;
          case 35674:
            return Ri;
          case 35675:
            return Ci;
          case 35676:
            return Pi;
          case 5124:
          case 35670:
            return wi;
          case 35667:
          case 35671:
            return Mi;
          case 35668:
          case 35672:
            return Si;
          case 35669:
          case 35673:
            return Ei;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Oi;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ii;
        }
      })(t.type));
  }
  function Fi(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  (Di.prototype.updateCache = function (e) {
    const t = this.cache;
    e instanceof Float32Array &&
      t.length !== e.length &&
      (this.cache = new Float32Array(e.length)),
      ii(t, e);
  }),
    (Fi.prototype.setValue = function (e, t, n) {
      const i = this.seq;
      for (let r = 0, o = i.length; r !== o; ++r) {
        const o = i[r];
        o.setValue(e, t[o.id], n);
      }
    });
  const Ui = /(\w+)(\])?(\[|\.)?/g;
  function ki(e, t) {
    e.seq.push(t), (e.map[t.id] = t);
  }
  function Bi(e, t, n) {
    const i = e.name,
      r = i.length;
    for (Ui.lastIndex = 0; ; ) {
      const o = Ui.exec(i),
        s = Ui.lastIndex;
      let a = o[1];
      const c = "]" === o[2],
        l = o[3];
      if ((c && (a |= 0), void 0 === l || ("[" === l && s + 2 === r))) {
        ki(n, void 0 === l ? new Ni(a, e, t) : new Di(a, e, t));
        break;
      }
      {
        let e = n.map[a];
        void 0 === e && ((e = new Fi(a)), ki(n, e)), (n = e);
      }
    }
  }
  function zi(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, 35718);
    for (let i = 0; i < n; ++i) {
      const n = e.getActiveUniform(t, i);
      Bi(n, e.getUniformLocation(t, n.name), this);
    }
  }
  function Hi(e, t, n) {
    const i = e.createShader(t);
    return e.shaderSource(i, n), e.compileShader(i), i;
  }
  (zi.prototype.setValue = function (e, t, n, i) {
    const r = this.map[t];
    void 0 !== r && r.setValue(e, n, i);
  }),
    (zi.prototype.setOptional = function (e, t, n) {
      const i = t[n];
      void 0 !== i && this.setValue(e, n, i);
    }),
    (zi.upload = function (e, t, n, i) {
      for (let r = 0, o = t.length; r !== o; ++r) {
        const o = t[r],
          s = n[o.id];
        !1 !== s.needsUpdate && o.setValue(e, s.value, i);
      }
    }),
    (zi.seqWithValue = function (e, t) {
      const n = [];
      for (let i = 0, r = e.length; i !== r; ++i) {
        const r = e[i];
        r.id in t && n.push(r);
      }
      return n;
    });
  let Gi = 0;
  function Vi(e) {
    switch (e) {
      case S:
        return ["Linear", "( value )"];
      case E:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        return (
          console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
          ["Linear", "( value )"]
        );
    }
  }
  function ji(e, t, n) {
    const i = e.getShaderParameter(t, 35713),
      r = e.getShaderInfoLog(t).trim();
    return i && "" === r
      ? ""
      : "THREE.WebGLShader: gl.getShaderInfoLog() " +
          n +
          "\n" +
          r +
          (function (e) {
            const t = e.split("\n");
            for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
            return t.join("\n");
          })(e.getShaderSource(t));
  }
  function Wi(e, t) {
    const n = Vi(t);
    return (
      "vec4 " +
      e +
      "( vec4 value ) { return " +
      n[0] +
      "ToLinear" +
      n[1] +
      "; }"
    );
  }
  function Xi(e, t) {
    const n = Vi(t);
    return (
      "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    );
  }
  function qi(e, t) {
    let n;
    switch (t) {
      case 1:
        n = "Linear";
        break;
      case 2:
        n = "Reinhard";
        break;
      case 3:
        n = "OptimizedCineon";
        break;
      case 4:
        n = "ACESFilmic";
        break;
      case 5:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
          (n = "Linear");
    }
    return (
      "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    );
  }
  function Yi(e) {
    return "" !== e;
  }
  function Zi(e, t) {
    return e
      .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
  }
  function Ji(e, t) {
    return e
      .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        t.numClippingPlanes - t.numClipIntersection
      );
  }
  const Ki = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Qi(e) {
    return e.replace(Ki, $i);
  }
  function $i(e, t) {
    const n = An[t];
    if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
    return Qi(n);
  }
  const er =
      /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    tr =
      /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function nr(e) {
    return e.replace(tr, rr).replace(er, ir);
  }
  function ir(e, t, n, i) {
    return (
      console.warn(
        "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
      ),
      rr(0, t, n, i)
    );
  }
  function rr(e, t, n, i) {
    let r = "";
    for (let e = parseInt(t); e < parseInt(n); e++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, e);
    return r;
  }
  function or(e) {
    let t =
      "precision " +
      e.precision +
      " float;\nprecision " +
      e.precision +
      " int;";
    return (
      "highp" === e.precision
        ? (t += "\n#define HIGH_PRECISION")
        : "mediump" === e.precision
        ? (t += "\n#define MEDIUM_PRECISION")
        : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
      t
    );
  }
  function sr(e, t, n, i) {
    const r = e.getContext(),
      o = n.defines;
    let s = n.vertexShader,
      a = n.fragmentShader;
    const c = (function (e) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return (
          1 === e.shadowMapType
            ? (t = "SHADOWMAP_TYPE_PCF")
            : 2 === e.shadowMapType
            ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
            : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
          t
        );
      })(n),
      l = (function (e) {
        let t = "ENVMAP_TYPE_CUBE";
        if (e.envMap)
          switch (e.envMapMode) {
            case 301:
            case 302:
              t = "ENVMAP_TYPE_CUBE";
              break;
            case 306:
            case 307:
              t = "ENVMAP_TYPE_CUBE_UV";
          }
        return t;
      })(n),
      h = (function (e) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (e.envMap)
          switch (e.envMapMode) {
            case 302:
            case 307:
              t = "ENVMAP_MODE_REFRACTION";
          }
        return t;
      })(n),
      u = (function (e) {
        let t = "ENVMAP_BLENDING_NONE";
        if (e.envMap)
          switch (e.combine) {
            case 0:
              t = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case 1:
              t = "ENVMAP_BLENDING_MIX";
              break;
            case 2:
              t = "ENVMAP_BLENDING_ADD";
          }
        return t;
      })(n),
      d = e.gammaFactor > 0 ? e.gammaFactor : 1,
      p = n.isWebGL2
        ? ""
        : (function (e) {
            return [
              e.extensionDerivatives ||
              e.envMapCubeUV ||
              e.bumpMap ||
              e.tangentSpaceNormalMap ||
              e.clearcoatNormalMap ||
              e.flatShading ||
              "physical" === e.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
              e.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (e.extensionShaderTextureLOD || e.envMap) &&
              e.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter(Yi)
              .join("\n");
          })(n),
      f = (function (e) {
        const t = [];
        for (const n in e) {
          const i = e[n];
          !1 !== i && t.push("#define " + n + " " + i);
        }
        return t.join("\n");
      })(o),
      m = r.createProgram();
    let g,
      v,
      y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial
      ? ((g = [f].filter(Yi).join("\n")),
        g.length > 0 && (g += "\n"),
        (v = [p, f].filter(Yi).join("\n")),
        v.length > 0 && (v += "\n"))
      : ((g = [
          or(n),
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.instancing ? "#define USE_INSTANCING" : "",
          n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
          "#define GAMMA_FACTOR " + d,
          "#define MAX_BONES " + n.maxBones,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + h : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.displacementMap && n.supportsVertexTextures
            ? "#define USE_DISPLACEMENTMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.useVertexTexture ? "#define BONE_TEXTURE" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && !1 === n.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + c : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#ifdef USE_COLOR",
          "\tattribute vec3 color;",
          "#endif",
          "#ifdef USE_MORPHTARGETS",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(Yi)
          .join("\n")),
        (v = [
          p,
          or(n),
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.alphaTest
            ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0")
            : "",
          "#define GAMMA_FACTOR " + d,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + l : "",
          n.envMap ? "#define " + h : "",
          n.envMap ? "#define " + u : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMap && n.objectSpaceNormalMap
            ? "#define OBJECTSPACE_NORMALMAP"
            : "",
          n.normalMap && n.tangentSpaceNormalMap
            ? "#define TANGENTSPACE_NORMALMAP"
            : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.vertexTangents ? "#define USE_TANGENT" : "",
          n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
          n.vertexUvs ? "#define USE_UV" : "",
          n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + c : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          (n.extensionShaderTextureLOD || n.envMap) &&
          n.rendererExtensionShaderTextureLod
            ? "#define TEXTURE_LOD_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
          0 !== n.toneMapping ? An.tonemapping_pars_fragment : "",
          0 !== n.toneMapping ? qi("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          An.encodings_pars_fragment,
          n.map ? Wi("mapTexelToLinear", n.mapEncoding) : "",
          n.matcap ? Wi("matcapTexelToLinear", n.matcapEncoding) : "",
          n.envMap ? Wi("envMapTexelToLinear", n.envMapEncoding) : "",
          n.emissiveMap
            ? Wi("emissiveMapTexelToLinear", n.emissiveMapEncoding)
            : "",
          n.lightMap ? Wi("lightMapTexelToLinear", n.lightMapEncoding) : "",
          Xi("linearToOutputTexel", n.outputEncoding),
          n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          "\n",
        ]
          .filter(Yi)
          .join("\n"))),
      (s = Qi(s)),
      (s = Zi(s, n)),
      (s = Ji(s, n)),
      (a = Qi(a)),
      (a = Zi(a, n)),
      (a = Ji(a, n)),
      (s = nr(s)),
      (a = nr(a)),
      n.isWebGL2 &&
        !0 !== n.isRawShaderMaterial &&
        ((y = "#version 300 es\n"),
        (g =
          [
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          g),
        (v =
          [
            "#define varying in",
            n.glslVersion === R ? "" : "out highp vec4 pc_fragColor;",
            n.glslVersion === R ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          v));
    const x = y + v + a,
      _ = Hi(r, 35633, y + g + s),
      b = Hi(r, 35632, x);
    if (
      (r.attachShader(m, _),
      r.attachShader(m, b),
      void 0 !== n.index0AttributeName
        ? r.bindAttribLocation(m, 0, n.index0AttributeName)
        : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
      r.linkProgram(m),
      e.debug.checkShaderErrors)
    ) {
      const e = r.getProgramInfoLog(m).trim(),
        t = r.getShaderInfoLog(_).trim(),
        n = r.getShaderInfoLog(b).trim();
      let i = !0,
        o = !0;
      if (!1 === r.getProgramParameter(m, 35714)) {
        i = !1;
        const t = ji(r, _, "vertex"),
          n = ji(r, b, "fragment");
        console.error(
          "THREE.WebGLProgram: shader error: ",
          r.getError(),
          "35715",
          r.getProgramParameter(m, 35715),
          "gl.getProgramInfoLog",
          e,
          t,
          n
        );
      } else
        "" !== e
          ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e)
          : ("" !== t && "" !== n) || (o = !1);
      o &&
        (this.diagnostics = {
          runnable: i,
          programLog: e,
          vertexShader: { log: t, prefix: g },
          fragmentShader: { log: n, prefix: v },
        });
    }
    let w, M;
    return (
      r.deleteShader(_),
      r.deleteShader(b),
      (this.getUniforms = function () {
        return void 0 === w && (w = new zi(r, m)), w;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === M &&
            (M = (function (e, t) {
              const n = {},
                i = e.getProgramParameter(t, 35721);
              for (let r = 0; r < i; r++) {
                const i = e.getActiveAttrib(t, r).name;
                n[i] = e.getAttribLocation(t, i);
              }
              return n;
            })(r, m)),
          M
        );
      }),
      (this.destroy = function () {
        i.releaseStatesOfProgram(this),
          r.deleteProgram(m),
          (this.program = void 0);
      }),
      (this.name = n.shaderName),
      (this.id = Gi++),
      (this.cacheKey = t),
      (this.usedTimes = 1),
      (this.program = m),
      (this.vertexShader = _),
      (this.fragmentShader = b),
      this
    );
  }
  function ar(e, t, n, i, r, o) {
    const s = [],
      a = i.isWebGL2,
      c = i.logarithmicDepthBuffer,
      l = i.floatVertexTextures,
      h = i.maxVertexUniforms,
      u = i.vertexTextures;
    let d = i.precision;
    const p = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite",
      },
      f = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        "physicallyCorrectLights",
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "sheen",
        "transmissionMap",
      ];
    function m(e) {
      let t;
      return (
        e && e.isTexture
          ? (t = e.encoding)
          : e && e.isWebGLRenderTarget
          ? (console.warn(
              "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
            ),
            (t = e.texture.encoding))
          : (t = S),
        t
      );
    }
    return {
      getParameters: function (r, s, f, g, v) {
        const y = g.fog,
          x = r.isMeshStandardMaterial ? g.environment : null,
          _ = t.get(r.envMap || x),
          b = p[r.type],
          w = v.isSkinnedMesh
            ? (function (e) {
                const t = e.skeleton.bones;
                if (l) return 1024;
                {
                  const e = h,
                    n = Math.floor((e - 20) / 4),
                    i = Math.min(n, t.length);
                  return i < t.length
                    ? (console.warn(
                        "THREE.WebGLRenderer: Skeleton has " +
                          t.length +
                          " bones. This GPU supports " +
                          i +
                          "."
                      ),
                      0)
                    : i;
                }
              })(v)
            : 0;
        let M, S;
        if (
          (null !== r.precision &&
            ((d = i.getMaxPrecision(r.precision)),
            d !== r.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                r.precision,
                "not supported, using",
                d,
                "instead."
              )),
          b)
        ) {
          const e = Rn[b];
          (M = e.vertexShader), (S = e.fragmentShader);
        } else (M = r.vertexShader), (S = r.fragmentShader);
        const E = e.getRenderTarget();
        return {
          isWebGL2: a,
          shaderID: b,
          shaderName: r.type,
          vertexShader: M,
          fragmentShader: S,
          defines: r.defines,
          isRawShaderMaterial: !0 === r.isRawShaderMaterial,
          glslVersion: r.glslVersion,
          precision: d,
          instancing: !0 === v.isInstancedMesh,
          instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
          supportsVertexTextures: u,
          outputEncoding: null !== E ? m(E.texture) : e.outputEncoding,
          map: !!r.map,
          mapEncoding: m(r.map),
          matcap: !!r.matcap,
          matcapEncoding: m(r.matcap),
          envMap: !!_,
          envMapMode: _ && _.mapping,
          envMapEncoding: m(_),
          envMapCubeUV: !!_ && (306 === _.mapping || 307 === _.mapping),
          lightMap: !!r.lightMap,
          lightMapEncoding: m(r.lightMap),
          aoMap: !!r.aoMap,
          emissiveMap: !!r.emissiveMap,
          emissiveMapEncoding: m(r.emissiveMap),
          bumpMap: !!r.bumpMap,
          normalMap: !!r.normalMap,
          objectSpaceNormalMap: 1 === r.normalMapType,
          tangentSpaceNormalMap: 0 === r.normalMapType,
          clearcoatMap: !!r.clearcoatMap,
          clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
          clearcoatNormalMap: !!r.clearcoatNormalMap,
          displacementMap: !!r.displacementMap,
          roughnessMap: !!r.roughnessMap,
          metalnessMap: !!r.metalnessMap,
          specularMap: !!r.specularMap,
          alphaMap: !!r.alphaMap,
          gradientMap: !!r.gradientMap,
          sheen: !!r.sheen,
          transmissionMap: !!r.transmissionMap,
          combine: r.combine,
          vertexTangents: r.normalMap && r.vertexTangents,
          vertexColors: r.vertexColors,
          vertexUvs: !!(
            r.map ||
            r.bumpMap ||
            r.normalMap ||
            r.specularMap ||
            r.alphaMap ||
            r.emissiveMap ||
            r.roughnessMap ||
            r.metalnessMap ||
            r.clearcoatMap ||
            r.clearcoatRoughnessMap ||
            r.clearcoatNormalMap ||
            r.displacementMap ||
            r.transmissionMap
          ),
          uvsVertexOnly: !(
            r.map ||
            r.bumpMap ||
            r.normalMap ||
            r.specularMap ||
            r.alphaMap ||
            r.emissiveMap ||
            r.roughnessMap ||
            r.metalnessMap ||
            r.clearcoatNormalMap ||
            r.transmissionMap ||
            !r.displacementMap
          ),
          fog: !!y,
          useFog: r.fog,
          fogExp2: y && y.isFogExp2,
          flatShading: r.flatShading,
          sizeAttenuation: r.sizeAttenuation,
          logarithmicDepthBuffer: c,
          skinning: r.skinning && w > 0,
          maxBones: w,
          useVertexTexture: l,
          morphTargets: r.morphTargets,
          morphNormals: r.morphNormals,
          maxMorphTargets: e.maxMorphTargets,
          maxMorphNormals: e.maxMorphNormals,
          numDirLights: s.directional.length,
          numPointLights: s.point.length,
          numSpotLights: s.spot.length,
          numRectAreaLights: s.rectArea.length,
          numHemiLights: s.hemi.length,
          numDirLightShadows: s.directionalShadowMap.length,
          numPointLightShadows: s.pointShadowMap.length,
          numSpotLightShadows: s.spotShadowMap.length,
          numClippingPlanes: o.numPlanes,
          numClipIntersection: o.numIntersection,
          dithering: r.dithering,
          shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
          shadowMapType: e.shadowMap.type,
          toneMapping: r.toneMapped ? e.toneMapping : 0,
          physicallyCorrectLights: e.physicallyCorrectLights,
          premultipliedAlpha: r.premultipliedAlpha,
          alphaTest: r.alphaTest,
          doubleSided: 2 === r.side,
          flipSided: 1 === r.side,
          depthPacking: void 0 !== r.depthPacking && r.depthPacking,
          index0AttributeName: r.index0AttributeName,
          extensionDerivatives: r.extensions && r.extensions.derivatives,
          extensionFragDepth: r.extensions && r.extensions.fragDepth,
          extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
          extensionShaderTextureLOD:
            r.extensions && r.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod:
            a || n.has("EXT_shader_texture_lod"),
          customProgramCacheKey: r.customProgramCacheKey(),
        };
      },
      getProgramCacheKey: function (t) {
        const n = [];
        if (
          (t.shaderID
            ? n.push(t.shaderID)
            : (n.push(t.fragmentShader), n.push(t.vertexShader)),
          void 0 !== t.defines)
        )
          for (const e in t.defines) n.push(e), n.push(t.defines[e]);
        if (!1 === t.isRawShaderMaterial) {
          for (let e = 0; e < f.length; e++) n.push(t[f[e]]);
          n.push(e.outputEncoding), n.push(e.gammaFactor);
        }
        return n.push(t.customProgramCacheKey), n.join();
      },
      getUniforms: function (e) {
        const t = p[e.type];
        let n;
        if (t) {
          const e = Rn[t];
          n = dn.clone(e.uniforms);
        } else n = e.uniforms;
        return n;
      },
      acquireProgram: function (t, n) {
        let i;
        for (let e = 0, t = s.length; e < t; e++) {
          const t = s[e];
          if (t.cacheKey === n) {
            (i = t), ++i.usedTimes;
            break;
          }
        }
        return void 0 === i && ((i = new sr(e, n, t, r)), s.push(i)), i;
      },
      releaseProgram: function (e) {
        if (0 == --e.usedTimes) {
          const t = s.indexOf(e);
          (s[t] = s[s.length - 1]), s.pop(), e.destroy();
        }
      },
      programs: s,
    };
  }
  function cr() {
    let e = new WeakMap();
    return {
      get: function (t) {
        let n = e.get(t);
        return void 0 === n && ((n = {}), e.set(t, n)), n;
      },
      remove: function (t) {
        e.delete(t);
      },
      update: function (t, n, i) {
        e.get(t)[n] = i;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  function lr(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.program !== t.program
      ? e.program.id - t.program.id
      : e.material.id !== t.material.id
      ? e.material.id - t.material.id
      : e.z !== t.z
      ? e.z - t.z
      : e.id - t.id;
  }
  function hr(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.z !== t.z
      ? t.z - e.z
      : e.id - t.id;
  }
  function ur(e) {
    const t = [];
    let n = 0;
    const i = [],
      r = [],
      o = { id: -1 };
    function s(i, r, s, a, c, l) {
      let h = t[n];
      const u = e.get(s);
      return (
        void 0 === h
          ? ((h = {
              id: i.id,
              object: i,
              geometry: r,
              material: s,
              program: u.program || o,
              groupOrder: a,
              renderOrder: i.renderOrder,
              z: c,
              group: l,
            }),
            (t[n] = h))
          : ((h.id = i.id),
            (h.object = i),
            (h.geometry = r),
            (h.material = s),
            (h.program = u.program || o),
            (h.groupOrder = a),
            (h.renderOrder = i.renderOrder),
            (h.z = c),
            (h.group = l)),
        n++,
        h
      );
    }
    return {
      opaque: i,
      transparent: r,
      init: function () {
        (n = 0), (i.length = 0), (r.length = 0);
      },
      push: function (e, t, n, o, a, c) {
        const l = s(e, t, n, o, a, c);
        (!0 === n.transparent ? r : i).push(l);
      },
      unshift: function (e, t, n, o, a, c) {
        const l = s(e, t, n, o, a, c);
        (!0 === n.transparent ? r : i).unshift(l);
      },
      finish: function () {
        for (let e = n, i = t.length; e < i; e++) {
          const n = t[e];
          if (null === n.id) break;
          (n.id = null),
            (n.object = null),
            (n.geometry = null),
            (n.material = null),
            (n.program = null),
            (n.group = null);
        }
      },
      sort: function (e, t) {
        i.length > 1 && i.sort(e || lr), r.length > 1 && r.sort(t || hr);
      },
    };
  }
  function dr(e) {
    let t = new WeakMap();
    return {
      get: function (n, i) {
        const r = t.get(n);
        let o;
        return (
          void 0 === r
            ? ((o = new ur(e)), t.set(n, new WeakMap()), t.get(n).set(i, o))
            : ((o = r.get(i)), void 0 === o && ((o = new ur(e)), r.set(i, o))),
          o
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function pr() {
    const e = {};
    return {
      get: function (t) {
        if (void 0 !== e[t.id]) return e[t.id];
        let n;
        switch (t.type) {
          case "DirectionalLight":
            n = { direction: new W(), color: new dt() };
            break;
          case "SpotLight":
            n = {
              position: new W(),
              direction: new W(),
              color: new dt(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            n = { position: new W(), color: new dt(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            n = {
              direction: new W(),
              skyColor: new dt(),
              groundColor: new dt(),
            };
            break;
          case "RectAreaLight":
            n = {
              color: new dt(),
              position: new W(),
              halfWidth: new W(),
              halfHeight: new W(),
            };
        }
        return (e[t.id] = n), n;
      },
    };
  }
  let fr = 0;
  function mr(e, t) {
    return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
  }
  function gr(e, t) {
    const n = new pr(),
      i = (function () {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new N(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new N(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (e[t.id] = n), n;
          },
        };
      })(),
      r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
      };
    for (let e = 0; e < 9; e++) r.probe.push(new W());
    const o = new W(),
      s = new xe(),
      a = new xe();
    return {
      setup: function (o) {
        let s = 0,
          a = 0,
          c = 0;
        for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
        let l = 0,
          h = 0,
          u = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0;
        o.sort(mr);
        for (let e = 0, t = o.length; e < t; e++) {
          const t = o[e],
            v = t.color,
            y = t.intensity,
            x = t.distance,
            _ = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
          if (t.isAmbientLight) (s += v.r * y), (a += v.g * y), (c += v.b * y);
          else if (t.isLightProbe)
            for (let e = 0; e < 9; e++)
              r.probe[e].addScaledVector(t.sh.coefficients[e], y);
          else if (t.isDirectionalLight) {
            const e = n.get(t);
            if (
              (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow)
            ) {
              const e = t.shadow,
                n = i.get(t);
              (n.shadowBias = e.bias),
                (n.shadowNormalBias = e.normalBias),
                (n.shadowRadius = e.radius),
                (n.shadowMapSize = e.mapSize),
                (r.directionalShadow[l] = n),
                (r.directionalShadowMap[l] = _),
                (r.directionalShadowMatrix[l] = t.shadow.matrix),
                f++;
            }
            (r.directional[l] = e), l++;
          } else if (t.isSpotLight) {
            const e = n.get(t);
            if (
              (e.position.setFromMatrixPosition(t.matrixWorld),
              e.color.copy(v).multiplyScalar(y),
              (e.distance = x),
              (e.coneCos = Math.cos(t.angle)),
              (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
              (e.decay = t.decay),
              t.castShadow)
            ) {
              const e = t.shadow,
                n = i.get(t);
              (n.shadowBias = e.bias),
                (n.shadowNormalBias = e.normalBias),
                (n.shadowRadius = e.radius),
                (n.shadowMapSize = e.mapSize),
                (r.spotShadow[u] = n),
                (r.spotShadowMap[u] = _),
                (r.spotShadowMatrix[u] = t.shadow.matrix),
                g++;
            }
            (r.spot[u] = e), u++;
          } else if (t.isRectAreaLight) {
            const e = n.get(t);
            e.color.copy(v).multiplyScalar(y),
              e.halfWidth.set(0.5 * t.width, 0, 0),
              e.halfHeight.set(0, 0.5 * t.height, 0),
              (r.rectArea[d] = e),
              d++;
          } else if (t.isPointLight) {
            const e = n.get(t);
            if (
              (e.color.copy(t.color).multiplyScalar(t.intensity),
              (e.distance = t.distance),
              (e.decay = t.decay),
              t.castShadow)
            ) {
              const e = t.shadow,
                n = i.get(t);
              (n.shadowBias = e.bias),
                (n.shadowNormalBias = e.normalBias),
                (n.shadowRadius = e.radius),
                (n.shadowMapSize = e.mapSize),
                (n.shadowCameraNear = e.camera.near),
                (n.shadowCameraFar = e.camera.far),
                (r.pointShadow[h] = n),
                (r.pointShadowMap[h] = _),
                (r.pointShadowMatrix[h] = t.shadow.matrix),
                m++;
            }
            (r.point[h] = e), h++;
          } else if (t.isHemisphereLight) {
            const e = n.get(t);
            e.skyColor.copy(t.color).multiplyScalar(y),
              e.groundColor.copy(t.groundColor).multiplyScalar(y),
              (r.hemi[p] = e),
              p++;
          }
        }
        d > 0 &&
          (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
            ? ((r.rectAreaLTC1 = Ln.LTC_FLOAT_1),
              (r.rectAreaLTC2 = Ln.LTC_FLOAT_2))
            : !0 === e.has("OES_texture_half_float_linear")
            ? ((r.rectAreaLTC1 = Ln.LTC_HALF_1),
              (r.rectAreaLTC2 = Ln.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
              )),
          (r.ambient[0] = s),
          (r.ambient[1] = a),
          (r.ambient[2] = c);
        const v = r.hash;
        (v.directionalLength === l &&
          v.pointLength === h &&
          v.spotLength === u &&
          v.rectAreaLength === d &&
          v.hemiLength === p &&
          v.numDirectionalShadows === f &&
          v.numPointShadows === m &&
          v.numSpotShadows === g) ||
          ((r.directional.length = l),
          (r.spot.length = u),
          (r.rectArea.length = d),
          (r.point.length = h),
          (r.hemi.length = p),
          (r.directionalShadow.length = f),
          (r.directionalShadowMap.length = f),
          (r.pointShadow.length = m),
          (r.pointShadowMap.length = m),
          (r.spotShadow.length = g),
          (r.spotShadowMap.length = g),
          (r.directionalShadowMatrix.length = f),
          (r.pointShadowMatrix.length = m),
          (r.spotShadowMatrix.length = g),
          (v.directionalLength = l),
          (v.pointLength = h),
          (v.spotLength = u),
          (v.rectAreaLength = d),
          (v.hemiLength = p),
          (v.numDirectionalShadows = f),
          (v.numPointShadows = m),
          (v.numSpotShadows = g),
          (r.version = fr++));
      },
      setupView: function (e, t) {
        let n = 0,
          i = 0,
          c = 0,
          l = 0,
          h = 0;
        const u = t.matrixWorldInverse;
        for (let t = 0, d = e.length; t < d; t++) {
          const d = e[t];
          if (d.isDirectionalLight) {
            const e = r.directional[n];
            e.direction.setFromMatrixPosition(d.matrixWorld),
              o.setFromMatrixPosition(d.target.matrixWorld),
              e.direction.sub(o),
              e.direction.transformDirection(u),
              n++;
          } else if (d.isSpotLight) {
            const e = r.spot[c];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(u),
              e.direction.setFromMatrixPosition(d.matrixWorld),
              o.setFromMatrixPosition(d.target.matrixWorld),
              e.direction.sub(o),
              e.direction.transformDirection(u),
              c++;
          } else if (d.isRectAreaLight) {
            const e = r.rectArea[l];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(u),
              a.identity(),
              s.copy(d.matrixWorld),
              s.premultiply(u),
              a.extractRotation(s),
              e.halfWidth.set(0.5 * d.width, 0, 0),
              e.halfHeight.set(0, 0.5 * d.height, 0),
              e.halfWidth.applyMatrix4(a),
              e.halfHeight.applyMatrix4(a),
              l++;
          } else if (d.isPointLight) {
            const e = r.point[i];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(u),
              i++;
          } else if (d.isHemisphereLight) {
            const e = r.hemi[h];
            e.direction.setFromMatrixPosition(d.matrixWorld),
              e.direction.transformDirection(u),
              e.direction.normalize(),
              h++;
          }
        }
      },
      state: r,
    };
  }
  function vr(e, t) {
    const n = new gr(e, t),
      i = [],
      r = [];
    return {
      init: function () {
        (i.length = 0), (r.length = 0);
      },
      state: { lightsArray: i, shadowsArray: r, lights: n },
      setupLights: function () {
        n.setup(i);
      },
      setupLightsView: function (e) {
        n.setupView(i, e);
      },
      pushLight: function (e) {
        i.push(e);
      },
      pushShadow: function (e) {
        r.push(e);
      },
    };
  }
  function yr(e, t) {
    let n = new WeakMap();
    return {
      get: function (i, r = 0) {
        let o;
        return (
          !1 === n.has(i)
            ? ((o = new vr(e, t)), n.set(i, []), n.get(i).push(o))
            : r >= n.get(i).length
            ? ((o = new vr(e, t)), n.get(i).push(o))
            : (o = n.get(i)[r]),
          o
        );
      },
      dispose: function () {
        n = new WeakMap();
      },
    };
  }
  function xr(e) {
    mt.call(this),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = 3200),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(e);
  }
  function _r(e) {
    mt.call(this),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new W()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(e);
  }
  function br(e, t, n) {
    let i = new Mn();
    const o = new N(),
      s = new N(),
      c = new H(),
      l = [],
      h = [],
      u = {},
      d = { 0: 1, 1: 0, 2: 2 },
      p = new pn({
        defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new N() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      f = p.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const g = new Ht();
    g.setAttribute(
      "position",
      new xt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const v = new sn(g, p),
      y = this;
    function x(n, i) {
      const r = t.update(v);
      (p.uniforms.shadow_pass.value = n.map.texture),
        (p.uniforms.resolution.value = n.mapSize),
        (p.uniforms.radius.value = n.radius),
        e.setRenderTarget(n.mapPass),
        e.clear(),
        e.renderBufferDirect(i, null, r, p, v, null),
        (f.uniforms.shadow_pass.value = n.mapPass.texture),
        (f.uniforms.resolution.value = n.mapSize),
        (f.uniforms.radius.value = n.radius),
        e.setRenderTarget(n.map),
        e.clear(),
        e.renderBufferDirect(i, null, r, f, v, null);
    }
    function _(e, t, n) {
      const i = (e << 0) | (t << 1) | (n << 2);
      let r = l[i];
      return (
        void 0 === r &&
          ((r = new xr({ depthPacking: 3201, morphTargets: e, skinning: t })),
          (l[i] = r)),
        r
      );
    }
    function b(e, t, n) {
      const i = (e << 0) | (t << 1) | (n << 2);
      let r = h[i];
      return (
        void 0 === r &&
          ((r = new _r({ morphTargets: e, skinning: t })), (h[i] = r)),
        r
      );
    }
    function w(t, n, i, r, o, s, a) {
      let c = null,
        l = _,
        h = t.customDepthMaterial;
      if (
        (!0 === r.isPointLight && ((l = b), (h = t.customDistanceMaterial)),
        void 0 === h)
      ) {
        let e = !1;
        !0 === i.morphTargets &&
          (e =
            n.morphAttributes &&
            n.morphAttributes.position &&
            n.morphAttributes.position.length > 0);
        let r = !1;
        !0 === t.isSkinnedMesh &&
          (!0 === i.skinning
            ? (r = !0)
            : console.warn(
                "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                t
              )),
          (c = l(e, r, !0 === t.isInstancedMesh));
      } else c = h;
      if (
        e.localClippingEnabled &&
        !0 === i.clipShadows &&
        0 !== i.clippingPlanes.length
      ) {
        const e = c.uuid,
          t = i.uuid;
        let n = u[e];
        void 0 === n && ((n = {}), (u[e] = n));
        let r = n[t];
        void 0 === r && ((r = c.clone()), (n[t] = r)), (c = r);
      }
      return (
        (c.visible = i.visible),
        (c.wireframe = i.wireframe),
        (c.side =
          3 === a
            ? null !== i.shadowSide
              ? i.shadowSide
              : i.side
            : null !== i.shadowSide
            ? i.shadowSide
            : d[i.side]),
        (c.clipShadows = i.clipShadows),
        (c.clippingPlanes = i.clippingPlanes),
        (c.clipIntersection = i.clipIntersection),
        (c.wireframeLinewidth = i.wireframeLinewidth),
        (c.linewidth = i.linewidth),
        !0 === r.isPointLight &&
          !0 === c.isMeshDistanceMaterial &&
          (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
          (c.nearDistance = o),
          (c.farDistance = s)),
        c
      );
    }
    function M(n, r, o, s, a) {
      if (!1 === n.visible) return;
      if (
        n.layers.test(r.layers) &&
        (n.isMesh || n.isLine || n.isPoints) &&
        (n.castShadow || (n.receiveShadow && 3 === a)) &&
        (!n.frustumCulled || i.intersectsObject(n))
      ) {
        n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
        const i = t.update(n),
          r = n.material;
        if (Array.isArray(r)) {
          const t = i.groups;
          for (let c = 0, l = t.length; c < l; c++) {
            const l = t[c],
              h = r[l.materialIndex];
            if (h && h.visible) {
              const t = w(n, i, h, s, o.near, o.far, a);
              e.renderBufferDirect(o, null, i, t, n, l);
            }
          }
        } else if (r.visible) {
          const t = w(n, i, r, s, o.near, o.far, a);
          e.renderBufferDirect(o, null, i, t, n, null);
        }
      }
      const c = n.children;
      for (let e = 0, t = c.length; e < t; e++) M(c[e], r, o, s, a);
    }
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = 1),
      (this.render = function (t, l, h) {
        if (!1 === y.enabled) return;
        if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
        if (0 === t.length) return;
        const u = e.getRenderTarget(),
          d = e.getActiveCubeFace(),
          p = e.getActiveMipmapLevel(),
          f = e.state;
        f.setBlending(0),
          f.buffers.color.setClear(1, 1, 1, 1),
          f.buffers.depth.setTest(!0),
          f.setScissorTest(!1);
        for (let u = 0, d = t.length; u < d; u++) {
          const d = t[u],
            p = d.shadow;
          if (void 0 === p) {
            console.warn("THREE.WebGLShadowMap:", d, "has no shadow.");
            continue;
          }
          if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
          o.copy(p.mapSize);
          const g = p.getFrameExtents();
          if (
            (o.multiply(g),
            s.copy(p.mapSize),
            (o.x > n || o.y > n) &&
              (o.x > n &&
                ((s.x = Math.floor(n / g.x)),
                (o.x = s.x * g.x),
                (p.mapSize.x = s.x)),
              o.y > n &&
                ((s.y = Math.floor(n / g.y)),
                (o.y = s.y * g.y),
                (p.mapSize.y = s.y))),
            null === p.map && !p.isPointLightShadow && 3 === this.type)
          ) {
            const e = { minFilter: a, magFilter: a, format: m };
            (p.map = new G(o.x, o.y, e)),
              (p.map.texture.name = d.name + ".shadowMap"),
              (p.mapPass = new G(o.x, o.y, e)),
              p.camera.updateProjectionMatrix();
          }
          if (null === p.map) {
            const e = { minFilter: r, magFilter: r, format: m };
            (p.map = new G(o.x, o.y, e)),
              (p.map.texture.name = d.name + ".shadowMap"),
              p.camera.updateProjectionMatrix();
          }
          e.setRenderTarget(p.map), e.clear();
          const v = p.getViewportCount();
          for (let e = 0; e < v; e++) {
            const t = p.getViewport(e);
            c.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
              f.viewport(c),
              p.updateMatrices(d, e),
              (i = p.getFrustum()),
              M(l, h, p.camera, d, this.type);
          }
          p.isPointLightShadow || 3 !== this.type || x(p, h),
            (p.needsUpdate = !1);
        }
        (y.needsUpdate = !1), e.setRenderTarget(u, d, p);
      });
  }
  function wr(t, n, i) {
    const r = i.isWebGL2,
      o = new (function () {
        let e = !1;
        const n = new H();
        let i = null;
        const r = new H(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, o, s, a) {
            !0 === a && ((e *= s), (i *= s), (o *= s)),
              n.set(e, i, o, s),
              !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      s = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (e) {
            e ? N(2929) : D(2929);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              if (e)
                switch (e) {
                  case 0:
                    t.depthFunc(512);
                    break;
                  case 1:
                    t.depthFunc(519);
                    break;
                  case 2:
                    t.depthFunc(513);
                    break;
                  default:
                    t.depthFunc(515);
                    break;
                  case 4:
                    t.depthFunc(514);
                    break;
                  case 5:
                    t.depthFunc(518);
                    break;
                  case 6:
                    t.depthFunc(516);
                    break;
                  case 7:
                    t.depthFunc(517);
                }
              else t.depthFunc(515);
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      a = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null,
          o = null,
          s = null,
          a = null,
          c = null,
          l = null;
        return {
          setTest: function (t) {
            e || (t ? N(2960) : D(2960));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, s) {
            (i === e && r === n && o === s) ||
              (t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
          },
          setOp: function (e, n, i) {
            (s === e && a === n && c === i) ||
              (t.stencilOp(e, n, i), (s = e), (a = n), (c = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            l !== e && (t.clearStencil(e), (l = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (o = null),
              (s = null),
              (a = null),
              (c = null),
              (l = null);
          },
        };
      })();
    let c = {},
      l = null,
      h = null,
      u = null,
      d = null,
      p = null,
      f = null,
      m = null,
      g = null,
      v = null,
      y = !1,
      x = null,
      _ = null,
      b = null,
      w = null,
      M = null;
    const S = t.getParameter(35661);
    let E = !1,
      T = 0;
    const A = t.getParameter(7938);
    -1 !== A.indexOf("WebGL")
      ? ((T = parseFloat(/^WebGL (\d)/.exec(A)[1])), (E = T >= 1))
      : -1 !== A.indexOf("OpenGL ES") &&
        ((T = parseFloat(/^OpenGL ES (\d)/.exec(A)[1])), (E = T >= 2));
    let L = null,
      R = {};
    const C = new H(),
      P = new H();
    function O(e, n, i) {
      const r = new Uint8Array(4),
        o = t.createTexture();
      t.bindTexture(e, o),
        t.texParameteri(e, 10241, 9728),
        t.texParameteri(e, 10240, 9728);
      for (let e = 0; e < i; e++)
        t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
      return o;
    }
    const I = {};
    function N(e) {
      !0 !== c[e] && (t.enable(e), (c[e] = !0));
    }
    function D(e) {
      !1 !== c[e] && (t.disable(e), (c[e] = !1));
    }
    (I[3553] = O(3553, 3553, 1)),
      (I[34067] = O(34067, 34069, 6)),
      o.setClear(0, 0, 0, 1),
      s.setClear(1),
      a.setClear(0),
      N(2929),
      s.setFunc(3),
      B(!1),
      z(1),
      N(2884),
      k(0);
    const F = { [e]: 32774, 101: 32778, 102: 32779 };
    if (r) (F[103] = 32775), (F[104] = 32776);
    else {
      const e = n.get("EXT_blend_minmax");
      null !== e && ((F[103] = e.MIN_EXT), (F[104] = e.MAX_EXT));
    }
    const U = {
      200: 0,
      201: 1,
      202: 768,
      204: 770,
      210: 776,
      208: 774,
      206: 772,
      203: 769,
      205: 771,
      209: 775,
      207: 773,
    };
    function k(n, i, r, o, s, a, c, l) {
      if (0 !== n) {
        if ((h || (N(3042), (h = !0)), 5 === n))
          (s = s || i),
            (a = a || r),
            (c = c || o),
            (i === d && s === m) ||
              (t.blendEquationSeparate(F[i], F[s]), (d = i), (m = s)),
            (r === p && o === f && a === g && c === v) ||
              (t.blendFuncSeparate(U[r], U[o], U[a], U[c]),
              (p = r),
              (f = o),
              (g = a),
              (v = c)),
            (u = n),
            (y = null);
        else if (n !== u || l !== y) {
          if (
            ((d === e && m === e) || (t.blendEquation(32774), (d = e), (m = e)),
            l)
          )
            switch (n) {
              case 1:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(1, 1);
                break;
              case 3:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case 4:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", n);
            }
          else
            switch (n) {
              case 1:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t.blendFunc(770, 1);
                break;
              case 3:
                t.blendFunc(0, 769);
                break;
              case 4:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", n);
            }
          (p = null), (f = null), (g = null), (v = null), (u = n), (y = l);
        }
      } else h && (D(3042), (h = !1));
    }
    function B(e) {
      x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e));
    }
    function z(e) {
      0 !== e
        ? (N(2884),
          e !== _ &&
            (1 === e
              ? t.cullFace(1029)
              : 2 === e
              ? t.cullFace(1028)
              : t.cullFace(1032)))
        : D(2884),
        (_ = e);
    }
    function G(e, n, i) {
      e
        ? (N(32823),
          (w === n && M === i) || (t.polygonOffset(n, i), (w = n), (M = i)))
        : D(32823);
    }
    function V(e) {
      void 0 === e && (e = 33984 + S - 1),
        L !== e && (t.activeTexture(e), (L = e));
    }
    return {
      buffers: { color: o, depth: s, stencil: a },
      enable: N,
      disable: D,
      useProgram: function (e) {
        return l !== e && (t.useProgram(e), (l = e), !0);
      },
      setBlending: k,
      setMaterial: function (e, t) {
        2 === e.side ? D(2884) : N(2884);
        let n = 1 === e.side;
        t && (n = !n),
          B(n),
          1 === e.blending && !1 === e.transparent
            ? k(0)
            : k(
                e.blending,
                e.blendEquation,
                e.blendSrc,
                e.blendDst,
                e.blendEquationAlpha,
                e.blendSrcAlpha,
                e.blendDstAlpha,
                e.premultipliedAlpha
              ),
          s.setFunc(e.depthFunc),
          s.setTest(e.depthTest),
          s.setMask(e.depthWrite),
          o.setMask(e.colorWrite);
        const i = e.stencilWrite;
        a.setTest(i),
          i &&
            (a.setMask(e.stencilWriteMask),
            a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
          G(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
      },
      setFlipSided: B,
      setCullFace: z,
      setLineWidth: function (e) {
        e !== b && (E && t.lineWidth(e), (b = e));
      },
      setPolygonOffset: G,
      setScissorTest: function (e) {
        e ? N(3089) : D(3089);
      },
      activeTexture: V,
      bindTexture: function (e, n) {
        null === L && V();
        let i = R[L];
        void 0 === i && ((i = { type: void 0, texture: void 0 }), (R[L] = i)),
          (i.type === e && i.texture === n) ||
            (t.bindTexture(e, n || I[e]), (i.type = e), (i.texture = n));
      },
      unbindTexture: function () {
        const e = R[L];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      scissor: function (e) {
        !1 === C.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), C.copy(e));
      },
      viewport: function (e) {
        !1 === P.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), P.copy(e));
      },
      reset: function () {
        (c = {}),
          (L = null),
          (R = {}),
          (l = null),
          (h = null),
          (u = null),
          (d = null),
          (p = null),
          (f = null),
          (m = null),
          (g = null),
          (v = null),
          (y = !1),
          (x = null),
          (_ = null),
          (b = null),
          (w = null),
          (M = null),
          o.reset(),
          s.reset(),
          a.reset();
      },
    };
  }
  function Mr(e, y, x, _, b, w, M) {
    const S = b.isWebGL2,
      E = b.maxTextures,
      T = b.maxCubemapSize,
      A = b.maxTextureSize,
      L = b.maxSamples,
      R = new WeakMap();
    let C,
      P = !1;
    try {
      P =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (e) {}
    function O(e, t) {
      return P
        ? new OffscreenCanvas(e, t)
        : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function N(e, t, n, i) {
      let r = 1;
      if (
        ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)),
        r < 1 || !0 === t)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
        ) {
          const i = t ? I.floorPowerOfTwo : Math.floor,
            o = i(r * e.width),
            s = i(r * e.height);
          void 0 === C && (C = O(o, s));
          const a = n ? O(o, s) : C;
          return (
            (a.width = o),
            (a.height = s),
            a.getContext("2d").drawImage(e, 0, 0, o, s),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                e.width +
                "x" +
                e.height +
                ") to (" +
                o +
                "x" +
                s +
                ")."
            ),
            a
          );
        }
        return (
          "data" in e &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                e.width +
                "x" +
                e.height +
                ")."
            ),
          e
        );
      }
      return e;
    }
    function D(e) {
      return I.isPowerOfTwo(e.width) && I.isPowerOfTwo(e.height);
    }
    function F(e, t) {
      return e.generateMipmaps && t && e.minFilter !== r && e.minFilter !== a;
    }
    function U(t, n, i, r) {
      e.generateMipmap(t),
        (_.get(n).__maxMipLevel = Math.log(Math.max(i, r)) * Math.LOG2E);
    }
    function k(t, n, i) {
      if (!1 === S) return n;
      if (null !== t) {
        if (void 0 !== e[t]) return e[t];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            t +
            "'"
        );
      }
      let r = n;
      return (
        6403 === n &&
          (5126 === i && (r = 33326),
          5131 === i && (r = 33325),
          5121 === i && (r = 33321)),
        6407 === n &&
          (5126 === i && (r = 34837),
          5131 === i && (r = 34843),
          5121 === i && (r = 32849)),
        6408 === n &&
          (5126 === i && (r = 34836),
          5131 === i && (r = 34842),
          5121 === i && (r = 32856)),
        (33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r) ||
          y.get("EXT_color_buffer_float"),
        r
      );
    }
    function B(e) {
      return e === r || e === o || e === s ? 9728 : 9729;
    }
    function z(t) {
      const n = t.target;
      n.removeEventListener("dispose", z),
        (function (t) {
          const n = _.get(t);
          void 0 !== n.__webglInit &&
            (e.deleteTexture(n.__webglTexture), _.remove(t));
        })(n),
        n.isVideoTexture && R.delete(n),
        M.memory.textures--;
    }
    function H(t) {
      const n = t.target;
      n.removeEventListener("dispose", H),
        (function (t) {
          const n = _.get(t),
            i = _.get(t.texture);
          if (t) {
            if (
              (void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture),
              t.depthTexture && t.depthTexture.dispose(),
              t.isWebGLCubeRenderTarget)
            )
              for (let t = 0; t < 6; t++)
                e.deleteFramebuffer(n.__webglFramebuffer[t]),
                  n.__webglDepthbuffer &&
                    e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
            else
              e.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer &&
                  e.deleteRenderbuffer(n.__webglDepthbuffer),
                n.__webglMultisampledFramebuffer &&
                  e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                n.__webglColorRenderbuffer &&
                  e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                n.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
            _.remove(t.texture), _.remove(t);
          }
        })(n),
        M.memory.textures--;
    }
    let G = 0;
    function V(e, t) {
      const n = _.get(e);
      if (
        (e.isVideoTexture &&
          (function (e) {
            const t = M.render.frame;
            R.get(e) !== t && (R.set(e, t), e.update());
          })(e),
        e.version > 0 && n.__version !== e.version)
      ) {
        const i = e.image;
        if (void 0 === i)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined"
          );
        else {
          if (!1 !== i.complete) return void Z(n, e, t);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        }
      }
      x.activeTexture(33984 + t), x.bindTexture(3553, n.__webglTexture);
    }
    function j(t, n) {
      const i = _.get(t);
      t.version > 0 && i.__version !== t.version
        ? (function (t, n, i) {
            if (6 !== n.image.length) return;
            Y(t, n),
              x.activeTexture(33984 + i),
              x.bindTexture(34067, t.__webglTexture),
              e.pixelStorei(37440, n.flipY);
            const r =
                n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
              o = n.image[0] && n.image[0].isDataTexture,
              s = [];
            for (let e = 0; e < 6; e++)
              s[e] =
                r || o
                  ? o
                    ? n.image[e].image
                    : n.image[e]
                  : N(n.image[e], !1, !0, T);
            const a = s[0],
              c = D(a) || S,
              l = w.convert(n.format),
              h = w.convert(n.type),
              u = k(n.internalFormat, l, h);
            let d;
            if ((q(34067, n, c), r)) {
              for (let e = 0; e < 6; e++) {
                d = s[e].mipmaps;
                for (let t = 0; t < d.length; t++) {
                  const i = d[t];
                  n.format !== m && n.format !== f
                    ? null !== l
                      ? x.compressedTexImage2D(
                          34069 + e,
                          t,
                          u,
                          i.width,
                          i.height,
                          0,
                          i.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : x.texImage2D(
                        34069 + e,
                        t,
                        u,
                        i.width,
                        i.height,
                        0,
                        l,
                        h,
                        i.data
                      );
                }
              }
              t.__maxMipLevel = d.length - 1;
            } else {
              d = n.mipmaps;
              for (let e = 0; e < 6; e++)
                if (o) {
                  x.texImage2D(
                    34069 + e,
                    0,
                    u,
                    s[e].width,
                    s[e].height,
                    0,
                    l,
                    h,
                    s[e].data
                  );
                  for (let t = 0; t < d.length; t++) {
                    const n = d[t].image[e].image;
                    x.texImage2D(
                      34069 + e,
                      t + 1,
                      u,
                      n.width,
                      n.height,
                      0,
                      l,
                      h,
                      n.data
                    );
                  }
                } else {
                  x.texImage2D(34069 + e, 0, u, l, h, s[e]);
                  for (let t = 0; t < d.length; t++) {
                    const n = d[t];
                    x.texImage2D(34069 + e, t + 1, u, l, h, n.image[e]);
                  }
                }
              t.__maxMipLevel = d.length;
            }
            F(n, c) && U(34067, n, a.width, a.height),
              (t.__version = n.version),
              n.onUpdate && n.onUpdate(n);
          })(i, t, n)
        : (x.activeTexture(33984 + n), x.bindTexture(34067, i.__webglTexture));
    }
    const W = { [t]: 10497, [n]: 33071, [i]: 33648 },
      X = { [r]: 9728, [o]: 9984, [s]: 9986, [a]: 9729, 1007: 9985, [c]: 9987 };
    function q(t, i, o) {
      o
        ? (e.texParameteri(t, 10242, W[i.wrapS]),
          e.texParameteri(t, 10243, W[i.wrapT]),
          (32879 !== t && 35866 !== t) || e.texParameteri(t, 32882, W[i.wrapR]),
          e.texParameteri(t, 10240, X[i.magFilter]),
          e.texParameteri(t, 10241, X[i.minFilter]))
        : (e.texParameteri(t, 10242, 33071),
          e.texParameteri(t, 10243, 33071),
          (32879 !== t && 35866 !== t) || e.texParameteri(t, 32882, 33071),
          (i.wrapS === n && i.wrapT === n) ||
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          e.texParameteri(t, 10240, B(i.magFilter)),
          e.texParameteri(t, 10241, B(i.minFilter)),
          i.minFilter !== r &&
            i.minFilter !== a &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            ));
      const s = y.get("EXT_texture_filter_anisotropic");
      if (s) {
        if (i.type === u && null === y.get("OES_texture_float_linear")) return;
        if (
          i.type === d &&
          null === (S || y.get("OES_texture_half_float_linear"))
        )
          return;
        (i.anisotropy > 1 || _.get(i).__currentAnisotropy) &&
          (e.texParameterf(
            t,
            s.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(i.anisotropy, b.getMaxAnisotropy())
          ),
          (_.get(i).__currentAnisotropy = i.anisotropy));
      }
    }
    function Y(t, n) {
      void 0 === t.__webglInit &&
        ((t.__webglInit = !0),
        n.addEventListener("dispose", z),
        (t.__webglTexture = e.createTexture()),
        M.memory.textures++);
    }
    function Z(t, i, o) {
      let s = 3553;
      i.isDataTexture2DArray && (s = 35866),
        i.isDataTexture3D && (s = 32879),
        Y(t, i),
        x.activeTexture(33984 + o),
        x.bindTexture(s, t.__webglTexture),
        e.pixelStorei(37440, i.flipY),
        e.pixelStorei(37441, i.premultiplyAlpha),
        e.pixelStorei(3317, i.unpackAlignment);
      const c =
          (function (e) {
            return (
              !S &&
              (e.wrapS !== n ||
                e.wrapT !== n ||
                (e.minFilter !== r && e.minFilter !== a))
            );
          })(i) && !1 === D(i.image),
        d = N(i.image, c, !1, A),
        y = D(d) || S,
        _ = w.convert(i.format);
      let b,
        M = w.convert(i.type),
        E = k(i.internalFormat, _, M);
      q(s, i, y);
      const T = i.mipmaps;
      if (i.isDepthTexture)
        (E = 6402),
          S
            ? (E =
                i.type === u
                  ? 36012
                  : i.type === h
                  ? 33190
                  : i.type === p
                  ? 35056
                  : 33189)
            : i.type === u &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          i.format === g &&
            6402 === E &&
            i.type !== l &&
            i.type !== h &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (i.type = l),
            (M = w.convert(i.type))),
          i.format === v &&
            6402 === E &&
            ((E = 34041),
            i.type !== p &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (i.type = p),
              (M = w.convert(i.type)))),
          x.texImage2D(3553, 0, E, d.width, d.height, 0, _, M, null);
      else if (i.isDataTexture)
        if (T.length > 0 && y) {
          for (let e = 0, t = T.length; e < t; e++)
            (b = T[e]),
              x.texImage2D(3553, e, E, b.width, b.height, 0, _, M, b.data);
          (i.generateMipmaps = !1), (t.__maxMipLevel = T.length - 1);
        } else
          x.texImage2D(3553, 0, E, d.width, d.height, 0, _, M, d.data),
            (t.__maxMipLevel = 0);
      else if (i.isCompressedTexture) {
        for (let e = 0, t = T.length; e < t; e++)
          (b = T[e]),
            i.format !== m && i.format !== f
              ? null !== _
                ? x.compressedTexImage2D(
                    3553,
                    e,
                    E,
                    b.width,
                    b.height,
                    0,
                    b.data
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                  )
              : x.texImage2D(3553, e, E, b.width, b.height, 0, _, M, b.data);
        t.__maxMipLevel = T.length - 1;
      } else if (i.isDataTexture2DArray)
        x.texImage3D(35866, 0, E, d.width, d.height, d.depth, 0, _, M, d.data),
          (t.__maxMipLevel = 0);
      else if (i.isDataTexture3D)
        x.texImage3D(32879, 0, E, d.width, d.height, d.depth, 0, _, M, d.data),
          (t.__maxMipLevel = 0);
      else if (T.length > 0 && y) {
        for (let e = 0, t = T.length; e < t; e++)
          (b = T[e]), x.texImage2D(3553, e, E, _, M, b);
        (i.generateMipmaps = !1), (t.__maxMipLevel = T.length - 1);
      } else x.texImage2D(3553, 0, E, _, M, d), (t.__maxMipLevel = 0);
      F(i, y) && U(s, i, d.width, d.height),
        (t.__version = i.version),
        i.onUpdate && i.onUpdate(i);
    }
    function J(t, n, i, r) {
      const o = w.convert(n.texture.format),
        s = w.convert(n.texture.type),
        a = k(n.texture.internalFormat, o, s);
      x.texImage2D(r, 0, a, n.width, n.height, 0, o, s, null),
        e.bindFramebuffer(36160, t),
        e.framebufferTexture2D(36160, i, r, _.get(n.texture).__webglTexture, 0),
        e.bindFramebuffer(36160, null);
    }
    function K(t, n, i) {
      if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
        let r = 33189;
        if (i) {
          const t = n.depthTexture;
          t &&
            t.isDepthTexture &&
            (t.type === u ? (r = 36012) : t.type === h && (r = 33190));
          const i = Q(n);
          e.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
        } else e.renderbufferStorage(36161, r, n.width, n.height);
        e.framebufferRenderbuffer(36160, 36096, 36161, t);
      } else if (n.depthBuffer && n.stencilBuffer) {
        if (i) {
          const t = Q(n);
          e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height);
        } else e.renderbufferStorage(36161, 34041, n.width, n.height);
        e.framebufferRenderbuffer(36160, 33306, 36161, t);
      } else {
        const t = w.convert(n.texture.format),
          r = w.convert(n.texture.type),
          o = k(n.texture.internalFormat, t, r);
        if (i) {
          const t = Q(n);
          e.renderbufferStorageMultisample(36161, t, o, n.width, n.height);
        } else e.renderbufferStorage(36161, o, n.width, n.height);
      }
      e.bindRenderbuffer(36161, null);
    }
    function Q(e) {
      return S && e.isWebGLMultisampleRenderTarget ? Math.min(L, e.samples) : 0;
    }
    let $ = !1,
      ee = !1;
    (this.allocateTextureUnit = function () {
      const e = G;
      return (
        e >= E &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              e +
              " texture units while this GPU supports only " +
              E
          ),
        (G += 1),
        e
      );
    }),
      (this.resetTextureUnits = function () {
        G = 0;
      }),
      (this.setTexture2D = V),
      (this.setTexture2DArray = function (e, t) {
        const n = _.get(e);
        e.version > 0 && n.__version !== e.version
          ? Z(n, e, t)
          : (x.activeTexture(33984 + t),
            x.bindTexture(35866, n.__webglTexture));
      }),
      (this.setTexture3D = function (e, t) {
        const n = _.get(e);
        e.version > 0 && n.__version !== e.version
          ? Z(n, e, t)
          : (x.activeTexture(33984 + t),
            x.bindTexture(32879, n.__webglTexture));
      }),
      (this.setTextureCube = j),
      (this.setupRenderTarget = function (t) {
        const n = _.get(t),
          i = _.get(t.texture);
        t.addEventListener("dispose", H),
          (i.__webglTexture = e.createTexture()),
          M.memory.textures++;
        const r = !0 === t.isWebGLCubeRenderTarget,
          o = !0 === t.isWebGLMultisampleRenderTarget,
          s = D(t) || S;
        if (
          (!S ||
            t.texture.format !== f ||
            (t.texture.type !== u && t.texture.type !== d) ||
            ((t.texture.format = m),
            console.warn(
              "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
            )),
          r)
        ) {
          n.__webglFramebuffer = [];
          for (let t = 0; t < 6; t++)
            n.__webglFramebuffer[t] = e.createFramebuffer();
        } else if (((n.__webglFramebuffer = e.createFramebuffer()), o))
          if (S) {
            (n.__webglMultisampledFramebuffer = e.createFramebuffer()),
              (n.__webglColorRenderbuffer = e.createRenderbuffer()),
              e.bindRenderbuffer(36161, n.__webglColorRenderbuffer);
            const i = w.convert(t.texture.format),
              r = w.convert(t.texture.type),
              o = k(t.texture.internalFormat, i, r),
              s = Q(t);
            e.renderbufferStorageMultisample(36161, s, o, t.width, t.height),
              e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer),
              e.framebufferRenderbuffer(
                36160,
                36064,
                36161,
                n.__webglColorRenderbuffer
              ),
              e.bindRenderbuffer(36161, null),
              t.depthBuffer &&
                ((n.__webglDepthRenderbuffer = e.createRenderbuffer()),
                K(n.__webglDepthRenderbuffer, t, !0)),
              e.bindFramebuffer(36160, null);
          } else
            console.warn(
              "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
            );
        if (r) {
          x.bindTexture(34067, i.__webglTexture), q(34067, t.texture, s);
          for (let e = 0; e < 6; e++)
            J(n.__webglFramebuffer[e], t, 36064, 34069 + e);
          F(t.texture, s) && U(34067, t.texture, t.width, t.height),
            x.bindTexture(34067, null);
        } else
          x.bindTexture(3553, i.__webglTexture),
            q(3553, t.texture, s),
            J(n.__webglFramebuffer, t, 36064, 3553),
            F(t.texture, s) && U(3553, t.texture, t.width, t.height),
            x.bindTexture(3553, null);
        t.depthBuffer &&
          (function (t) {
            const n = _.get(t),
              i = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture) {
              if (i)
                throw new Error(
                  "target.depthTexture not supported in Cube render targets"
                );
              !(function (t, n) {
                if (n && n.isWebGLCubeRenderTarget)
                  throw new Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                if (
                  (e.bindFramebuffer(36160, t),
                  !n.depthTexture || !n.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (_.get(n.depthTexture).__webglTexture &&
                  n.depthTexture.image.width === n.width &&
                  n.depthTexture.image.height === n.height) ||
                  ((n.depthTexture.image.width = n.width),
                  (n.depthTexture.image.height = n.height),
                  (n.depthTexture.needsUpdate = !0)),
                  V(n.depthTexture, 0);
                const i = _.get(n.depthTexture).__webglTexture;
                if (n.depthTexture.format === g)
                  e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                else {
                  if (n.depthTexture.format !== v)
                    throw new Error("Unknown depthTexture format");
                  e.framebufferTexture2D(36160, 33306, 3553, i, 0);
                }
              })(n.__webglFramebuffer, t);
            } else if (i) {
              n.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                e.bindFramebuffer(36160, n.__webglFramebuffer[i]),
                  (n.__webglDepthbuffer[i] = e.createRenderbuffer()),
                  K(n.__webglDepthbuffer[i], t, !1);
            } else
              e.bindFramebuffer(36160, n.__webglFramebuffer),
                (n.__webglDepthbuffer = e.createRenderbuffer()),
                K(n.__webglDepthbuffer, t, !1);
            e.bindFramebuffer(36160, null);
          })(t);
      }),
      (this.updateRenderTargetMipmap = function (e) {
        const t = e.texture;
        if (F(t, D(e) || S)) {
          const n = e.isWebGLCubeRenderTarget ? 34067 : 3553,
            i = _.get(t).__webglTexture;
          x.bindTexture(n, i),
            U(n, t, e.width, e.height),
            x.bindTexture(n, null);
        }
      }),
      (this.updateMultisampleRenderTarget = function (t) {
        if (t.isWebGLMultisampleRenderTarget)
          if (S) {
            const n = _.get(t);
            e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
              e.bindFramebuffer(36009, n.__webglFramebuffer);
            const i = t.width,
              r = t.height;
            let o = 16384;
            t.depthBuffer && (o |= 256),
              t.stencilBuffer && (o |= 1024),
              e.blitFramebuffer(0, 0, i, r, 0, 0, i, r, o, 9728),
              e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
          } else
            console.warn(
              "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
            );
      }),
      (this.safeSetTexture2D = function (e, t) {
        e &&
          e.isWebGLRenderTarget &&
          (!1 === $ &&
            (console.warn(
              "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
            ),
            ($ = !0)),
          (e = e.texture)),
          V(e, t);
      }),
      (this.safeSetTextureCube = function (e, t) {
        e &&
          e.isWebGLCubeRenderTarget &&
          (!1 === ee &&
            (console.warn(
              "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
            ),
            (ee = !0)),
          (e = e.texture)),
          j(e, t);
      });
  }
  function Sr(e, t, n) {
    const i = n.isWebGL2;
    return {
      convert: function (e) {
        let n;
        if (1009 === e) return 5121;
        if (1017 === e) return 32819;
        if (1018 === e) return 32820;
        if (1019 === e) return 33635;
        if (1010 === e) return 5120;
        if (1011 === e) return 5122;
        if (e === l) return 5123;
        if (1013 === e) return 5124;
        if (e === h) return 5125;
        if (e === u) return 5126;
        if (e === d)
          return i
            ? 5131
            : ((n = t.get("OES_texture_half_float")),
              null !== n ? n.HALF_FLOAT_OES : null);
        if (1021 === e) return 6406;
        if (e === f) return 6407;
        if (e === m) return 6408;
        if (1024 === e) return 6409;
        if (1025 === e) return 6410;
        if (e === g) return 6402;
        if (e === v) return 34041;
        if (1028 === e) return 6403;
        if (1029 === e) return 36244;
        if (1030 === e) return 33319;
        if (1031 === e) return 33320;
        if (1032 === e) return 36248;
        if (1033 === e) return 36249;
        if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
          if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
            return null;
          if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
          if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
            return null;
          if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === e)
          return (
            (n = t.get("WEBGL_compressed_texture_etc1")),
            null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
          );
        if (
          (37492 === e || 37496 === e) &&
          ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
        ) {
          if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
          if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC;
        }
        return 37808 === e ||
          37809 === e ||
          37810 === e ||
          37811 === e ||
          37812 === e ||
          37813 === e ||
          37814 === e ||
          37815 === e ||
          37816 === e ||
          37817 === e ||
          37818 === e ||
          37819 === e ||
          37820 === e ||
          37821 === e ||
          37840 === e ||
          37841 === e ||
          37842 === e ||
          37843 === e ||
          37844 === e ||
          37845 === e ||
          37846 === e ||
          37847 === e ||
          37848 === e ||
          37849 === e ||
          37850 === e ||
          37851 === e ||
          37852 === e ||
          37853 === e
          ? ((n = t.get("WEBGL_compressed_texture_astc")),
            null !== n ? e : null)
          : 36492 === e
          ? ((n = t.get("EXT_texture_compression_bptc")), null !== n ? e : null)
          : e === p
          ? i
            ? 34042
            : ((n = t.get("WEBGL_depth_texture")),
              null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
          : void 0;
      },
    };
  }
  function Er(e = []) {
    mn.call(this), (this.cameras = e);
  }
  function Tr() {
    je.call(this), (this.type = "Group");
  }
  function Ar() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  function Lr(e, t) {
    const n = this;
    let i = null,
      r = 1,
      o = null,
      s = "local-floor",
      a = null;
    const c = [],
      l = new Map(),
      h = new mn();
    h.layers.enable(1), (h.viewport = new H());
    const u = new mn();
    u.layers.enable(2), (u.viewport = new H());
    const d = [h, u],
      p = new Er();
    p.layers.enable(1), p.layers.enable(2);
    let f = null,
      m = null;
    function g(e) {
      const t = l.get(e.inputSource);
      t && t.dispatchEvent({ type: e.type, data: e.inputSource });
    }
    function v() {
      l.forEach(function (e, t) {
        e.disconnect(t);
      }),
        l.clear(),
        e.setFramebuffer(null),
        e.setRenderTarget(e.getRenderTarget()),
        S.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    function y(e) {
      (o = e),
        S.setContext(i),
        S.start(),
        (n.isPresenting = !0),
        n.dispatchEvent({ type: "sessionstart" });
    }
    function x(e) {
      const t = i.inputSources;
      for (let e = 0; e < c.length; e++) l.set(t[e], c[e]);
      for (let t = 0; t < e.removed.length; t++) {
        const n = e.removed[t],
          i = l.get(n);
        i && (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n));
      }
      for (let t = 0; t < e.added.length; t++) {
        const n = e.added[t],
          i = l.get(n);
        i && i.dispatchEvent({ type: "connected", data: n });
      }
    }
    (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (e) {
        let t = c[e];
        return (
          void 0 === t && ((t = new Ar()), (c[e] = t)), t.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (e) {
        let t = c[e];
        return void 0 === t && ((t = new Ar()), (c[e] = t)), t.getGripSpace();
      }),
      (this.getHand = function (e) {
        let t = c[e];
        return void 0 === t && ((t = new Ar()), (c[e] = t)), t.getHandSpace();
      }),
      (this.setFramebufferScaleFactor = function (e) {
        (r = e),
          !0 === n.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
            );
      }),
      (this.setReferenceSpaceType = function (e) {
        (s = e),
          !0 === n.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return o;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = function (e) {
        if (((i = e), null !== i)) {
          i.addEventListener("select", g),
            i.addEventListener("selectstart", g),
            i.addEventListener("selectend", g),
            i.addEventListener("squeeze", g),
            i.addEventListener("squeezestart", g),
            i.addEventListener("squeezeend", g),
            i.addEventListener("end", v);
          const e = t.getContextAttributes();
          !0 !== e.xrCompatible && t.makeXRCompatible();
          const n = {
              antialias: e.antialias,
              alpha: e.alpha,
              depth: e.depth,
              stencil: e.stencil,
              framebufferScaleFactor: r,
            },
            o = new XRWebGLLayer(i, t, n);
          i.updateRenderState({ baseLayer: o }),
            i.requestReferenceSpace(s).then(y),
            i.addEventListener("inputsourceschange", x);
        }
      });
    const _ = new W(),
      b = new W();
    function w(e, t) {
      null === t
        ? e.matrixWorld.copy(e.matrix)
        : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
        e.matrixWorldInverse.copy(e.matrixWorld).invert();
    }
    this.getCamera = function (e) {
      (p.near = u.near = h.near = e.near),
        (p.far = u.far = h.far = e.far),
        (f === p.near && m === p.far) ||
          (i.updateRenderState({ depthNear: p.near, depthFar: p.far }),
          (f = p.near),
          (m = p.far));
      const t = e.parent,
        n = p.cameras;
      w(p, t);
      for (let e = 0; e < n.length; e++) w(n[e], t);
      e.matrixWorld.copy(p.matrixWorld);
      const r = e.children;
      for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
      return (
        2 === n.length
          ? (function (e, t, n) {
              _.setFromMatrixPosition(t.matrixWorld),
                b.setFromMatrixPosition(n.matrixWorld);
              const i = _.distanceTo(b),
                r = t.projectionMatrix.elements,
                o = n.projectionMatrix.elements,
                s = r[14] / (r[10] - 1),
                a = r[14] / (r[10] + 1),
                c = (r[9] + 1) / r[5],
                l = (r[9] - 1) / r[5],
                h = (r[8] - 1) / r[0],
                u = (o[8] + 1) / o[0],
                d = s * h,
                p = s * u,
                f = i / (-h + u),
                m = f * -h;
              t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                e.translateX(m),
                e.translateZ(f),
                e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
              const g = s + f,
                v = a + f,
                y = d - m,
                x = p + (i - m),
                w = ((c * a) / v) * g,
                M = ((l * a) / v) * g;
              e.projectionMatrix.makePerspective(y, x, w, M, g, v);
            })(p, h, u)
          : p.projectionMatrix.copy(h.projectionMatrix),
        p
      );
    };
    let M = null;
    const S = new Sn();
    S.setAnimationLoop(function (t, n) {
      if (((a = n.getViewerPose(o)), null !== a)) {
        const t = a.views,
          n = i.renderState.baseLayer;
        e.setFramebuffer(n.framebuffer);
        let r = !1;
        t.length !== p.cameras.length && ((p.cameras.length = 0), (r = !0));
        for (let e = 0; e < t.length; e++) {
          const i = t[e],
            o = n.getViewport(i),
            s = d[e];
          s.matrix.fromArray(i.transform.matrix),
            s.projectionMatrix.fromArray(i.projectionMatrix),
            s.viewport.set(o.x, o.y, o.width, o.height),
            0 === e && p.matrix.copy(s.matrix),
            !0 === r && p.cameras.push(s);
        }
      }
      const r = i.inputSources;
      for (let e = 0; e < c.length; e++) {
        const t = c[e],
          i = r[e];
        t.update(i, n, o);
      }
      M && M(t, n);
    }),
      (this.setAnimationLoop = function (e) {
        M = e;
      }),
      (this.dispose = function () {});
  }
  function Rr(e) {
    function t(t, n) {
      (t.opacity.value = n.opacity),
        n.color && t.diffuse.value.copy(n.color),
        n.emissive &&
          t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
        n.map && (t.map.value = n.map),
        n.alphaMap && (t.alphaMap.value = n.alphaMap),
        n.specularMap && (t.specularMap.value = n.specularMap);
      const i = e.get(n).envMap;
      if (i) {
        (t.envMap.value = i),
          (t.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
          (t.reflectivity.value = n.reflectivity),
          (t.refractionRatio.value = n.refractionRatio);
        const r = e.get(i).__maxMipLevel;
        void 0 !== r && (t.maxMipLevel.value = r);
      }
      let r, o;
      n.lightMap &&
        ((t.lightMap.value = n.lightMap),
        (t.lightMapIntensity.value = n.lightMapIntensity)),
        n.aoMap &&
          ((t.aoMap.value = n.aoMap),
          (t.aoMapIntensity.value = n.aoMapIntensity)),
        n.map
          ? (r = n.map)
          : n.specularMap
          ? (r = n.specularMap)
          : n.displacementMap
          ? (r = n.displacementMap)
          : n.normalMap
          ? (r = n.normalMap)
          : n.bumpMap
          ? (r = n.bumpMap)
          : n.roughnessMap
          ? (r = n.roughnessMap)
          : n.metalnessMap
          ? (r = n.metalnessMap)
          : n.alphaMap
          ? (r = n.alphaMap)
          : n.emissiveMap
          ? (r = n.emissiveMap)
          : n.clearcoatMap
          ? (r = n.clearcoatMap)
          : n.clearcoatNormalMap
          ? (r = n.clearcoatNormalMap)
          : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
        void 0 !== r &&
          (r.isWebGLRenderTarget && (r = r.texture),
          !0 === r.matrixAutoUpdate && r.updateMatrix(),
          t.uvTransform.value.copy(r.matrix)),
        n.aoMap ? (o = n.aoMap) : n.lightMap && (o = n.lightMap),
        void 0 !== o &&
          (o.isWebGLRenderTarget && (o = o.texture),
          !0 === o.matrixAutoUpdate && o.updateMatrix(),
          t.uv2Transform.value.copy(o.matrix));
    }
    function n(t, n) {
      (t.roughness.value = n.roughness),
        (t.metalness.value = n.metalness),
        n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
        n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
        n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
        n.bumpMap &&
          ((t.bumpMap.value = n.bumpMap),
          (t.bumpScale.value = n.bumpScale),
          1 === n.side && (t.bumpScale.value *= -1)),
        n.normalMap &&
          ((t.normalMap.value = n.normalMap),
          t.normalScale.value.copy(n.normalScale),
          1 === n.side && t.normalScale.value.negate()),
        n.displacementMap &&
          ((t.displacementMap.value = n.displacementMap),
          (t.displacementScale.value = n.displacementScale),
          (t.displacementBias.value = n.displacementBias)),
        e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
    }
    return {
      refreshFogUniforms: function (e, t) {
        e.fogColor.value.copy(t.color),
          t.isFog
            ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
            : t.isFogExp2 && (e.fogDensity.value = t.density);
      },
      refreshMaterialUniforms: function (e, i, r, o) {
        i.isMeshBasicMaterial
          ? t(e, i)
          : i.isMeshLambertMaterial
          ? (t(e, i),
            (function (e, t) {
              t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
            })(e, i))
          : i.isMeshToonMaterial
          ? (t(e, i),
            (function (e, t) {
              t.gradientMap && (e.gradientMap.value = t.gradientMap),
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1)),
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate()),
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
            })(e, i))
          : i.isMeshPhongMaterial
          ? (t(e, i),
            (function (e, t) {
              e.specular.value.copy(t.specular),
                (e.shininess.value = Math.max(t.shininess, 1e-4)),
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1)),
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate()),
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
            })(e, i))
          : i.isMeshStandardMaterial
          ? (t(e, i),
            i.isMeshPhysicalMaterial
              ? (function (e, t) {
                  n(e, t),
                    (e.reflectivity.value = t.reflectivity),
                    (e.clearcoat.value = t.clearcoat),
                    (e.clearcoatRoughness.value = t.clearcoatRoughness),
                    t.sheen && e.sheen.value.copy(t.sheen),
                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                    t.clearcoatRoughnessMap &&
                      (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                    t.clearcoatNormalMap &&
                      (e.clearcoatNormalScale.value.copy(
                        t.clearcoatNormalScale
                      ),
                      (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                      1 === t.side && e.clearcoatNormalScale.value.negate()),
                    (e.transmission.value = t.transmission),
                    t.transmissionMap &&
                      (e.transmissionMap.value = t.transmissionMap);
                })(e, i)
              : n(e, i))
          : i.isMeshMatcapMaterial
          ? (t(e, i),
            (function (e, t) {
              t.matcap && (e.matcap.value = t.matcap),
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  1 === t.side && (e.bumpScale.value *= -1)),
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate()),
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
            })(e, i))
          : i.isMeshDepthMaterial
          ? (t(e, i),
            (function (e, t) {
              t.displacementMap &&
                ((e.displacementMap.value = t.displacementMap),
                (e.displacementScale.value = t.displacementScale),
                (e.displacementBias.value = t.displacementBias));
            })(e, i))
          : i.isMeshDistanceMaterial
          ? (t(e, i),
            (function (e, t) {
              t.displacementMap &&
                ((e.displacementMap.value = t.displacementMap),
                (e.displacementScale.value = t.displacementScale),
                (e.displacementBias.value = t.displacementBias)),
                e.referencePosition.value.copy(t.referencePosition),
                (e.nearDistance.value = t.nearDistance),
                (e.farDistance.value = t.farDistance);
            })(e, i))
          : i.isMeshNormalMaterial
          ? (t(e, i),
            (function (e, t) {
              t.bumpMap &&
                ((e.bumpMap.value = t.bumpMap),
                (e.bumpScale.value = t.bumpScale),
                1 === t.side && (e.bumpScale.value *= -1)),
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  1 === t.side && e.normalScale.value.negate()),
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
            })(e, i))
          : i.isLineBasicMaterial
          ? ((function (e, t) {
              e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
            })(e, i),
            i.isLineDashedMaterial &&
              (function (e, t) {
                (e.dashSize.value = t.dashSize),
                  (e.totalSize.value = t.dashSize + t.gapSize),
                  (e.scale.value = t.scale);
              })(e, i))
          : i.isPointsMaterial
          ? (function (e, t, n, i) {
              let r;
              e.diffuse.value.copy(t.color),
                (e.opacity.value = t.opacity),
                (e.size.value = t.size * n),
                (e.scale.value = 0.5 * i),
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.map ? (r = t.map) : t.alphaMap && (r = t.alphaMap),
                void 0 !== r &&
                  (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                  e.uvTransform.value.copy(r.matrix));
            })(e, i, r, o)
          : i.isSpriteMaterial
          ? (function (e, t) {
              let n;
              e.diffuse.value.copy(t.color),
                (e.opacity.value = t.opacity),
                (e.rotation.value = t.rotation),
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap),
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  e.uvTransform.value.copy(n.matrix));
            })(e, i)
          : i.isShadowMaterial
          ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
          : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
      },
    };
  }
  function Cr(e) {
    const t =
        void 0 !== (e = e || {}).canvas
          ? e.canvas
          : (function () {
              const e = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
              return (e.style.display = "block"), e;
            })(),
      n = void 0 !== e.context ? e.context : null,
      i = void 0 !== e.alpha && e.alpha,
      r = void 0 === e.depth || e.depth,
      o = void 0 === e.stencil || e.stencil,
      s = void 0 !== e.antialias && e.antialias,
      a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
      c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
      l = void 0 !== e.powerPreference ? e.powerPreference : "default",
      h =
        void 0 !== e.failIfMajorPerformanceCaveat &&
        e.failIfMajorPerformanceCaveat;
    let p = null,
      f = null;
    const g = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0 }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.gammaFactor = 2),
      (this.outputEncoding = S),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = 0),
      (this.toneMappingExposure = 1),
      (this.maxMorphTargets = 8),
      (this.maxMorphNormals = 4);
    const v = this;
    let y = !1,
      x = null,
      _ = 0,
      b = 0,
      w = null,
      M = null,
      E = -1,
      T = null;
    const A = new H(),
      L = new H();
    let R = null,
      C = t.width,
      P = t.height,
      O = 1,
      D = null,
      F = null;
    const U = new H(0, 0, C, P),
      k = new H(0, 0, C, P);
    let B = !1;
    const z = new Mn();
    let G = !1,
      V = !1;
    const j = new xe(),
      X = new W(),
      q = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Y() {
      return null === w ? O : 1;
    }
    let Z,
      J,
      K,
      Q,
      $,
      ee,
      te,
      ne,
      ie,
      re,
      oe,
      se,
      ae,
      ce,
      le,
      he,
      ue,
      de,
      pe,
      fe,
      me,
      ge = n;
    function ve(e, n) {
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          o = t.getContext(r, n);
        if (null !== o) return o;
      }
      return null;
    }
    try {
      const e = {
        alpha: i,
        depth: r,
        stencil: o,
        antialias: s,
        premultipliedAlpha: a,
        preserveDrawingBuffer: c,
        powerPreference: l,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        (t.addEventListener("webglcontextlost", we, !1),
        t.addEventListener("webglcontextrestored", Me, !1),
        null === ge)
      ) {
        const t = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (!0 === v.isWebGL1Renderer && t.shift(), (ge = ve(t, e)), null === ge)
        )
          throw ve(t)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      void 0 === ge.getShaderPrecisionFormat &&
        (ge.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (e) {
      throw (console.error("THREE.WebGLRenderer: " + e.message), e);
    }
    function ye() {
      (Z = new Fn(ge)),
        (J = new In(ge, Z, e)),
        !1 === J.isWebGL2 &&
          (Z.get("WEBGL_depth_texture"),
          Z.get("OES_texture_float"),
          Z.get("OES_texture_half_float"),
          Z.get("OES_texture_half_float_linear"),
          Z.get("OES_standard_derivatives"),
          Z.get("OES_element_index_uint"),
          Z.get("OES_vertex_array_object"),
          Z.get("ANGLE_instanced_arrays")),
        Z.get("OES_texture_float_linear"),
        (fe = new Sr(ge, Z, J)),
        (K = new wr(ge, Z, J)),
        K.scissor(L.copy(k).multiplyScalar(O).floor()),
        K.viewport(A.copy(U).multiplyScalar(O).floor()),
        (Q = new Bn(ge)),
        ($ = new cr()),
        (ee = new Mr(ge, Z, K, $, J, fe, Q)),
        (te = new Dn(v)),
        (ne = new En(ge, J)),
        (me = new Pn(ge, Z, ne, J)),
        (ie = new Un(ge, ne, Q, me)),
        (re = new Vn(ge, ie, ne, Q)),
        (ue = new Gn(ge)),
        (le = new Nn($)),
        (oe = new ar(v, te, Z, J, me, le)),
        (se = new Rr($)),
        (ae = new dr($)),
        (ce = new yr(Z, J)),
        (he = new Cn(v, te, K, re, a)),
        (de = new On(ge, Z, Q, J)),
        (pe = new kn(ge, Z, Q, J)),
        (Q.programs = oe.programs),
        (v.capabilities = J),
        (v.extensions = Z),
        (v.properties = $),
        (v.renderLists = ae),
        (v.state = K),
        (v.info = Q);
    }
    ye();
    const _e = new Lr(v, ge);
    this.xr = _e;
    const be = new br(v, re, J.maxTextureSize);
    function we(e) {
      e.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (y = !0);
    }
    function Me() {
      console.log("THREE.WebGLRenderer: Context Restored."), (y = !1), ye();
    }
    function Se(e) {
      const t = e.target;
      t.removeEventListener("dispose", Se),
        (function (e) {
          Ee(e), $.remove(e);
        })(t);
    }
    function Ee(e) {
      const t = $.get(e).program;
      void 0 !== t && oe.releaseProgram(t);
    }
    (this.shadowMap = be),
      (this.getContext = function () {
        return ge;
      }),
      (this.getContextAttributes = function () {
        return ge.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const e = Z.get("WEBGL_lose_context");
        e && e.loseContext();
      }),
      (this.forceContextRestore = function () {
        const e = Z.get("WEBGL_lose_context");
        e && e.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return O;
      }),
      (this.setPixelRatio = function (e) {
        void 0 !== e && ((O = e), this.setSize(C, P, !1));
      }),
      (this.getSize = function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
            ),
            (e = new N())),
          e.set(C, P)
        );
      }),
      (this.setSize = function (e, n, i) {
        _e.isPresenting
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
          : ((C = e),
            (P = n),
            (t.width = Math.floor(e * O)),
            (t.height = Math.floor(n * O)),
            !1 !== i &&
              ((t.style.width = e + "px"), (t.style.height = n + "px")),
            this.setViewport(0, 0, e, n));
      }),
      (this.getDrawingBufferSize = function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
            ),
            (e = new N())),
          e.set(C * O, P * O).floor()
        );
      }),
      (this.setDrawingBufferSize = function (e, n, i) {
        (C = e),
          (P = n),
          (O = i),
          (t.width = Math.floor(e * i)),
          (t.height = Math.floor(n * i)),
          this.setViewport(0, 0, e, n);
      }),
      (this.getCurrentViewport = function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
            ),
            (e = new H())),
          e.copy(A)
        );
      }),
      (this.getViewport = function (e) {
        return e.copy(U);
      }),
      (this.setViewport = function (e, t, n, i) {
        e.isVector4 ? U.set(e.x, e.y, e.z, e.w) : U.set(e, t, n, i),
          K.viewport(A.copy(U).multiplyScalar(O).floor());
      }),
      (this.getScissor = function (e) {
        return e.copy(k);
      }),
      (this.setScissor = function (e, t, n, i) {
        e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, i),
          K.scissor(L.copy(k).multiplyScalar(O).floor());
      }),
      (this.getScissorTest = function () {
        return B;
      }),
      (this.setScissorTest = function (e) {
        K.setScissorTest((B = e));
      }),
      (this.setOpaqueSort = function (e) {
        D = e;
      }),
      (this.setTransparentSort = function (e) {
        F = e;
      }),
      (this.getClearColor = function (e) {
        return (
          void 0 === e &&
            (console.warn(
              "WebGLRenderer: .getClearColor() now requires a Color as an argument"
            ),
            (e = new dt())),
          e.copy(he.getClearColor())
        );
      }),
      (this.setClearColor = function () {
        he.setClearColor.apply(he, arguments);
      }),
      (this.getClearAlpha = function () {
        return he.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        he.setClearAlpha.apply(he, arguments);
      }),
      (this.clear = function (e, t, n) {
        let i = 0;
        (void 0 === e || e) && (i |= 16384),
          (void 0 === t || t) && (i |= 256),
          (void 0 === n || n) && (i |= 1024),
          ge.clear(i);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", we, !1),
          t.removeEventListener("webglcontextrestored", Me, !1),
          ae.dispose(),
          ce.dispose(),
          $.dispose(),
          te.dispose(),
          re.dispose(),
          me.dispose(),
          _e.dispose(),
          Ae.stop();
      }),
      (this.renderBufferImmediate = function (e, t) {
        me.initAttributes();
        const n = $.get(e);
        e.hasPositions && !n.position && (n.position = ge.createBuffer()),
          e.hasNormals && !n.normal && (n.normal = ge.createBuffer()),
          e.hasUvs && !n.uv && (n.uv = ge.createBuffer()),
          e.hasColors && !n.color && (n.color = ge.createBuffer());
        const i = t.getAttributes();
        e.hasPositions &&
          (ge.bindBuffer(34962, n.position),
          ge.bufferData(34962, e.positionArray, 35048),
          me.enableAttribute(i.position),
          ge.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
          e.hasNormals &&
            (ge.bindBuffer(34962, n.normal),
            ge.bufferData(34962, e.normalArray, 35048),
            me.enableAttribute(i.normal),
            ge.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
          e.hasUvs &&
            (ge.bindBuffer(34962, n.uv),
            ge.bufferData(34962, e.uvArray, 35048),
            me.enableAttribute(i.uv),
            ge.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
          e.hasColors &&
            (ge.bindBuffer(34962, n.color),
            ge.bufferData(34962, e.colorArray, 35048),
            me.enableAttribute(i.color),
            ge.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
          me.disableUnusedAttributes(),
          ge.drawArrays(4, 0, e.count),
          (e.count = 0);
      }),
      (this.renderBufferDirect = function (e, t, n, i, r, o) {
        null === t && (t = q);
        const s = r.isMesh && r.matrixWorld.determinant() < 0,
          a = Oe(e, t, i, r);
        K.setMaterial(i, s);
        let c = n.index;
        const l = n.attributes.position;
        if (null === c) {
          if (void 0 === l || 0 === l.count) return;
        } else if (0 === c.count) return;
        let h,
          u = 1;
        !0 === i.wireframe && ((c = ie.getWireframeAttribute(n)), (u = 2)),
          (i.morphTargets || i.morphNormals) && ue.update(r, n, i, a),
          me.setup(r, i, a, n, c);
        let d = de;
        null !== c && ((h = ne.get(c)), (d = pe), d.setIndex(h));
        const p = null !== c ? c.count : l.count,
          f = n.drawRange.start * u,
          m = n.drawRange.count * u,
          g = null !== o ? o.start * u : 0,
          v = null !== o ? o.count * u : 1 / 0,
          y = Math.max(f, g),
          x = Math.min(p, f + m, g + v) - 1,
          _ = Math.max(0, x - y + 1);
        if (0 !== _) {
          if (r.isMesh)
            !0 === i.wireframe
              ? (K.setLineWidth(i.wireframeLinewidth * Y()), d.setMode(1))
              : d.setMode(4);
          else if (r.isLine) {
            let e = i.linewidth;
            void 0 === e && (e = 1),
              K.setLineWidth(e * Y()),
              r.isLineSegments
                ? d.setMode(1)
                : r.isLineLoop
                ? d.setMode(2)
                : d.setMode(3);
          } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
          if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
          else if (n.isInstancedBufferGeometry) {
            const e = Math.min(n.instanceCount, n._maxInstanceCount);
            d.renderInstances(y, _, e);
          } else d.render(y, _);
        }
      }),
      (this.compile = function (e, t) {
        (f = ce.get(e)),
          f.init(),
          e.traverseVisible(function (e) {
            e.isLight &&
              e.layers.test(t.layers) &&
              (f.pushLight(e), e.castShadow && f.pushShadow(e));
          }),
          f.setupLights();
        const n = new WeakMap();
        e.traverse(function (t) {
          const i = t.material;
          if (i)
            if (Array.isArray(i))
              for (let r = 0; r < i.length; r++) {
                const o = i[r];
                !1 === n.has(o) && (Pe(o, e, t), n.set(o));
              }
            else !1 === n.has(i) && (Pe(i, e, t), n.set(i));
        });
      });
    let Te = null;
    const Ae = new Sn();
    function Le(e, t, n, i) {
      if (!1 === e.visible) return;
      if (e.layers.test(t.layers))
        if (e.isGroup) n = e.renderOrder;
        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
        else if (e.isLight) f.pushLight(e), e.castShadow && f.pushShadow(e);
        else if (e.isSprite) {
          if (!e.frustumCulled || z.intersectsSprite(e)) {
            i && X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
            const t = re.update(e),
              r = e.material;
            r.visible && p.push(e, t, r, n, X.z, null);
          }
        } else if (e.isImmediateRenderObject)
          i && X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j),
            p.push(e, null, e.material, n, X.z, null);
        else if (
          (e.isMesh || e.isLine || e.isPoints) &&
          (e.isSkinnedMesh &&
            e.skeleton.frame !== Q.render.frame &&
            (e.skeleton.update(), (e.skeleton.frame = Q.render.frame)),
          !e.frustumCulled || z.intersectsObject(e))
        ) {
          i && X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
          const t = re.update(e),
            r = e.material;
          if (Array.isArray(r)) {
            const i = t.groups;
            for (let o = 0, s = i.length; o < s; o++) {
              const s = i[o],
                a = r[s.materialIndex];
              a && a.visible && p.push(e, t, a, n, X.z, s);
            }
          } else r.visible && p.push(e, t, r, n, X.z, null);
        }
      const r = e.children;
      for (let e = 0, o = r.length; e < o; e++) Le(r[e], t, n, i);
    }
    function Re(e, t, n) {
      const i = !0 === t.isScene ? t.overrideMaterial : null;
      for (let r = 0, o = e.length; r < o; r++) {
        const o = e[r],
          s = o.object,
          a = o.geometry,
          c = null === i ? o.material : i,
          l = o.group;
        if (n.isArrayCamera) {
          const e = n.cameras;
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            s.layers.test(i.layers) &&
              (K.viewport(A.copy(i.viewport)),
              f.setupLightsView(i),
              Ce(s, t, i, a, c, l));
          }
        } else Ce(s, t, n, a, c, l);
      }
    }
    function Ce(e, t, n, i, r, o) {
      if (
        (e.onBeforeRender(v, t, n, i, r, o),
        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
        e.isImmediateRenderObject)
      ) {
        const i = Oe(n, t, r, e);
        K.setMaterial(r),
          me.reset(),
          (function (e, t) {
            e.render(function (e) {
              v.renderBufferImmediate(e, t);
            });
          })(e, i);
      } else v.renderBufferDirect(n, t, i, r, e, o);
      e.onAfterRender(v, t, n, i, r, o);
    }
    function Pe(e, t, n) {
      !0 !== t.isScene && (t = q);
      const i = $.get(e),
        r = f.state.lights,
        o = f.state.shadowsArray,
        s = r.state.version,
        a = oe.getParameters(e, r.state, o, t, n),
        c = oe.getProgramCacheKey(a);
      let l = i.program,
        h = !0;
      if (void 0 === l) e.addEventListener("dispose", Se);
      else if (l.cacheKey !== c) Ee(e);
      else if (i.lightsStateVersion !== s) h = !1;
      else {
        if (void 0 !== a.shaderID) {
          const n = e.isMeshStandardMaterial ? t.environment : null;
          return void (i.envMap = te.get(e.envMap || n));
        }
        h = !1;
      }
      h &&
        ((a.uniforms = oe.getUniforms(e)),
        e.onBeforeCompile(a, v),
        (l = oe.acquireProgram(a, c)),
        (i.program = l),
        (i.uniforms = a.uniforms),
        (i.outputEncoding = a.outputEncoding));
      const u = i.uniforms;
      ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
        ((i.numClippingPlanes = le.numPlanes),
        (i.numIntersection = le.numIntersection),
        (u.clippingPlanes = le.uniform)),
        (i.environment = e.isMeshStandardMaterial ? t.environment : null),
        (i.fog = t.fog),
        (i.envMap = te.get(e.envMap || i.environment)),
        (i.needsLights = (function (e) {
          return (
            e.isMeshLambertMaterial ||
            e.isMeshToonMaterial ||
            e.isMeshPhongMaterial ||
            e.isMeshStandardMaterial ||
            e.isShadowMaterial ||
            (e.isShaderMaterial && !0 === e.lights)
          );
        })(e)),
        (i.lightsStateVersion = s),
        i.needsLights &&
          ((u.ambientLightColor.value = r.state.ambient),
          (u.lightProbe.value = r.state.probe),
          (u.directionalLights.value = r.state.directional),
          (u.directionalLightShadows.value = r.state.directionalShadow),
          (u.spotLights.value = r.state.spot),
          (u.spotLightShadows.value = r.state.spotShadow),
          (u.rectAreaLights.value = r.state.rectArea),
          (u.ltc_1.value = r.state.rectAreaLTC1),
          (u.ltc_2.value = r.state.rectAreaLTC2),
          (u.pointLights.value = r.state.point),
          (u.pointLightShadows.value = r.state.pointShadow),
          (u.hemisphereLights.value = r.state.hemi),
          (u.directionalShadowMap.value = r.state.directionalShadowMap),
          (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
          (u.spotShadowMap.value = r.state.spotShadowMap),
          (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
          (u.pointShadowMap.value = r.state.pointShadowMap),
          (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
      const d = i.program.getUniforms(),
        p = zi.seqWithValue(d.seq, u);
      i.uniformsList = p;
    }
    function Oe(e, t, n, i) {
      !0 !== t.isScene && (t = q), ee.resetTextureUnits();
      const r = t.fog,
        o = n.isMeshStandardMaterial ? t.environment : null,
        s = null === w ? v.outputEncoding : w.texture.encoding,
        a = te.get(n.envMap || o),
        c = $.get(n),
        l = f.state.lights;
      if (!0 === G && (!0 === V || e !== T)) {
        const t = e === T && n.id === E;
        le.setState(n, e, t);
      }
      n.version === c.__version
        ? (n.fog && c.fog !== r) ||
          c.environment !== o ||
          (c.needsLights && c.lightsStateVersion !== l.state.version)
          ? Pe(n, t, i)
          : void 0 === c.numClippingPlanes ||
            (c.numClippingPlanes === le.numPlanes &&
              c.numIntersection === le.numIntersection)
          ? (c.outputEncoding !== s || c.envMap !== a) && Pe(n, t, i)
          : Pe(n, t, i)
        : (Pe(n, t, i), (c.__version = n.version));
      let h = !1,
        d = !1,
        p = !1;
      const g = c.program,
        y = g.getUniforms(),
        x = c.uniforms;
      if (
        (K.useProgram(g.program) && ((h = !0), (d = !0), (p = !0)),
        n.id !== E && ((E = n.id), (d = !0)),
        h || T !== e)
      ) {
        if (
          (y.setValue(ge, "projectionMatrix", e.projectionMatrix),
          J.logarithmicDepthBuffer &&
            y.setValue(
              ge,
              "logDepthBufFC",
              2 / (Math.log(e.far + 1) / Math.LN2)
            ),
          T !== e && ((T = e), (d = !0), (p = !0)),
          n.isShaderMaterial ||
            n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshStandardMaterial ||
            n.envMap)
        ) {
          const t = y.map.cameraPosition;
          void 0 !== t &&
            t.setValue(ge, X.setFromMatrixPosition(e.matrixWorld));
        }
        (n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshLambertMaterial ||
          n.isMeshBasicMaterial ||
          n.isMeshStandardMaterial ||
          n.isShaderMaterial) &&
          y.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera),
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial ||
            n.isShadowMaterial ||
            n.skinning) &&
            y.setValue(ge, "viewMatrix", e.matrixWorldInverse);
      }
      if (n.skinning) {
        y.setOptional(ge, i, "bindMatrix"),
          y.setOptional(ge, i, "bindMatrixInverse");
        const e = i.skeleton;
        if (e) {
          const t = e.bones;
          if (J.floatVertexTextures) {
            if (null === e.boneTexture) {
              let n = Math.sqrt(4 * t.length);
              (n = I.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
              const i = new Float32Array(n * n * 4);
              i.set(e.boneMatrices);
              const r = new _n(i, n, n, m, u);
              (e.boneMatrices = i),
                (e.boneTexture = r),
                (e.boneTextureSize = n);
            }
            y.setValue(ge, "boneTexture", e.boneTexture, ee),
              y.setValue(ge, "boneTextureSize", e.boneTextureSize);
          } else y.setOptional(ge, e, "boneMatrices");
        }
      }
      var _, b;
      return (
        (d || c.receiveShadow !== i.receiveShadow) &&
          ((c.receiveShadow = i.receiveShadow),
          y.setValue(ge, "receiveShadow", i.receiveShadow)),
        d &&
          (y.setValue(ge, "toneMappingExposure", v.toneMappingExposure),
          c.needsLights &&
            ((b = p),
            ((_ = x).ambientLightColor.needsUpdate = b),
            (_.lightProbe.needsUpdate = b),
            (_.directionalLights.needsUpdate = b),
            (_.directionalLightShadows.needsUpdate = b),
            (_.pointLights.needsUpdate = b),
            (_.pointLightShadows.needsUpdate = b),
            (_.spotLights.needsUpdate = b),
            (_.spotLightShadows.needsUpdate = b),
            (_.rectAreaLights.needsUpdate = b),
            (_.hemisphereLights.needsUpdate = b)),
          r && n.fog && se.refreshFogUniforms(x, r),
          se.refreshMaterialUniforms(x, n, O, P),
          zi.upload(ge, c.uniformsList, x, ee)),
        n.isShaderMaterial &&
          !0 === n.uniformsNeedUpdate &&
          (zi.upload(ge, c.uniformsList, x, ee), (n.uniformsNeedUpdate = !1)),
        n.isSpriteMaterial && y.setValue(ge, "center", i.center),
        y.setValue(ge, "modelViewMatrix", i.modelViewMatrix),
        y.setValue(ge, "normalMatrix", i.normalMatrix),
        y.setValue(ge, "modelMatrix", i.matrixWorld),
        g
      );
    }
    Ae.setAnimationLoop(function (e) {
      _e.isPresenting || (Te && Te(e));
    }),
      "undefined" != typeof window && Ae.setContext(window),
      (this.setAnimationLoop = function (e) {
        (Te = e), _e.setAnimationLoop(e), null === e ? Ae.stop() : Ae.start();
      }),
      (this.render = function (e, t) {
        let n, i;
        if (
          (void 0 !== arguments[2] &&
            (console.warn(
              "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
            ),
            (n = arguments[2])),
          void 0 !== arguments[3] &&
            (console.warn(
              "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
            ),
            (i = arguments[3])),
          void 0 !== t && !0 !== t.isCamera)
        )
          return void console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
        if (!0 === y) return;
        me.resetDefaultState(),
          (E = -1),
          (T = null),
          !0 === e.autoUpdate && e.updateMatrixWorld(),
          null === t.parent && t.updateMatrixWorld(),
          !0 === _e.enabled && !0 === _e.isPresenting && (t = _e.getCamera(t)),
          !0 === e.isScene && e.onBeforeRender(v, e, t, n || w),
          (f = ce.get(e, g.length)),
          f.init(),
          g.push(f),
          j.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          z.setFromProjectionMatrix(j),
          (V = this.localClippingEnabled),
          (G = le.init(this.clippingPlanes, V, t)),
          (p = ae.get(e, t)),
          p.init(),
          Le(e, t, 0, v.sortObjects),
          p.finish(),
          !0 === v.sortObjects && p.sort(D, F),
          !0 === G && le.beginShadows();
        const r = f.state.shadowsArray;
        be.render(r, e, t),
          f.setupLights(),
          f.setupLightsView(t),
          !0 === G && le.endShadows(),
          !0 === this.info.autoReset && this.info.reset(),
          void 0 !== n && this.setRenderTarget(n),
          he.render(p, e, t, i);
        const o = p.opaque,
          s = p.transparent;
        o.length > 0 && Re(o, e, t),
          s.length > 0 && Re(s, e, t),
          !0 === e.isScene && e.onAfterRender(v, e, t),
          null !== w &&
            (ee.updateRenderTargetMipmap(w),
            ee.updateMultisampleRenderTarget(w)),
          K.buffers.depth.setTest(!0),
          K.buffers.depth.setMask(!0),
          K.buffers.color.setMask(!0),
          K.setPolygonOffset(!1),
          g.pop(),
          (f = g.length > 0 ? g[g.length - 1] : null),
          (p = null);
      }),
      (this.setFramebuffer = function (e) {
        x !== e && null === w && ge.bindFramebuffer(36160, e), (x = e);
      }),
      (this.getActiveCubeFace = function () {
        return _;
      }),
      (this.getActiveMipmapLevel = function () {
        return b;
      }),
      (this.getRenderList = function () {
        return p;
      }),
      (this.setRenderList = function (e) {
        p = e;
      }),
      (this.getRenderTarget = function () {
        return w;
      }),
      (this.setRenderTarget = function (e, t = 0, n = 0) {
        (w = e),
          (_ = t),
          (b = n),
          e &&
            void 0 === $.get(e).__webglFramebuffer &&
            ee.setupRenderTarget(e);
        let i = x,
          r = !1;
        if (e) {
          const n = $.get(e).__webglFramebuffer;
          e.isWebGLCubeRenderTarget
            ? ((i = n[t]), (r = !0))
            : (i = e.isWebGLMultisampleRenderTarget
                ? $.get(e).__webglMultisampledFramebuffer
                : n),
            A.copy(e.viewport),
            L.copy(e.scissor),
            (R = e.scissorTest);
        } else
          A.copy(U).multiplyScalar(O).floor(),
            L.copy(k).multiplyScalar(O).floor(),
            (R = B);
        if (
          (M !== i && (ge.bindFramebuffer(36160, i), (M = i)),
          K.viewport(A),
          K.scissor(L),
          K.setScissorTest(R),
          r)
        ) {
          const i = $.get(e.texture);
          ge.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n);
        }
      }),
      (this.readRenderTargetPixels = function (e, t, n, i, r, o, s) {
        if (!e || !e.isWebGLRenderTarget)
          return void console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let a = $.get(e).__webglFramebuffer;
        if ((e.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
          let s = !1;
          a !== M && (ge.bindFramebuffer(36160, a), (s = !0));
          try {
            const a = e.texture,
              c = a.format,
              l = a.type;
            if (c !== m && fe.convert(c) !== ge.getParameter(35739))
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
            if (
              !(
                1009 === l ||
                fe.convert(l) === ge.getParameter(35738) ||
                (l === u &&
                  (J.isWebGL2 ||
                    Z.get("OES_texture_float") ||
                    Z.get("WEBGL_color_buffer_float"))) ||
                (l === d &&
                  (J.isWebGL2
                    ? Z.get("EXT_color_buffer_float")
                    : Z.get("EXT_color_buffer_half_float")))
              )
            )
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            36053 === ge.checkFramebufferStatus(36160)
              ? t >= 0 &&
                t <= e.width - i &&
                n >= 0 &&
                n <= e.height - r &&
                ge.readPixels(t, n, i, r, fe.convert(c), fe.convert(l), o)
              : console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                );
          } finally {
            s && ge.bindFramebuffer(36160, M);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (e, t, n = 0) {
        const i = Math.pow(2, -n),
          r = Math.floor(t.image.width * i),
          o = Math.floor(t.image.height * i),
          s = fe.convert(t.format);
        ee.setTexture2D(t, 0),
          ge.copyTexImage2D(3553, n, s, e.x, e.y, r, o, 0),
          K.unbindTexture();
      }),
      (this.copyTextureToTexture = function (e, t, n, i = 0) {
        const r = t.image.width,
          o = t.image.height,
          s = fe.convert(n.format),
          a = fe.convert(n.type);
        ee.setTexture2D(n, 0),
          ge.pixelStorei(37440, n.flipY),
          ge.pixelStorei(37441, n.premultiplyAlpha),
          ge.pixelStorei(3317, n.unpackAlignment),
          t.isDataTexture
            ? ge.texSubImage2D(3553, i, e.x, e.y, r, o, s, a, t.image.data)
            : t.isCompressedTexture
            ? ge.compressedTexSubImage2D(
                3553,
                i,
                e.x,
                e.y,
                t.mipmaps[0].width,
                t.mipmaps[0].height,
                s,
                t.mipmaps[0].data
              )
            : ge.texSubImage2D(3553, i, e.x, e.y, s, a, t.image),
          0 === i && n.generateMipmaps && ge.generateMipmap(3553),
          K.unbindTexture();
      }),
      (this.initTexture = function (e) {
        ee.setTexture2D(e, 0), K.unbindTexture();
      }),
      (this.resetState = function () {
        K.reset(), me.reset();
      }),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  function Pr(e) {
    Cr.call(this, e);
  }
  (xr.prototype = Object.create(mt.prototype)),
    (xr.prototype.constructor = xr),
    (xr.prototype.isMeshDepthMaterial = !0),
    (xr.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        (this.depthPacking = e.depthPacking),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        this
      );
    }),
    (_r.prototype = Object.create(mt.prototype)),
    (_r.prototype.constructor = _r),
    (_r.prototype.isMeshDistanceMaterial = !0),
    (_r.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        (this.nearDistance = e.nearDistance),
        (this.farDistance = e.farDistance),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        this
      );
    }),
    (Er.prototype = Object.assign(Object.create(mn.prototype), {
      constructor: Er,
      isArrayCamera: !0,
    })),
    (Tr.prototype = Object.assign(Object.create(je.prototype), {
      constructor: Tr,
      isGroup: !0,
    })),
    Object.assign(Ar.prototype, {
      constructor: Ar,
      getHandSpace: function () {
        if (
          null === this._hand &&
          ((this._hand = new Tr()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = []),
          (this._hand.inputState = { pinching: !1 }),
          window.XRHand)
        )
          for (let e = 0; e <= window.XRHand.LITTLE_PHALANX_TIP; e++) {
            const e = new Tr();
            (e.matrixAutoUpdate = !1),
              (e.visible = !1),
              this._hand.joints.push(e),
              this._hand.add(e);
          }
        return this._hand;
      },
      getTargetRaySpace: function () {
        return (
          null === this._targetRay &&
            ((this._targetRay = new Tr()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1)),
          this._targetRay
        );
      },
      getGripSpace: function () {
        return (
          null === this._grip &&
            ((this._grip = new Tr()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1)),
          this._grip
        );
      },
      dispatchEvent: function (e) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
        );
      },
      disconnect: function (e) {
        return (
          this.dispatchEvent({ type: "disconnected", data: e }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      },
      update: function (e, t, n) {
        let i = null,
          r = null,
          o = null;
        const s = this._targetRay,
          a = this._grip,
          c = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState)
          if (c && e.hand) {
            o = !0;
            for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
              if (e.hand[i]) {
                const r = t.getJointPose(e.hand[i], n),
                  o = c.joints[i];
                null !== r &&
                  (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  (o.jointRadius = r.radius)),
                  (o.visible = null !== r);
                const s = c.joints[window.XRHand.INDEX_PHALANX_TIP],
                  a = c.joints[window.XRHand.THUMB_PHALANX_TIP],
                  l = s.position.distanceTo(a.position),
                  h = 0.02,
                  u = 0.005;
                c.inputState.pinching && l > h + u
                  ? ((c.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: e.handedness,
                      target: this,
                    }))
                  : !c.inputState.pinching &&
                    l <= h - u &&
                    ((c.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: e.handedness,
                      target: this,
                    }));
              }
          } else
            null !== s &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null !== i &&
                (s.matrix.fromArray(i.transform.matrix),
                s.matrix.decompose(s.position, s.rotation, s.scale))),
              null !== a &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                null !== r &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale)));
        return (
          null !== s && (s.visible = null !== i),
          null !== a && (a.visible = null !== r),
          null !== c && (c.visible = null !== o),
          this
        );
      },
    }),
    Object.assign(Lr.prototype, C.prototype),
    (Pr.prototype = Object.assign(Object.create(Cr.prototype), {
      constructor: Pr,
      isWebGL1Renderer: !0,
    }));
  class Or {
    constructor(e, t, n) {
      Object.defineProperty(this, "isFog", { value: !0 }),
        (this.name = ""),
        (this.color = new dt(e)),
        (this.near = void 0 !== t ? t : 1),
        (this.far = void 0 !== n ? n : 1e3);
    }
    clone() {
      return new Or(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }
  }
  class Ir extends je {
    constructor() {
      super(),
        Object.defineProperty(this, "isScene", { value: !0 }),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        null !== e.background && (this.background = e.background.clone()),
        null !== e.environment && (this.environment = e.environment.clone()),
        null !== e.fog && (this.fog = e.fog.clone()),
        null !== e.overrideMaterial &&
          (this.overrideMaterial = e.overrideMaterial.clone()),
        (this.autoUpdate = e.autoUpdate),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this
      );
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        null !== this.background &&
          (t.object.background = this.background.toJSON(e)),
        null !== this.environment &&
          (t.object.environment = this.environment.toJSON(e)),
        null !== this.fog && (t.object.fog = this.fog.toJSON()),
        t
      );
    }
  }
  function Nr(e, t) {
    (this.array = e),
      (this.stride = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.usage = A),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = I.generateUUID());
  }
  Object.defineProperty(Nr.prototype, "needsUpdate", {
    set: function (e) {
      !0 === e && this.version++;
    },
  }),
    Object.assign(Nr.prototype, {
      isInterleavedBuffer: !0,
      onUploadCallback: function () {},
      setUsage: function (e) {
        return (this.usage = e), this;
      },
      copy: function (e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      },
      copyAt: function (e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let i = 0, r = this.stride; i < r; i++)
          this.array[e + i] = t.array[n + i];
        return this;
      },
      set: function (e, t = 0) {
        return this.array.set(e, t), this;
      },
      clone: function (e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = I.generateUUID()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        const t = new Nr(
          new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
          this.stride
        );
        return t.setUsage(this.usage), t;
      },
      onUpload: function (e) {
        return (this.onUploadCallback = e), this;
      },
      toJSON: function (e) {
        return (
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = I.generateUUID()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      },
    });
  const Dr = new W();
  function Fr(e, t, n, i) {
    (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = !0 === i);
  }
  function Ur(e) {
    mt.call(this),
      (this.type = "SpriteMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(e);
  }
  let kr;
  Object.defineProperties(Fr.prototype, {
    count: {
      get: function () {
        return this.data.count;
      },
    },
    array: {
      get: function () {
        return this.data.array;
      },
    },
    needsUpdate: {
      set: function (e) {
        this.data.needsUpdate = e;
      },
    },
  }),
    Object.assign(Fr.prototype, {
      isInterleavedBufferAttribute: !0,
      applyMatrix4: function (e) {
        for (let t = 0, n = this.data.count; t < n; t++)
          (Dr.x = this.getX(t)),
            (Dr.y = this.getY(t)),
            (Dr.z = this.getZ(t)),
            Dr.applyMatrix4(e),
            this.setXYZ(t, Dr.x, Dr.y, Dr.z);
        return this;
      },
      setX: function (e, t) {
        return (this.data.array[e * this.data.stride + this.offset] = t), this;
      },
      setY: function (e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 1] = t), this
        );
      },
      setZ: function (e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 2] = t), this
        );
      },
      setW: function (e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 3] = t), this
        );
      },
      getX: function (e) {
        return this.data.array[e * this.data.stride + this.offset];
      },
      getY: function (e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      },
      getZ: function (e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      },
      getW: function (e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      },
      setXY: function (e, t, n) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          this
        );
      },
      setXYZ: function (e, t, n, i) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          this
        );
      },
      setXYZW: function (e, t, n, i, r) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = i),
          (this.data.array[e + 3] = r),
          this
        );
      },
      clone: function (e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return new xt(
            new this.array.constructor(e),
            this.itemSize,
            this.normalized
          );
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new Fr(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
      },
      toJSON: function (e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: e,
            normalized: this.normalized,
          };
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      },
    }),
    (Ur.prototype = Object.create(mt.prototype)),
    (Ur.prototype.constructor = Ur),
    (Ur.prototype.isSpriteMaterial = !0),
    (Ur.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.rotation = e.rotation),
        (this.sizeAttenuation = e.sizeAttenuation),
        this
      );
    });
  const Br = new W(),
    zr = new W(),
    Hr = new W(),
    Gr = new N(),
    Vr = new N(),
    jr = new xe(),
    Wr = new W(),
    Xr = new W(),
    qr = new W(),
    Yr = new N(),
    Zr = new N(),
    Jr = new N();
  function Kr(e) {
    if ((je.call(this), (this.type = "Sprite"), void 0 === kr)) {
      kr = new Ht();
      const e = new Nr(
        new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        5
      );
      kr.setIndex([0, 1, 2, 0, 2, 3]),
        kr.setAttribute("position", new Fr(e, 3, 0, !1)),
        kr.setAttribute("uv", new Fr(e, 2, 3, !1));
    }
    (this.geometry = kr),
      (this.material = void 0 !== e ? e : new Ur()),
      (this.center = new N(0.5, 0.5));
  }
  function Qr(e, t, n, i, r, o) {
    Gr.subVectors(e, n).addScalar(0.5).multiply(i),
      void 0 !== r
        ? ((Vr.x = o * Gr.x - r * Gr.y), (Vr.y = r * Gr.x + o * Gr.y))
        : Vr.copy(Gr),
      e.copy(t),
      (e.x += Vr.x),
      (e.y += Vr.y),
      e.applyMatrix4(jr);
  }
  Kr.prototype = Object.assign(Object.create(je.prototype), {
    constructor: Kr,
    isSprite: !0,
    raycast: function (e, t) {
      null === e.camera &&
        console.error(
          'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
        ),
        zr.setFromMatrixScale(this.matrixWorld),
        jr.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(
          e.camera.matrixWorldInverse,
          this.matrixWorld
        ),
        Hr.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera &&
          !1 === this.material.sizeAttenuation &&
          zr.multiplyScalar(-Hr.z);
      const n = this.material.rotation;
      let i, r;
      0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
      const o = this.center;
      Qr(Wr.set(-0.5, -0.5, 0), Hr, o, zr, i, r),
        Qr(Xr.set(0.5, -0.5, 0), Hr, o, zr, i, r),
        Qr(qr.set(0.5, 0.5, 0), Hr, o, zr, i, r),
        Yr.set(0, 0),
        Zr.set(1, 0),
        Jr.set(1, 1);
      let s = e.ray.intersectTriangle(Wr, Xr, qr, !1, Br);
      if (
        null === s &&
        (Qr(Xr.set(-0.5, 0.5, 0), Hr, o, zr, i, r),
        Zr.set(0, 1),
        (s = e.ray.intersectTriangle(Wr, qr, Xr, !1, Br)),
        null === s)
      )
        return;
      const a = e.ray.origin.distanceTo(Br);
      a < e.near ||
        a > e.far ||
        t.push({
          distance: a,
          point: Br.clone(),
          uv: ot.getUV(Br, Wr, Xr, qr, Yr, Zr, Jr, new N()),
          face: null,
          object: this,
        });
    },
    copy: function (e) {
      return (
        je.prototype.copy.call(this, e),
        void 0 !== e.center && this.center.copy(e.center),
        (this.material = e.material),
        this
      );
    },
  });
  const $r = new W(),
    eo = new W();
  function to() {
    je.call(this),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0);
  }
  to.prototype = Object.assign(Object.create(je.prototype), {
    constructor: to,
    isLOD: !0,
    copy: function (e) {
      je.prototype.copy.call(this, e, !1);
      const t = e.levels;
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e];
        this.addLevel(n.object.clone(), n.distance);
      }
      return (this.autoUpdate = e.autoUpdate), this;
    },
    addLevel: function (e, t = 0) {
      t = Math.abs(t);
      const n = this.levels;
      let i;
      for (i = 0; i < n.length && !(t < n[i].distance); i++);
      return n.splice(i, 0, { distance: t, object: e }), this.add(e), this;
    },
    getCurrentLevel: function () {
      return this._currentLevel;
    },
    getObjectForDistance: function (e) {
      const t = this.levels;
      if (t.length > 0) {
        let n, i;
        for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
        return t[n - 1].object;
      }
      return null;
    },
    raycast: function (e, t) {
      if (this.levels.length > 0) {
        $r.setFromMatrixPosition(this.matrixWorld);
        const n = e.ray.origin.distanceTo($r);
        this.getObjectForDistance(n).raycast(e, t);
      }
    },
    update: function (e) {
      const t = this.levels;
      if (t.length > 1) {
        $r.setFromMatrixPosition(e.matrixWorld),
          eo.setFromMatrixPosition(this.matrixWorld);
        const n = $r.distanceTo(eo) / e.zoom;
        let i, r;
        for (
          t[0].object.visible = !0, i = 1, r = t.length;
          i < r && n >= t[i].distance;
          i++
        )
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        for (this._currentLevel = i - 1; i < r; i++) t[i].object.visible = !1;
      }
    },
    toJSON: function (e) {
      const t = je.prototype.toJSON.call(this, e);
      !1 === this.autoUpdate && (t.object.autoUpdate = !1),
        (t.object.levels = []);
      const n = this.levels;
      for (let e = 0, i = n.length; e < i; e++) {
        const i = n[e];
        t.object.levels.push({ object: i.object.uuid, distance: i.distance });
      }
      return t;
    },
  });
  const no = new W(),
    io = new H(),
    ro = new H(),
    oo = new W(),
    so = new xe();
  function ao(e, t) {
    e &&
      e.isGeometry &&
      console.error(
        "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
      ),
      sn.call(this, e, t),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new xe()),
      (this.bindMatrixInverse = new xe());
  }
  function co() {
    je.call(this), (this.type = "Bone");
  }
  (ao.prototype = Object.assign(Object.create(sn.prototype), {
    constructor: ao,
    isSkinnedMesh: !0,
    copy: function (e) {
      return (
        sn.prototype.copy.call(this, e),
        (this.bindMode = e.bindMode),
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        (this.skeleton = e.skeleton),
        this
      );
    },
    bind: function (e, t) {
      (this.skeleton = e),
        void 0 === t &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (t = this.matrixWorld)),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert();
    },
    pose: function () {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function () {
      const e = new H(),
        t = this.geometry.attributes.skinWeight;
      for (let n = 0, i = t.count; n < i; n++) {
        (e.x = t.getX(n)),
          (e.y = t.getY(n)),
          (e.z = t.getZ(n)),
          (e.w = t.getW(n));
        const i = 1 / e.manhattanLength();
        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
          t.setXYZW(n, e.x, e.y, e.z, e.w);
      }
    },
    updateMatrixWorld: function (e) {
      sn.prototype.updateMatrixWorld.call(this, e),
        "attached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    },
    boneTransform: function (e, t) {
      const n = this.skeleton,
        i = this.geometry;
      io.fromBufferAttribute(i.attributes.skinIndex, e),
        ro.fromBufferAttribute(i.attributes.skinWeight, e),
        no
          .fromBufferAttribute(i.attributes.position, e)
          .applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
      for (let e = 0; e < 4; e++) {
        const i = ro.getComponent(e);
        if (0 !== i) {
          const r = io.getComponent(e);
          so.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
            t.addScaledVector(oo.copy(no).applyMatrix4(so), i);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    },
  })),
    (co.prototype = Object.assign(Object.create(je.prototype), {
      constructor: co,
      isBone: !0,
    }));
  const lo = new xe(),
    ho = new xe();
  function uo(e = [], t = []) {
    (this.uuid = I.generateUUID()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  Object.assign(uo.prototype, {
    init: function () {
      const e = this.bones,
        t = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length)
      )
        this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let e = 0, t = this.bones.length; e < t; e++)
          this.boneInverses.push(new xe());
      }
    },
    calculateInverses: function () {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = new xe();
        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
          this.boneInverses.push(t);
      }
    },
    pose: function () {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = this.bones[e];
        t && t.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = this.bones[e];
        t &&
          (t.parent && t.parent.isBone
            ? (t.matrix.copy(t.parent.matrixWorld).invert(),
              t.matrix.multiply(t.matrixWorld))
            : t.matrix.copy(t.matrixWorld),
          t.matrix.decompose(t.position, t.quaternion, t.scale));
      }
    },
    update: function () {
      const e = this.bones,
        t = this.boneInverses,
        n = this.boneMatrices,
        i = this.boneTexture;
      for (let i = 0, r = e.length; i < r; i++) {
        const r = e[i] ? e[i].matrixWorld : ho;
        lo.multiplyMatrices(r, t[i]), lo.toArray(n, 16 * i);
      }
      null !== i && (i.needsUpdate = !0);
    },
    clone: function () {
      return new uo(this.bones, this.boneInverses);
    },
    getBoneByName: function (e) {
      for (let t = 0, n = this.bones.length; t < n; t++) {
        const n = this.bones[t];
        if (n.name === e) return n;
      }
    },
    dispose: function () {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    },
    fromJSON: function (e, t) {
      this.uuid = e.uuid;
      for (let n = 0, i = e.bones.length; n < i; n++) {
        const i = e.bones[n];
        let r = t[i];
        void 0 === r &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", i),
          (r = new co())),
          this.bones.push(r),
          this.boneInverses.push(new xe().fromArray(e.boneInverses[n]));
      }
      return this.init(), this;
    },
    toJSON: function () {
      const e = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      e.uuid = this.uuid;
      const t = this.bones,
        n = this.boneInverses;
      for (let i = 0, r = t.length; i < r; i++) {
        const r = t[i];
        e.bones.push(r.uuid);
        const o = n[i];
        e.boneInverses.push(o.toArray());
      }
      return e;
    },
  });
  const po = new xe(),
    fo = new xe(),
    mo = [],
    go = new sn();
  function vo(e, t, n) {
    sn.call(this, e, t),
      (this.instanceMatrix = new xt(new Float32Array(16 * n), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.frustumCulled = !1);
  }
  function yo(e) {
    mt.call(this),
      (this.type = "LineBasicMaterial"),
      (this.color = new dt(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.morphTargets = !1),
      this.setValues(e);
  }
  (vo.prototype = Object.assign(Object.create(sn.prototype), {
    constructor: vo,
    isInstancedMesh: !0,
    copy: function (e) {
      return (
        sn.prototype.copy.call(this, e),
        this.instanceMatrix.copy(e.instanceMatrix),
        (this.count = e.count),
        this
      );
    },
    getColorAt: function (e, t) {
      t.fromArray(this.instanceColor.array, 3 * e);
    },
    getMatrixAt: function (e, t) {
      t.fromArray(this.instanceMatrix.array, 16 * e);
    },
    raycast: function (e, t) {
      const n = this.matrixWorld,
        i = this.count;
      if (
        ((go.geometry = this.geometry),
        (go.material = this.material),
        void 0 !== go.material)
      )
        for (let r = 0; r < i; r++) {
          this.getMatrixAt(r, po),
            fo.multiplyMatrices(n, po),
            (go.matrixWorld = fo),
            go.raycast(e, mo);
          for (let e = 0, n = mo.length; e < n; e++) {
            const n = mo[e];
            (n.instanceId = r), (n.object = this), t.push(n);
          }
          mo.length = 0;
        }
    },
    setColorAt: function (e, t) {
      null === this.instanceColor &&
        (this.instanceColor = new xt(new Float32Array(3 * this.count), 3)),
        t.toArray(this.instanceColor.array, 3 * e);
    },
    setMatrixAt: function (e, t) {
      t.toArray(this.instanceMatrix.array, 16 * e);
    },
    updateMorphTargets: function () {},
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    (yo.prototype = Object.create(mt.prototype)),
    (yo.prototype.constructor = yo),
    (yo.prototype.isLineBasicMaterial = !0),
    (yo.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.linewidth = e.linewidth),
        (this.linecap = e.linecap),
        (this.linejoin = e.linejoin),
        (this.morphTargets = e.morphTargets),
        this
      );
    });
  const xo = new W(),
    _o = new W(),
    bo = new xe(),
    wo = new ye(),
    Mo = new he();
  function So(e = new Ht(), t = new yo()) {
    je.call(this),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  So.prototype = Object.assign(Object.create(je.prototype), {
    constructor: So,
    isLine: !0,
    copy: function (e) {
      return (
        je.prototype.copy.call(this, e),
        (this.material = e.material),
        (this.geometry = e.geometry),
        this
      );
    },
    computeLineDistances: function () {
      const e = this.geometry;
      if (e.isBufferGeometry)
        if (null === e.index) {
          const t = e.attributes.position,
            n = [0];
          for (let e = 1, i = t.count; e < i; e++)
            xo.fromBufferAttribute(t, e - 1),
              _o.fromBufferAttribute(t, e),
              (n[e] = n[e - 1]),
              (n[e] += xo.distanceTo(_o));
          e.setAttribute("lineDistance", new Lt(n, 1));
        } else
          console.warn(
            "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else if (e.isGeometry) {
        const t = e.vertices,
          n = e.lineDistances;
        n[0] = 0;
        for (let e = 1, i = t.length; e < i; e++)
          (n[e] = n[e - 1]), (n[e] += t[e - 1].distanceTo(t[e]));
      }
      return this;
    },
    raycast: function (e, t) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = e.params.Line.threshold;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        Mo.copy(n.boundingSphere),
        Mo.applyMatrix4(i),
        (Mo.radius += r),
        !1 === e.ray.intersectsSphere(Mo))
      )
        return;
      bo.copy(i).invert(), wo.copy(e.ray).applyMatrix4(bo);
      const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        s = o * o,
        a = new W(),
        c = new W(),
        l = new W(),
        h = new W(),
        u = this.isLineSegments ? 2 : 1;
      if (n.isBufferGeometry) {
        const i = n.index,
          r = n.attributes.position;
        if (null !== i) {
          const n = i.array;
          for (let i = 0, o = n.length - 1; i < o; i += u) {
            const o = n[i],
              u = n[i + 1];
            if (
              (a.fromBufferAttribute(r, o),
              c.fromBufferAttribute(r, u),
              wo.distanceSqToSegment(a, c, h, l) > s)
            )
              continue;
            h.applyMatrix4(this.matrixWorld);
            const d = e.ray.origin.distanceTo(h);
            d < e.near ||
              d > e.far ||
              t.push({
                distance: d,
                point: l.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
        } else
          for (let n = 0, i = r.count - 1; n < i; n += u) {
            if (
              (a.fromBufferAttribute(r, n),
              c.fromBufferAttribute(r, n + 1),
              wo.distanceSqToSegment(a, c, h, l) > s)
            )
              continue;
            h.applyMatrix4(this.matrixWorld);
            const i = e.ray.origin.distanceTo(h);
            i < e.near ||
              i > e.far ||
              t.push({
                distance: i,
                point: l.clone().applyMatrix4(this.matrixWorld),
                index: n,
                face: null,
                faceIndex: null,
                object: this,
              });
          }
      } else if (n.isGeometry) {
        const i = n.vertices,
          r = i.length;
        for (let n = 0; n < r - 1; n += u) {
          if (wo.distanceSqToSegment(i[n], i[n + 1], h, l) > s) continue;
          h.applyMatrix4(this.matrixWorld);
          const r = e.ray.origin.distanceTo(h);
          r < e.near ||
            r > e.far ||
            t.push({
              distance: r,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    },
    updateMorphTargets: function () {
      const e = this.geometry;
      if (e.isBufferGeometry) {
        const t = e.morphAttributes,
          n = Object.keys(t);
        if (n.length > 0) {
          const e = t[n[0]];
          if (void 0 !== e) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t].name || String(t);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[n] = t);
            }
          }
        }
      } else {
        const t = e.morphTargets;
        void 0 !== t &&
          t.length > 0 &&
          console.error(
            "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    },
  });
  const Eo = new W(),
    To = new W();
  function Ao(e, t) {
    So.call(this, e, t), (this.type = "LineSegments");
  }
  function Lo(e, t) {
    So.call(this, e, t), (this.type = "LineLoop");
  }
  function Ro(e) {
    mt.call(this),
      (this.type = "PointsMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.morphTargets = !1),
      this.setValues(e);
  }
  (Ao.prototype = Object.assign(Object.create(So.prototype), {
    constructor: Ao,
    isLineSegments: !0,
    computeLineDistances: function () {
      const e = this.geometry;
      if (e.isBufferGeometry)
        if (null === e.index) {
          const t = e.attributes.position,
            n = [];
          for (let e = 0, i = t.count; e < i; e += 2)
            Eo.fromBufferAttribute(t, e),
              To.fromBufferAttribute(t, e + 1),
              (n[e] = 0 === e ? 0 : n[e - 1]),
              (n[e + 1] = n[e] + Eo.distanceTo(To));
          e.setAttribute("lineDistance", new Lt(n, 1));
        } else
          console.warn(
            "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
          );
      else if (e.isGeometry) {
        const t = e.vertices,
          n = e.lineDistances;
        for (let e = 0, i = t.length; e < i; e += 2)
          Eo.copy(t[e]),
            To.copy(t[e + 1]),
            (n[e] = 0 === e ? 0 : n[e - 1]),
            (n[e + 1] = n[e] + Eo.distanceTo(To));
      }
      return this;
    },
  })),
    (Lo.prototype = Object.assign(Object.create(So.prototype), {
      constructor: Lo,
      isLineLoop: !0,
    })),
    (Ro.prototype = Object.create(mt.prototype)),
    (Ro.prototype.constructor = Ro),
    (Ro.prototype.isPointsMaterial = !0),
    (Ro.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.size = e.size),
        (this.sizeAttenuation = e.sizeAttenuation),
        (this.morphTargets = e.morphTargets),
        this
      );
    });
  const Co = new xe(),
    Po = new ye(),
    Oo = new he(),
    Io = new W();
  function No(e = new Ht(), t = new Ro()) {
    je.call(this),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  function Do(e, t, n, i, r, o, s) {
    const a = Po.distanceSqToPoint(e);
    if (a < n) {
      const n = new W();
      Po.closestPointToPoint(e, n), n.applyMatrix4(i);
      const c = r.ray.origin.distanceTo(n);
      if (c < r.near || c > r.far) return;
      o.push({
        distance: c,
        distanceToRay: Math.sqrt(a),
        point: n,
        index: t,
        face: null,
        object: s,
      });
    }
  }
  function Fo(e, t, n, i, r, o, s, c, l) {
    B.call(this, e, t, n, i, r, o, s, c, l),
      (this.format = void 0 !== s ? s : f),
      (this.minFilter = void 0 !== o ? o : a),
      (this.magFilter = void 0 !== r ? r : a),
      (this.generateMipmaps = !1);
    const h = this;
    "requestVideoFrameCallback" in e &&
      e.requestVideoFrameCallback(function t() {
        (h.needsUpdate = !0), e.requestVideoFrameCallback(t);
      });
  }
  function Uo(e, t, n, i, r, o, s, a, c, l, h, u) {
    B.call(this, null, o, s, a, c, l, i, r, h, u),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  function ko(e, t, n, i, r, o, s, a, c) {
    B.call(this, e, t, n, i, r, o, s, a, c), (this.needsUpdate = !0);
  }
  function Bo(e, t, n, i, o, s, a, c, h, u) {
    if ((u = void 0 !== u ? u : g) !== g && u !== v)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    void 0 === n && u === g && (n = l),
      void 0 === n && u === v && (n = p),
      B.call(this, null, i, o, s, a, c, u, n, h),
      (this.image = { width: e, height: t }),
      (this.magFilter = void 0 !== a ? a : r),
      (this.minFilter = void 0 !== c ? c : r),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  (No.prototype = Object.assign(Object.create(je.prototype), {
    constructor: No,
    isPoints: !0,
    copy: function (e) {
      return (
        je.prototype.copy.call(this, e),
        (this.material = e.material),
        (this.geometry = e.geometry),
        this
      );
    },
    raycast: function (e, t) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = e.params.Points.threshold;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        Oo.copy(n.boundingSphere),
        Oo.applyMatrix4(i),
        (Oo.radius += r),
        !1 === e.ray.intersectsSphere(Oo))
      )
        return;
      Co.copy(i).invert(), Po.copy(e.ray).applyMatrix4(Co);
      const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        s = o * o;
      if (n.isBufferGeometry) {
        const r = n.index,
          o = n.attributes.position;
        if (null !== r) {
          const n = r.array;
          for (let r = 0, a = n.length; r < a; r++) {
            const a = n[r];
            Io.fromBufferAttribute(o, a), Do(Io, a, s, i, e, t, this);
          }
        } else
          for (let n = 0, r = o.count; n < r; n++)
            Io.fromBufferAttribute(o, n), Do(Io, n, s, i, e, t, this);
      } else {
        const r = n.vertices;
        for (let n = 0, o = r.length; n < o; n++) Do(r[n], n, s, i, e, t, this);
      }
    },
    updateMorphTargets: function () {
      const e = this.geometry;
      if (e.isBufferGeometry) {
        const t = e.morphAttributes,
          n = Object.keys(t);
        if (n.length > 0) {
          const e = t[n[0]];
          if (void 0 !== e) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t].name || String(t);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[n] = t);
            }
          }
        }
      } else {
        const t = e.morphTargets;
        void 0 !== t &&
          t.length > 0 &&
          console.error(
            "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
    },
  })),
    (Fo.prototype = Object.assign(Object.create(B.prototype), {
      constructor: Fo,
      clone: function () {
        return new this.constructor(this.image).copy(this);
      },
      isVideoTexture: !0,
      update: function () {
        const e = this.image;
        !1 == "requestVideoFrameCallback" in e &&
          e.readyState >= e.HAVE_CURRENT_DATA &&
          (this.needsUpdate = !0);
      },
    })),
    (Uo.prototype = Object.create(B.prototype)),
    (Uo.prototype.constructor = Uo),
    (Uo.prototype.isCompressedTexture = !0),
    (ko.prototype = Object.create(B.prototype)),
    (ko.prototype.constructor = ko),
    (ko.prototype.isCanvasTexture = !0),
    (Bo.prototype = Object.create(B.prototype)),
    (Bo.prototype.constructor = Bo),
    (Bo.prototype.isDepthTexture = !0);
  let zo = 0;
  const Ho = new xe(),
    Go = new je(),
    Vo = new W();
  function jo() {
    Object.defineProperty(this, "id", { value: (zo += 2) }),
      (this.uuid = I.generateUUID()),
      (this.name = ""),
      (this.type = "Geometry"),
      (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.elementsNeedUpdate = !1),
      (this.verticesNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.lineDistancesNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  (jo.prototype = Object.assign(Object.create(C.prototype), {
    constructor: jo,
    isGeometry: !0,
    applyMatrix4: function (e) {
      const t = new D().getNormalMatrix(e);
      for (let t = 0, n = this.vertices.length; t < n; t++)
        this.vertices[t].applyMatrix4(e);
      for (let e = 0, n = this.faces.length; e < n; e++) {
        const n = this.faces[e];
        n.normal.applyMatrix3(t).normalize();
        for (let e = 0, i = n.vertexNormals.length; e < i; e++)
          n.vertexNormals[e].applyMatrix3(t).normalize();
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    },
    rotateX: function (e) {
      return Ho.makeRotationX(e), this.applyMatrix4(Ho), this;
    },
    rotateY: function (e) {
      return Ho.makeRotationY(e), this.applyMatrix4(Ho), this;
    },
    rotateZ: function (e) {
      return Ho.makeRotationZ(e), this.applyMatrix4(Ho), this;
    },
    translate: function (e, t, n) {
      return Ho.makeTranslation(e, t, n), this.applyMatrix4(Ho), this;
    },
    scale: function (e, t, n) {
      return Ho.makeScale(e, t, n), this.applyMatrix4(Ho), this;
    },
    lookAt: function (e) {
      return (
        Go.lookAt(e), Go.updateMatrix(), this.applyMatrix4(Go.matrix), this
      );
    },
    fromBufferGeometry: function (e) {
      const t = this,
        n = null !== e.index ? e.index : void 0,
        i = e.attributes;
      if (void 0 === i.position)
        return (
          console.error(
            "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
          ),
          this
        );
      const r = i.position,
        o = i.normal,
        s = i.color,
        a = i.uv,
        c = i.uv2;
      void 0 !== c && (this.faceVertexUvs[1] = []);
      for (let e = 0; e < r.count; e++)
        t.vertices.push(new W().fromBufferAttribute(r, e)),
          void 0 !== s && t.colors.push(new dt().fromBufferAttribute(s, e));
      function l(e, n, i, r) {
        const l =
            void 0 === s
              ? []
              : [t.colors[e].clone(), t.colors[n].clone(), t.colors[i].clone()],
          h =
            void 0 === o
              ? []
              : [
                  new W().fromBufferAttribute(o, e),
                  new W().fromBufferAttribute(o, n),
                  new W().fromBufferAttribute(o, i),
                ],
          u = new pt(e, n, i, h, l, r);
        t.faces.push(u),
          void 0 !== a &&
            t.faceVertexUvs[0].push([
              new N().fromBufferAttribute(a, e),
              new N().fromBufferAttribute(a, n),
              new N().fromBufferAttribute(a, i),
            ]),
          void 0 !== c &&
            t.faceVertexUvs[1].push([
              new N().fromBufferAttribute(c, e),
              new N().fromBufferAttribute(c, n),
              new N().fromBufferAttribute(c, i),
            ]);
      }
      const h = e.groups;
      if (h.length > 0)
        for (let e = 0; e < h.length; e++) {
          const t = h[e],
            i = t.start;
          for (let e = i, r = i + t.count; e < r; e += 3)
            void 0 !== n
              ? l(n.getX(e), n.getX(e + 1), n.getX(e + 2), t.materialIndex)
              : l(e, e + 1, e + 2, t.materialIndex);
        }
      else if (void 0 !== n)
        for (let e = 0; e < n.count; e += 3)
          l(n.getX(e), n.getX(e + 1), n.getX(e + 2));
      else for (let e = 0; e < r.count; e += 3) l(e, e + 1, e + 2);
      return (
        this.computeFaceNormals(),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
        this
      );
    },
    center: function () {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Vo).negate(),
        this.translate(Vo.x, Vo.y, Vo.z),
        this
      );
    },
    normalize: function () {
      this.computeBoundingSphere();
      const e = this.boundingSphere.center,
        t = this.boundingSphere.radius,
        n = 0 === t ? 1 : 1 / t,
        i = new xe();
      return (
        i.set(
          n,
          0,
          0,
          -n * e.x,
          0,
          n,
          0,
          -n * e.y,
          0,
          0,
          n,
          -n * e.z,
          0,
          0,
          0,
          1
        ),
        this.applyMatrix4(i),
        this
      );
    },
    computeFaceNormals: function () {
      const e = new W(),
        t = new W();
      for (let n = 0, i = this.faces.length; n < i; n++) {
        const i = this.faces[n],
          r = this.vertices[i.a],
          o = this.vertices[i.b],
          s = this.vertices[i.c];
        e.subVectors(s, o),
          t.subVectors(r, o),
          e.cross(t),
          e.normalize(),
          i.normal.copy(e);
      }
    },
    computeVertexNormals: function (e = !0) {
      const t = new Array(this.vertices.length);
      for (let e = 0, n = this.vertices.length; e < n; e++) t[e] = new W();
      if (e) {
        const e = new W(),
          n = new W();
        for (let i = 0, r = this.faces.length; i < r; i++) {
          const r = this.faces[i],
            o = this.vertices[r.a],
            s = this.vertices[r.b],
            a = this.vertices[r.c];
          e.subVectors(a, s),
            n.subVectors(o, s),
            e.cross(n),
            t[r.a].add(e),
            t[r.b].add(e),
            t[r.c].add(e);
        }
      } else {
        this.computeFaceNormals();
        for (let e = 0, n = this.faces.length; e < n; e++) {
          const n = this.faces[e];
          t[n.a].add(n.normal), t[n.b].add(n.normal), t[n.c].add(n.normal);
        }
      }
      for (let e = 0, n = this.vertices.length; e < n; e++) t[e].normalize();
      for (let e = 0, n = this.faces.length; e < n; e++) {
        const n = this.faces[e],
          i = n.vertexNormals;
        3 === i.length
          ? (i[0].copy(t[n.a]), i[1].copy(t[n.b]), i[2].copy(t[n.c]))
          : ((i[0] = t[n.a].clone()),
            (i[1] = t[n.b].clone()),
            (i[2] = t[n.c].clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function () {
      this.computeFaceNormals();
      for (let e = 0, t = this.faces.length; e < t; e++) {
        const t = this.faces[e],
          n = t.vertexNormals;
        3 === n.length
          ? (n[0].copy(t.normal), n[1].copy(t.normal), n[2].copy(t.normal))
          : ((n[0] = t.normal.clone()),
            (n[1] = t.normal.clone()),
            (n[2] = t.normal.clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function () {
      for (let e = 0, t = this.faces.length; e < t; e++) {
        const t = this.faces[e];
        t.__originalFaceNormal
          ? t.__originalFaceNormal.copy(t.normal)
          : (t.__originalFaceNormal = t.normal.clone()),
          t.__originalVertexNormals || (t.__originalVertexNormals = []);
        for (let e = 0, n = t.vertexNormals.length; e < n; e++)
          t.__originalVertexNormals[e]
            ? t.__originalVertexNormals[e].copy(t.vertexNormals[e])
            : (t.__originalVertexNormals[e] = t.vertexNormals[e].clone());
      }
      const e = new jo();
      e.faces = this.faces;
      for (let t = 0, n = this.morphTargets.length; t < n; t++) {
        if (!this.morphNormals[t]) {
          (this.morphNormals[t] = {}),
            (this.morphNormals[t].faceNormals = []),
            (this.morphNormals[t].vertexNormals = []);
          const e = this.morphNormals[t].faceNormals,
            n = this.morphNormals[t].vertexNormals;
          for (let t = 0, i = this.faces.length; t < i; t++) {
            const t = new W(),
              i = { a: new W(), b: new W(), c: new W() };
            e.push(t), n.push(i);
          }
        }
        const n = this.morphNormals[t];
        (e.vertices = this.morphTargets[t].vertices),
          e.computeFaceNormals(),
          e.computeVertexNormals();
        for (let e = 0, t = this.faces.length; e < t; e++) {
          const t = this.faces[e],
            i = n.faceNormals[e],
            r = n.vertexNormals[e];
          i.copy(t.normal),
            r.a.copy(t.vertexNormals[0]),
            r.b.copy(t.vertexNormals[1]),
            r.c.copy(t.vertexNormals[2]);
        }
      }
      for (let e = 0, t = this.faces.length; e < t; e++) {
        const t = this.faces[e];
        (t.normal = t.__originalFaceNormal),
          (t.vertexNormals = t.__originalVertexNormals);
      }
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Y()),
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new he()),
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function (e, t, n = 0) {
      if (!e || !e.isGeometry)
        return void console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          e
        );
      let i;
      const r = this.vertices.length,
        o = this.vertices,
        s = e.vertices,
        a = this.faces,
        c = e.faces,
        l = this.colors,
        h = e.colors;
      void 0 !== t && (i = new D().getNormalMatrix(t));
      for (let e = 0, n = s.length; e < n; e++) {
        const n = s[e].clone();
        void 0 !== t && n.applyMatrix4(t), o.push(n);
      }
      for (let e = 0, t = h.length; e < t; e++) l.push(h[e].clone());
      for (let e = 0, t = c.length; e < t; e++) {
        const t = c[e];
        let o, s;
        const l = t.vertexNormals,
          h = t.vertexColors,
          u = new pt(t.a + r, t.b + r, t.c + r);
        u.normal.copy(t.normal),
          void 0 !== i && u.normal.applyMatrix3(i).normalize();
        for (let e = 0, t = l.length; e < t; e++)
          (o = l[e].clone()),
            void 0 !== i && o.applyMatrix3(i).normalize(),
            u.vertexNormals.push(o);
        u.color.copy(t.color);
        for (let e = 0, t = h.length; e < t; e++)
          (s = h[e]), u.vertexColors.push(s.clone());
        (u.materialIndex = t.materialIndex + n), a.push(u);
      }
      for (let t = 0, n = e.faceVertexUvs.length; t < n; t++) {
        const n = e.faceVertexUvs[t];
        void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
        for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e],
            r = [];
          for (let e = 0, t = i.length; e < t; e++) r.push(i[e].clone());
          this.faceVertexUvs[t].push(r);
        }
      }
    },
    mergeMesh: function (e) {
      e && e.isMesh
        ? (e.matrixAutoUpdate && e.updateMatrix(),
          this.merge(e.geometry, e.matrix))
        : console.error(
            "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
            e
          );
    },
    mergeVertices: function (e = 4) {
      const t = {},
        n = [],
        i = [],
        r = Math.pow(10, e);
      for (let e = 0, o = this.vertices.length; e < o; e++) {
        const o = this.vertices[e],
          s =
            Math.round(o.x * r) +
            "_" +
            Math.round(o.y * r) +
            "_" +
            Math.round(o.z * r);
        void 0 === t[s]
          ? ((t[s] = e), n.push(this.vertices[e]), (i[e] = n.length - 1))
          : (i[e] = i[t[s]]);
      }
      const o = [];
      for (let e = 0, t = this.faces.length; e < t; e++) {
        const t = this.faces[e];
        (t.a = i[t.a]), (t.b = i[t.b]), (t.c = i[t.c]);
        const n = [t.a, t.b, t.c];
        for (let t = 0; t < 3; t++)
          if (n[t] === n[(t + 1) % 3]) {
            o.push(e);
            break;
          }
      }
      for (let e = o.length - 1; e >= 0; e--) {
        const t = o[e];
        this.faces.splice(t, 1);
        for (let e = 0, n = this.faceVertexUvs.length; e < n; e++)
          this.faceVertexUvs[e].splice(t, 1);
      }
      const s = this.vertices.length - n.length;
      return (this.vertices = n), s;
    },
    setFromPoints: function (e) {
      this.vertices = [];
      for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        this.vertices.push(new W(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function () {
      const e = this.faces,
        t = e.length;
      for (let n = 0; n < t; n++) e[n]._id = n;
      e.sort(function (e, t) {
        return e.materialIndex - t.materialIndex;
      });
      const n = this.faceVertexUvs[0],
        i = this.faceVertexUvs[1];
      let r, o;
      n && n.length === t && (r = []), i && i.length === t && (o = []);
      for (let s = 0; s < t; s++) {
        const t = e[s]._id;
        r && r.push(n[t]), o && o.push(i[t]);
      }
      r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
    },
    toJSON: function () {
      const e = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON",
        },
      };
      if (
        ((e.uuid = this.uuid),
        (e.type = this.type),
        "" !== this.name && (e.name = this.name),
        void 0 !== this.parameters)
      ) {
        const t = this.parameters;
        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
        return e;
      }
      const t = [];
      for (let e = 0; e < this.vertices.length; e++) {
        const n = this.vertices[e];
        t.push(n.x, n.y, n.z);
      }
      const n = [],
        i = [],
        r = {},
        o = [],
        s = {},
        a = [],
        c = {};
      for (let e = 0; e < this.faces.length; e++) {
        const t = this.faces[e],
          i = !0,
          r = !1,
          o = void 0 !== this.faceVertexUvs[0][e],
          s = t.normal.length() > 0,
          a = t.vertexNormals.length > 0,
          c = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b,
          p = t.vertexColors.length > 0;
        let f = 0;
        if (
          ((f = l(f, 0, 0)),
          (f = l(f, 1, i)),
          (f = l(f, 2, r)),
          (f = l(f, 3, o)),
          (f = l(f, 4, s)),
          (f = l(f, 5, a)),
          (f = l(f, 6, c)),
          (f = l(f, 7, p)),
          n.push(f),
          n.push(t.a, t.b, t.c),
          n.push(t.materialIndex),
          o)
        ) {
          const t = this.faceVertexUvs[0][e];
          n.push(d(t[0]), d(t[1]), d(t[2]));
        }
        if ((s && n.push(h(t.normal)), a)) {
          const e = t.vertexNormals;
          n.push(h(e[0]), h(e[1]), h(e[2]));
        }
        if ((c && n.push(u(t.color)), p)) {
          const e = t.vertexColors;
          n.push(u(e[0]), u(e[1]), u(e[2]));
        }
      }
      function l(e, t, n) {
        return n ? e | (1 << t) : e & ~(1 << t);
      }
      function h(e) {
        const t = e.x.toString() + e.y.toString() + e.z.toString();
        return (
          void 0 !== r[t] || ((r[t] = i.length / 3), i.push(e.x, e.y, e.z)),
          r[t]
        );
      }
      function u(e) {
        const t = e.r.toString() + e.g.toString() + e.b.toString();
        return void 0 !== s[t] || ((s[t] = o.length), o.push(e.getHex())), s[t];
      }
      function d(e) {
        const t = e.x.toString() + e.y.toString();
        return (
          void 0 !== c[t] || ((c[t] = a.length / 2), a.push(e.x, e.y)), c[t]
        );
      }
      return (
        (e.data = {}),
        (e.data.vertices = t),
        (e.data.normals = i),
        o.length > 0 && (e.data.colors = o),
        a.length > 0 && (e.data.uvs = [a]),
        (e.data.faces = n),
        e
      );
    },
    clone: function () {
      return new jo().copy(this);
    },
    copy: function (e) {
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = e.name);
      const t = e.vertices;
      for (let e = 0, n = t.length; e < n; e++)
        this.vertices.push(t[e].clone());
      const n = e.colors;
      for (let e = 0, t = n.length; e < t; e++) this.colors.push(n[e].clone());
      const i = e.faces;
      for (let e = 0, t = i.length; e < t; e++) this.faces.push(i[e].clone());
      for (let t = 0, n = e.faceVertexUvs.length; t < n; t++) {
        const n = e.faceVertexUvs[t];
        void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []);
        for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e],
            r = [];
          for (let e = 0, t = i.length; e < t; e++) {
            const t = i[e];
            r.push(t.clone());
          }
          this.faceVertexUvs[t].push(r);
        }
      }
      const r = e.morphTargets;
      for (let e = 0, t = r.length; e < t; e++) {
        const t = {};
        if (((t.name = r[e].name), void 0 !== r[e].vertices)) {
          t.vertices = [];
          for (let n = 0, i = r[e].vertices.length; n < i; n++)
            t.vertices.push(r[e].vertices[n].clone());
        }
        if (void 0 !== r[e].normals) {
          t.normals = [];
          for (let n = 0, i = r[e].normals.length; n < i; n++)
            t.normals.push(r[e].normals[n].clone());
        }
        this.morphTargets.push(t);
      }
      const o = e.morphNormals;
      for (let e = 0, t = o.length; e < t; e++) {
        const t = {};
        if (void 0 !== o[e].vertexNormals) {
          t.vertexNormals = [];
          for (let n = 0, i = o[e].vertexNormals.length; n < i; n++) {
            const i = o[e].vertexNormals[n],
              r = {};
            (r.a = i.a.clone()),
              (r.b = i.b.clone()),
              (r.c = i.c.clone()),
              t.vertexNormals.push(r);
          }
        }
        if (void 0 !== o[e].faceNormals) {
          t.faceNormals = [];
          for (let n = 0, i = o[e].faceNormals.length; n < i; n++)
            t.faceNormals.push(o[e].faceNormals[n].clone());
        }
        this.morphNormals.push(t);
      }
      const s = e.skinWeights;
      for (let e = 0, t = s.length; e < t; e++)
        this.skinWeights.push(s[e].clone());
      const a = e.skinIndices;
      for (let e = 0, t = a.length; e < t; e++)
        this.skinIndices.push(a[e].clone());
      const c = e.lineDistances;
      for (let e = 0, t = c.length; e < t; e++) this.lineDistances.push(c[e]);
      const l = e.boundingBox;
      null !== l && (this.boundingBox = l.clone());
      const h = e.boundingSphere;
      return (
        null !== h && (this.boundingSphere = h.clone()),
        (this.elementsNeedUpdate = e.elementsNeedUpdate),
        (this.verticesNeedUpdate = e.verticesNeedUpdate),
        (this.uvsNeedUpdate = e.uvsNeedUpdate),
        (this.normalsNeedUpdate = e.normalsNeedUpdate),
        (this.colorsNeedUpdate = e.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = e.groupsNeedUpdate),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    new W(),
    new W(),
    new W(),
    new ot();
  function Wo(e, t, n, i, r) {
    let o, s;
    if (
      r ===
      (function (e, t, n, i) {
        let r = 0;
        for (let o = t, s = n - i; o < n; o += i)
          (r += (e[s] - e[o]) * (e[o + 1] + e[s + 1])), (s = o);
        return r;
      })(e, t, n, i) >
        0
    )
      for (o = t; o < n; o += i) s = ds(o, e[o], e[o + 1], s);
    else for (o = n - i; o >= t; o -= i) s = ds(o, e[o], e[o + 1], s);
    return s && ss(s, s.next) && (ps(s), (s = s.next)), s;
  }
  function Xo(e, t) {
    if (!e) return e;
    t || (t = e);
    let n,
      i = e;
    do {
      if (
        ((n = !1), i.steiner || (!ss(i, i.next) && 0 !== os(i.prev, i, i.next)))
      )
        i = i.next;
      else {
        if ((ps(i), (i = t = i.prev), i === i.next)) break;
        n = !0;
      }
    } while (n || i !== t);
    return t;
  }
  function qo(e, t, n, i, r, o, s) {
    if (!e) return;
    !s &&
      o &&
      (function (e, t, n, i) {
        let r = e;
        do {
          null === r.z && (r.z = ts(r.x, r.y, t, n, i)),
            (r.prevZ = r.prev),
            (r.nextZ = r.next),
            (r = r.next);
        } while (r !== e);
        (r.prevZ.nextZ = null),
          (r.prevZ = null),
          (function (e) {
            let t,
              n,
              i,
              r,
              o,
              s,
              a,
              c,
              l = 1;
            do {
              for (n = e, e = null, o = null, s = 0; n; ) {
                for (
                  s++, i = n, a = 0, t = 0;
                  t < l && (a++, (i = i.nextZ), i);
                  t++
                );
                for (c = l; a > 0 || (c > 0 && i); )
                  0 !== a && (0 === c || !i || n.z <= i.z)
                    ? ((r = n), (n = n.nextZ), a--)
                    : ((r = i), (i = i.nextZ), c--),
                    o ? (o.nextZ = r) : (e = r),
                    (r.prevZ = o),
                    (o = r);
                n = i;
              }
              (o.nextZ = null), (l *= 2);
            } while (s > 1);
          })(r);
      })(e, i, r, o);
    let a,
      c,
      l = e;
    for (; e.prev !== e.next; )
      if (((a = e.prev), (c = e.next), o ? Zo(e, i, r, o) : Yo(e)))
        t.push(a.i / n),
          t.push(e.i / n),
          t.push(c.i / n),
          ps(e),
          (e = c.next),
          (l = c.next);
      else if ((e = c) === l) {
        s
          ? 1 === s
            ? qo((e = Jo(Xo(e), t, n)), t, n, i, r, o, 2)
            : 2 === s && Ko(e, t, n, i, r, o)
          : qo(Xo(e), t, n, i, r, o, 1);
        break;
      }
  }
  function Yo(e) {
    const t = e.prev,
      n = e,
      i = e.next;
    if (os(t, n, i) >= 0) return !1;
    let r = e.next.next;
    for (; r !== e.prev; ) {
      if (
        is(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
        os(r.prev, r, r.next) >= 0
      )
        return !1;
      r = r.next;
    }
    return !0;
  }
  function Zo(e, t, n, i) {
    const r = e.prev,
      o = e,
      s = e.next;
    if (os(r, o, s) >= 0) return !1;
    const a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
      c = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
      l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
      h = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
      u = ts(a, c, t, n, i),
      d = ts(l, h, t, n, i);
    let p = e.prevZ,
      f = e.nextZ;
    for (; p && p.z >= u && f && f.z <= d; ) {
      if (
        p !== e.prev &&
        p !== e.next &&
        is(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
        os(p.prev, p, p.next) >= 0
      )
        return !1;
      if (
        ((p = p.prevZ),
        f !== e.prev &&
          f !== e.next &&
          is(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
          os(f.prev, f, f.next) >= 0)
      )
        return !1;
      f = f.nextZ;
    }
    for (; p && p.z >= u; ) {
      if (
        p !== e.prev &&
        p !== e.next &&
        is(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
        os(p.prev, p, p.next) >= 0
      )
        return !1;
      p = p.prevZ;
    }
    for (; f && f.z <= d; ) {
      if (
        f !== e.prev &&
        f !== e.next &&
        is(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
        os(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.nextZ;
    }
    return !0;
  }
  function Jo(e, t, n) {
    let i = e;
    do {
      const r = i.prev,
        o = i.next.next;
      !ss(r, o) &&
        as(r, i, i.next, o) &&
        hs(r, o) &&
        hs(o, r) &&
        (t.push(r.i / n),
        t.push(i.i / n),
        t.push(o.i / n),
        ps(i),
        ps(i.next),
        (i = e = o)),
        (i = i.next);
    } while (i !== e);
    return Xo(i);
  }
  function Ko(e, t, n, i, r, o) {
    let s = e;
    do {
      let e = s.next.next;
      for (; e !== s.prev; ) {
        if (s.i !== e.i && rs(s, e)) {
          let a = us(s, e);
          return (
            (s = Xo(s, s.next)),
            (a = Xo(a, a.next)),
            qo(s, t, n, i, r, o),
            void qo(a, t, n, i, r, o)
          );
        }
        e = e.next;
      }
      s = s.next;
    } while (s !== e);
  }
  function Qo(e, t) {
    return e.x - t.x;
  }
  function $o(e, t) {
    if (
      ((t = (function (e, t) {
        let n = t;
        const i = e.x,
          r = e.y;
        let o,
          s = -1 / 0;
        do {
          if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
            const e = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
            if (e <= i && e > s) {
              if (((s = e), e === i)) {
                if (r === n.y) return n;
                if (r === n.next.y) return n.next;
              }
              o = n.x < n.next.x ? n : n.next;
            }
          }
          n = n.next;
        } while (n !== t);
        if (!o) return null;
        if (i === s) return o;
        const a = o,
          c = o.x,
          l = o.y;
        let h,
          u = 1 / 0;
        n = o;
        do {
          i >= n.x &&
            n.x >= c &&
            i !== n.x &&
            is(r < l ? i : s, r, c, l, r < l ? s : i, r, n.x, n.y) &&
            ((h = Math.abs(r - n.y) / (i - n.x)),
            hs(n, e) &&
              (h < u ||
                (h === u && (n.x > o.x || (n.x === o.x && es(o, n))))) &&
              ((o = n), (u = h))),
            (n = n.next);
        } while (n !== a);
        return o;
      })(e, t)),
      t)
    ) {
      const n = us(t, e);
      Xo(t, t.next), Xo(n, n.next);
    }
  }
  function es(e, t) {
    return os(e.prev, e, t.prev) < 0 && os(t.next, e, e.next) < 0;
  }
  function ts(e, t, n, i, r) {
    return (
      (e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) |
      ((t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) <<
        1)
    );
  }
  function ns(e) {
    let t = e,
      n = e;
    do {
      (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
    } while (t !== e);
    return n;
  }
  function is(e, t, n, i, r, o, s, a) {
    return (
      (r - s) * (t - a) - (e - s) * (o - a) >= 0 &&
      (e - s) * (i - a) - (n - s) * (t - a) >= 0 &&
      (n - s) * (o - a) - (r - s) * (i - a) >= 0
    );
  }
  function rs(e, t) {
    return (
      e.next.i !== t.i &&
      e.prev.i !== t.i &&
      !(function (e, t) {
        let n = e;
        do {
          if (
            n.i !== e.i &&
            n.next.i !== e.i &&
            n.i !== t.i &&
            n.next.i !== t.i &&
            as(n, n.next, e, t)
          )
            return !0;
          n = n.next;
        } while (n !== e);
        return !1;
      })(e, t) &&
      ((hs(e, t) &&
        hs(t, e) &&
        (function (e, t) {
          let n = e,
            i = !1;
          const r = (e.x + t.x) / 2,
            o = (e.y + t.y) / 2;
          do {
            n.y > o != n.next.y > o &&
              n.next.y !== n.y &&
              r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
              (i = !i),
              (n = n.next);
          } while (n !== e);
          return i;
        })(e, t) &&
        (os(e.prev, e, t.prev) || os(e, t.prev, t))) ||
        (ss(e, t) && os(e.prev, e, e.next) > 0 && os(t.prev, t, t.next) > 0))
    );
  }
  function os(e, t, n) {
    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
  }
  function ss(e, t) {
    return e.x === t.x && e.y === t.y;
  }
  function as(e, t, n, i) {
    const r = ls(os(e, t, n)),
      o = ls(os(e, t, i)),
      s = ls(os(n, i, e)),
      a = ls(os(n, i, t));
    return (
      (r !== o && s !== a) ||
      !(0 !== r || !cs(e, n, t)) ||
      !(0 !== o || !cs(e, i, t)) ||
      !(0 !== s || !cs(n, e, i)) ||
      !(0 !== a || !cs(n, t, i))
    );
  }
  function cs(e, t, n) {
    return (
      t.x <= Math.max(e.x, n.x) &&
      t.x >= Math.min(e.x, n.x) &&
      t.y <= Math.max(e.y, n.y) &&
      t.y >= Math.min(e.y, n.y)
    );
  }
  function ls(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0;
  }
  function hs(e, t) {
    return os(e.prev, e, e.next) < 0
      ? os(e, t, e.next) >= 0 && os(e, e.prev, t) >= 0
      : os(e, t, e.prev) < 0 || os(e, e.next, t) < 0;
  }
  function us(e, t) {
    const n = new fs(e.i, e.x, e.y),
      i = new fs(t.i, t.x, t.y),
      r = e.next,
      o = t.prev;
    return (
      (e.next = t),
      (t.prev = e),
      (n.next = r),
      (r.prev = n),
      (i.next = n),
      (n.prev = i),
      (o.next = i),
      (i.prev = o),
      i
    );
  }
  function ds(e, t, n, i) {
    const r = new fs(e, t, n);
    return (
      i
        ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function ps(e) {
    (e.next.prev = e.prev),
      (e.prev.next = e.next),
      e.prevZ && (e.prevZ.nextZ = e.nextZ),
      e.nextZ && (e.nextZ.prevZ = e.prevZ);
  }
  function fs(e, t, n) {
    (this.i = e),
      (this.x = t),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  const ms = {
    area: function (e) {
      const t = e.length;
      let n = 0;
      for (let i = t - 1, r = 0; r < t; i = r++)
        n += e[i].x * e[r].y - e[r].x * e[i].y;
      return 0.5 * n;
    },
    isClockWise: function (e) {
      return ms.area(e) < 0;
    },
    triangulateShape: function (e, t) {
      const n = [],
        i = [],
        r = [];
      gs(e), vs(n, e);
      let o = e.length;
      t.forEach(gs);
      for (let e = 0; e < t.length; e++)
        i.push(o), (o += t[e].length), vs(n, t[e]);
      const s = (function (e, t, n) {
        n = n || 2;
        const i = t && t.length,
          r = i ? t[0] * n : e.length;
        let o = Wo(e, 0, r, n, !0);
        const s = [];
        if (!o || o.next === o.prev) return s;
        let a, c, l, h, u, d, p;
        if (
          (i &&
            (o = (function (e, t, n, i) {
              const r = [];
              let o, s, a, c, l;
              for (o = 0, s = t.length; o < s; o++)
                (a = t[o] * i),
                  (c = o < s - 1 ? t[o + 1] * i : e.length),
                  (l = Wo(e, a, c, i, !1)),
                  l === l.next && (l.steiner = !0),
                  r.push(ns(l));
              for (r.sort(Qo), o = 0; o < r.length; o++)
                $o(r[o], n), (n = Xo(n, n.next));
              return n;
            })(e, t, o, n)),
          e.length > 80 * n)
        ) {
          (a = l = e[0]), (c = h = e[1]);
          for (let t = n; t < r; t += n)
            (u = e[t]),
              (d = e[t + 1]),
              u < a && (a = u),
              d < c && (c = d),
              u > l && (l = u),
              d > h && (h = d);
          (p = Math.max(l - a, h - c)), (p = 0 !== p ? 1 / p : 0);
        }
        return qo(o, s, n, a, c, p), s;
      })(n, i);
      for (let e = 0; e < s.length; e += 3) r.push(s.slice(e, e + 3));
      return r;
    },
  };
  function gs(e) {
    const t = e.length;
    t > 2 && e[t - 1].equals(e[0]) && e.pop();
  }
  function vs(e, t) {
    for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
  }
  class ys extends Ht {
    constructor(e, t) {
      super(),
        (this.type = "ExtrudeBufferGeometry"),
        (this.parameters = { shapes: e, options: t }),
        (e = Array.isArray(e) ? e : [e]);
      const n = this,
        i = [],
        r = [];
      for (let t = 0, n = e.length; t < n; t++) o(e[t]);
      function o(e) {
        const o = [],
          s = void 0 !== t.curveSegments ? t.curveSegments : 12,
          a = void 0 !== t.steps ? t.steps : 1;
        let c = void 0 !== t.depth ? t.depth : 100,
          l = void 0 === t.bevelEnabled || t.bevelEnabled,
          h = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
          u = void 0 !== t.bevelSize ? t.bevelSize : h - 2,
          d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
          p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
        const f = t.extrudePath,
          m = void 0 !== t.UVGenerator ? t.UVGenerator : xs;
        void 0 !== t.amount &&
          (console.warn(
            "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
          ),
          (c = t.amount));
        let g,
          v,
          y,
          x,
          _,
          b = !1;
        f &&
          ((g = f.getSpacedPoints(a)),
          (b = !0),
          (l = !1),
          (v = f.computeFrenetFrames(a, !1)),
          (y = new W()),
          (x = new W()),
          (_ = new W())),
          l || ((p = 0), (h = 0), (u = 0), (d = 0));
        const w = e.extractPoints(s);
        let M = w.shape;
        const S = w.holes;
        if (!ms.isClockWise(M)) {
          M = M.reverse();
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            ms.isClockWise(t) && (S[e] = t.reverse());
          }
        }
        const E = ms.triangulateShape(M, S),
          T = M;
        for (let e = 0, t = S.length; e < t; e++) {
          const t = S[e];
          M = M.concat(t);
        }
        function A(e, t, n) {
          return (
            t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            t.clone().multiplyScalar(n).add(e)
          );
        }
        const L = M.length,
          R = E.length;
        function C(e, t, n) {
          let i, r, o;
          const s = e.x - t.x,
            a = e.y - t.y,
            c = n.x - e.x,
            l = n.y - e.y,
            h = s * s + a * a,
            u = s * l - a * c;
          if (Math.abs(u) > Number.EPSILON) {
            const u = Math.sqrt(h),
              d = Math.sqrt(c * c + l * l),
              p = t.x - a / u,
              f = t.y + s / u,
              m =
                ((n.x - l / d - p) * l - (n.y + c / d - f) * c) /
                (s * l - a * c);
            (i = p + s * m - e.x), (r = f + a * m - e.y);
            const g = i * i + r * r;
            if (g <= 2) return new N(i, r);
            o = Math.sqrt(g / 2);
          } else {
            let e = !1;
            s > Number.EPSILON
              ? c > Number.EPSILON && (e = !0)
              : s < -Number.EPSILON
              ? c < -Number.EPSILON && (e = !0)
              : Math.sign(a) === Math.sign(l) && (e = !0),
              e
                ? ((i = -a), (r = s), (o = Math.sqrt(h)))
                : ((i = s), (r = a), (o = Math.sqrt(h / 2)));
          }
          return new N(i / o, r / o);
        }
        const P = [];
        for (
          let e = 0, t = T.length, n = t - 1, i = e + 1;
          e < t;
          e++, n++, i++
        )
          n === t && (n = 0), i === t && (i = 0), (P[e] = C(T[e], T[n], T[i]));
        const O = [];
        let I,
          D = P.concat();
        for (let e = 0, t = S.length; e < t; e++) {
          const t = S[e];
          I = [];
          for (
            let e = 0, n = t.length, i = n - 1, r = e + 1;
            e < n;
            e++, i++, r++
          )
            i === n && (i = 0),
              r === n && (r = 0),
              (I[e] = C(t[e], t[i], t[r]));
          O.push(I), (D = D.concat(I));
        }
        for (let e = 0; e < p; e++) {
          const t = e / p,
            n = h * Math.cos((t * Math.PI) / 2),
            i = u * Math.sin((t * Math.PI) / 2) + d;
          for (let e = 0, t = T.length; e < t; e++) {
            const t = A(T[e], P[e], i);
            k(t.x, t.y, -n);
          }
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            I = O[e];
            for (let e = 0, r = t.length; e < r; e++) {
              const r = A(t[e], I[e], i);
              k(r.x, r.y, -n);
            }
          }
        }
        const F = u + d;
        for (let e = 0; e < L; e++) {
          const t = l ? A(M[e], D[e], F) : M[e];
          b
            ? (x.copy(v.normals[0]).multiplyScalar(t.x),
              y.copy(v.binormals[0]).multiplyScalar(t.y),
              _.copy(g[0]).add(x).add(y),
              k(_.x, _.y, _.z))
            : k(t.x, t.y, 0);
        }
        for (let e = 1; e <= a; e++)
          for (let t = 0; t < L; t++) {
            const n = l ? A(M[t], D[t], F) : M[t];
            b
              ? (x.copy(v.normals[e]).multiplyScalar(n.x),
                y.copy(v.binormals[e]).multiplyScalar(n.y),
                _.copy(g[e]).add(x).add(y),
                k(_.x, _.y, _.z))
              : k(n.x, n.y, (c / a) * e);
          }
        for (let e = p - 1; e >= 0; e--) {
          const t = e / p,
            n = h * Math.cos((t * Math.PI) / 2),
            i = u * Math.sin((t * Math.PI) / 2) + d;
          for (let e = 0, t = T.length; e < t; e++) {
            const t = A(T[e], P[e], i);
            k(t.x, t.y, c + n);
          }
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            I = O[e];
            for (let e = 0, r = t.length; e < r; e++) {
              const r = A(t[e], I[e], i);
              b ? k(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : k(r.x, r.y, c + n);
            }
          }
        }
        function U(e, t) {
          let n = e.length;
          for (; --n >= 0; ) {
            const i = n;
            let r = n - 1;
            r < 0 && (r = e.length - 1);
            for (let e = 0, n = a + 2 * p; e < n; e++) {
              const n = L * e,
                o = L * (e + 1);
              z(t + i + n, t + r + n, t + r + o, t + i + o);
            }
          }
        }
        function k(e, t, n) {
          o.push(e), o.push(t), o.push(n);
        }
        function B(e, t, r) {
          H(e), H(t), H(r);
          const o = i.length / 3,
            s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
          G(s[0]), G(s[1]), G(s[2]);
        }
        function z(e, t, r, o) {
          H(e), H(t), H(o), H(t), H(r), H(o);
          const s = i.length / 3,
            a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
          G(a[0]), G(a[1]), G(a[3]), G(a[1]), G(a[2]), G(a[3]);
        }
        function H(e) {
          i.push(o[3 * e + 0]), i.push(o[3 * e + 1]), i.push(o[3 * e + 2]);
        }
        function G(e) {
          r.push(e.x), r.push(e.y);
        }
        !(function () {
          const e = i.length / 3;
          if (l) {
            let e = 0,
              t = L * e;
            for (let e = 0; e < R; e++) {
              const n = E[e];
              B(n[2] + t, n[1] + t, n[0] + t);
            }
            (e = a + 2 * p), (t = L * e);
            for (let e = 0; e < R; e++) {
              const n = E[e];
              B(n[0] + t, n[1] + t, n[2] + t);
            }
          } else {
            for (let e = 0; e < R; e++) {
              const t = E[e];
              B(t[2], t[1], t[0]);
            }
            for (let e = 0; e < R; e++) {
              const t = E[e];
              B(t[0] + L * a, t[1] + L * a, t[2] + L * a);
            }
          }
          n.addGroup(e, i.length / 3 - e, 0);
        })(),
          (function () {
            const e = i.length / 3;
            let t = 0;
            U(T, t), (t += T.length);
            for (let e = 0, n = S.length; e < n; e++) {
              const n = S[e];
              U(n, t), (t += n.length);
            }
            n.addGroup(e, i.length / 3 - e, 1);
          })();
      }
      this.setAttribute("position", new Lt(i, 3)),
        this.setAttribute("uv", new Lt(r, 2)),
        this.computeVertexNormals();
    }
    toJSON() {
      const e = Ht.prototype.toJSON.call(this);
      return (function (e, t, n) {
        if (((n.shapes = []), Array.isArray(e)))
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            n.shapes.push(i.uuid);
          }
        else n.shapes.push(e.uuid);
        return (
          void 0 !== t.extrudePath &&
            (n.options.extrudePath = t.extrudePath.toJSON()),
          n
        );
      })(this.parameters.shapes, this.parameters.options, e);
    }
  }
  const xs = {
    generateTopUV: function (e, t, n, i, r) {
      const o = t[3 * n],
        s = t[3 * n + 1],
        a = t[3 * i],
        c = t[3 * i + 1],
        l = t[3 * r],
        h = t[3 * r + 1];
      return [new N(o, s), new N(a, c), new N(l, h)];
    },
    generateSideWallUV: function (e, t, n, i, r, o) {
      const s = t[3 * n],
        a = t[3 * n + 1],
        c = t[3 * n + 2],
        l = t[3 * i],
        h = t[3 * i + 1],
        u = t[3 * i + 2],
        d = t[3 * r],
        p = t[3 * r + 1],
        f = t[3 * r + 2],
        m = t[3 * o],
        g = t[3 * o + 1],
        v = t[3 * o + 2];
      return Math.abs(a - h) < 0.01
        ? [new N(s, 1 - c), new N(l, 1 - u), new N(d, 1 - f), new N(m, 1 - v)]
        : [new N(a, 1 - c), new N(h, 1 - u), new N(p, 1 - f), new N(g, 1 - v)];
    },
  };
  class _s extends jo {
    constructor(e, t) {
      super(),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: e, options: t }),
        this.fromBufferGeometry(new ys(e, t)),
        this.mergeVertices();
    }
    toJSON() {
      const e = super.toJSON();
      return (function (e, t, n) {
        if (((n.shapes = []), Array.isArray(e)))
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            n.shapes.push(i.uuid);
          }
        else n.shapes.push(e.uuid);
        return (
          void 0 !== t.extrudePath &&
            (n.options.extrudePath = t.extrudePath.toJSON()),
          n
        );
      })(this.parameters.shapes, this.parameters.options, e);
    }
  }
  function bs(e, t, n) {
    Ht.call(this),
      (this.type = "ParametricBufferGeometry"),
      (this.parameters = { func: e, slices: t, stacks: n });
    const i = [],
      r = [],
      o = [],
      s = [],
      a = 1e-5,
      c = new W(),
      l = new W(),
      h = new W(),
      u = new W(),
      d = new W();
    e.length < 3 &&
      console.error(
        "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
      );
    const p = t + 1;
    for (let i = 0; i <= n; i++) {
      const p = i / n;
      for (let n = 0; n <= t; n++) {
        const i = n / t;
        e(i, p, l),
          r.push(l.x, l.y, l.z),
          i - a >= 0
            ? (e(i - a, p, h), u.subVectors(l, h))
            : (e(i + a, p, h), u.subVectors(h, l)),
          p - a >= 0
            ? (e(i, p - a, h), d.subVectors(l, h))
            : (e(i, p + a, h), d.subVectors(h, l)),
          c.crossVectors(u, d).normalize(),
          o.push(c.x, c.y, c.z),
          s.push(i, p);
      }
    }
    for (let e = 0; e < n; e++)
      for (let n = 0; n < t; n++) {
        const t = e * p + n,
          r = e * p + n + 1,
          o = (e + 1) * p + n + 1,
          s = (e + 1) * p + n;
        i.push(t, r, s), i.push(r, o, s);
      }
    this.setIndex(i),
      this.setAttribute("position", new Lt(r, 3)),
      this.setAttribute("normal", new Lt(o, 3)),
      this.setAttribute("uv", new Lt(s, 2));
  }
  function ws(e, t, n) {
    jo.call(this),
      (this.type = "ParametricGeometry"),
      (this.parameters = { func: e, slices: t, stacks: n }),
      this.fromBufferGeometry(new bs(e, t, n)),
      this.mergeVertices();
  }
  (bs.prototype = Object.create(Ht.prototype)),
    (bs.prototype.constructor = bs),
    (ws.prototype = Object.create(jo.prototype)),
    (ws.prototype.constructor = ws);
  class Ms extends Ht {
    constructor(e, t = 12) {
      super(),
        (this.type = "ShapeBufferGeometry"),
        (this.parameters = { shapes: e, curveSegments: t });
      const n = [],
        i = [],
        r = [],
        o = [];
      let s = 0,
        a = 0;
      if (!1 === Array.isArray(e)) c(e);
      else
        for (let t = 0; t < e.length; t++)
          c(e[t]), this.addGroup(s, a, t), (s += a), (a = 0);
      function c(e) {
        const s = i.length / 3,
          c = e.extractPoints(t);
        let l = c.shape;
        const h = c.holes;
        !1 === ms.isClockWise(l) && (l = l.reverse());
        for (let e = 0, t = h.length; e < t; e++) {
          const t = h[e];
          !0 === ms.isClockWise(t) && (h[e] = t.reverse());
        }
        const u = ms.triangulateShape(l, h);
        for (let e = 0, t = h.length; e < t; e++) {
          const t = h[e];
          l = l.concat(t);
        }
        for (let e = 0, t = l.length; e < t; e++) {
          const t = l[e];
          i.push(t.x, t.y, 0), r.push(0, 0, 1), o.push(t.x, t.y);
        }
        for (let e = 0, t = u.length; e < t; e++) {
          const t = u[e],
            i = t[0] + s,
            r = t[1] + s,
            o = t[2] + s;
          n.push(i, r, o), (a += 3);
        }
      }
      this.setIndex(n),
        this.setAttribute("position", new Lt(i, 3)),
        this.setAttribute("normal", new Lt(r, 3)),
        this.setAttribute("uv", new Lt(o, 2));
    }
    toJSON() {
      const e = Ht.prototype.toJSON.call(this);
      return (function (e, t) {
        if (((t.shapes = []), Array.isArray(e)))
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            t.shapes.push(i.uuid);
          }
        else t.shapes.push(e.uuid);
        return t;
      })(this.parameters.shapes, e);
    }
  }
  class Ss extends jo {
    constructor(e, t) {
      super(),
        (this.type = "ShapeGeometry"),
        "object" == typeof t &&
          (console.warn(
            "THREE.ShapeGeometry: Options parameter has been removed."
          ),
          (t = t.curveSegments)),
        (this.parameters = { shapes: e, curveSegments: t }),
        this.fromBufferGeometry(new Ms(e, t)),
        this.mergeVertices();
    }
    toJSON() {
      const e = jo.prototype.toJSON.call(this);
      return (function (e, t) {
        if (((t.shapes = []), Array.isArray(e)))
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            t.shapes.push(i.uuid);
          }
        else t.shapes.push(e.uuid);
        return t;
      })(this.parameters.shapes, e);
    }
  }
  function Es(e) {
    mt.call(this),
      (this.type = "ShadowMaterial"),
      (this.color = new dt(0)),
      (this.transparent = !0),
      this.setValues(e);
  }
  function Ts(e) {
    pn.call(this, e), (this.type = "RawShaderMaterial");
  }
  function As(e) {
    mt.call(this),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new dt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new N(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.vertexTangents = !1),
      this.setValues(e);
  }
  function Ls(e) {
    As.call(this),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoat = 0),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new N(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.reflectivity = 0.5),
      Object.defineProperty(this, "ior", {
        get: function () {
          return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
        },
        set: function (e) {
          this.reflectivity = I.clamp((2.5 * (e - 1)) / (e + 1), 0, 1);
        },
      }),
      (this.sheen = null),
      (this.transmission = 0),
      (this.transmissionMap = null),
      this.setValues(e);
  }
  function Rs(e) {
    mt.call(this),
      (this.type = "MeshPhongMaterial"),
      (this.color = new dt(16777215)),
      (this.specular = new dt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new N(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(e);
  }
  function Cs(e) {
    mt.call(this),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new N(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(e);
  }
  function Ps(e) {
    mt.call(this),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new N(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(e);
  }
  function Os(e) {
    mt.call(this),
      (this.type = "MeshLambertMaterial"),
      (this.color = new dt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new dt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(e);
  }
  function Is(e) {
    mt.call(this),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new dt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new N(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(e);
  }
  function Ns(e) {
    yo.call(this),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  (Es.prototype = Object.create(mt.prototype)),
    (Es.prototype.constructor = Es),
    (Es.prototype.isShadowMaterial = !0),
    (Es.prototype.copy = function (e) {
      return mt.prototype.copy.call(this, e), this.color.copy(e.color), this;
    }),
    (Ts.prototype = Object.create(pn.prototype)),
    (Ts.prototype.constructor = Ts),
    (Ts.prototype.isRawShaderMaterial = !0),
    (As.prototype = Object.create(mt.prototype)),
    (As.prototype.constructor = As),
    (As.prototype.isMeshStandardMaterial = !0),
    (As.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        (this.defines = { STANDARD: "" }),
        this.color.copy(e.color),
        (this.roughness = e.roughness),
        (this.metalness = e.metalness),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        this.emissive.copy(e.emissive),
        (this.emissiveMap = e.emissiveMap),
        (this.emissiveIntensity = e.emissiveIntensity),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.roughnessMap = e.roughnessMap),
        (this.metalnessMap = e.metalnessMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.envMapIntensity = e.envMapIntensity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        (this.vertexTangents = e.vertexTangents),
        this
      );
    }),
    (Ls.prototype = Object.create(As.prototype)),
    (Ls.prototype.constructor = Ls),
    (Ls.prototype.isMeshPhysicalMaterial = !0),
    (Ls.prototype.copy = function (e) {
      return (
        As.prototype.copy.call(this, e),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.clearcoat = e.clearcoat),
        (this.clearcoatMap = e.clearcoatMap),
        (this.clearcoatRoughness = e.clearcoatRoughness),
        (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = e.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        (this.reflectivity = e.reflectivity),
        e.sheen
          ? (this.sheen = (this.sheen || new dt()).copy(e.sheen))
          : (this.sheen = null),
        (this.transmission = e.transmission),
        (this.transmissionMap = e.transmissionMap),
        this
      );
    }),
    (Rs.prototype = Object.create(mt.prototype)),
    (Rs.prototype.constructor = Rs),
    (Rs.prototype.isMeshPhongMaterial = !0),
    (Rs.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        (this.shininess = e.shininess),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        this.emissive.copy(e.emissive),
        (this.emissiveMap = e.emissiveMap),
        (this.emissiveIntensity = e.emissiveIntensity),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.specularMap = e.specularMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.combine = e.combine),
        (this.reflectivity = e.reflectivity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        this
      );
    }),
    (Cs.prototype = Object.create(mt.prototype)),
    (Cs.prototype.constructor = Cs),
    (Cs.prototype.isMeshToonMaterial = !0),
    (Cs.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.gradientMap = e.gradientMap),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        this.emissive.copy(e.emissive),
        (this.emissiveMap = e.emissiveMap),
        (this.emissiveIntensity = e.emissiveIntensity),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.alphaMap = e.alphaMap),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        this
      );
    }),
    (Ps.prototype = Object.create(mt.prototype)),
    (Ps.prototype.constructor = Ps),
    (Ps.prototype.isMeshNormalMaterial = !0),
    (Ps.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        this
      );
    }),
    (Os.prototype = Object.create(mt.prototype)),
    (Os.prototype.constructor = Os),
    (Os.prototype.isMeshLambertMaterial = !0),
    (Os.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        this.emissive.copy(e.emissive),
        (this.emissiveMap = e.emissiveMap),
        (this.emissiveIntensity = e.emissiveIntensity),
        (this.specularMap = e.specularMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.combine = e.combine),
        (this.reflectivity = e.reflectivity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        this
      );
    }),
    (Is.prototype = Object.create(mt.prototype)),
    (Is.prototype.constructor = Is),
    (Is.prototype.isMeshMatcapMaterial = !0),
    (Is.prototype.copy = function (e) {
      return (
        mt.prototype.copy.call(this, e),
        (this.defines = { MATCAP: "" }),
        this.color.copy(e.color),
        (this.matcap = e.matcap),
        (this.map = e.map),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.alphaMap = e.alphaMap),
        (this.skinning = e.skinning),
        (this.morphTargets = e.morphTargets),
        (this.morphNormals = e.morphNormals),
        this
      );
    }),
    (Ns.prototype = Object.create(yo.prototype)),
    (Ns.prototype.constructor = Ns),
    (Ns.prototype.isLineDashedMaterial = !0),
    (Ns.prototype.copy = function (e) {
      return (
        yo.prototype.copy.call(this, e),
        (this.scale = e.scale),
        (this.dashSize = e.dashSize),
        (this.gapSize = e.gapSize),
        this
      );
    });
  var Ds = Object.freeze({
    __proto__: null,
    ShadowMaterial: Es,
    SpriteMaterial: Ur,
    RawShaderMaterial: Ts,
    ShaderMaterial: pn,
    PointsMaterial: Ro,
    MeshPhysicalMaterial: Ls,
    MeshStandardMaterial: As,
    MeshPhongMaterial: Rs,
    MeshToonMaterial: Cs,
    MeshNormalMaterial: Ps,
    MeshLambertMaterial: Os,
    MeshDepthMaterial: xr,
    MeshDistanceMaterial: _r,
    MeshBasicMaterial: gt,
    MeshMatcapMaterial: Is,
    LineDashedMaterial: Ns,
    LineBasicMaterial: yo,
    Material: mt,
  });
  const Fs = {
    arraySlice: function (e, t, n) {
      return Fs.isTypedArray(e)
        ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
        : e.slice(t, n);
    },
    convertArray: function (e, t, n) {
      return !e || (!n && e.constructor === t)
        ? e
        : "number" == typeof t.BYTES_PER_ELEMENT
        ? new t(e)
        : Array.prototype.slice.call(e);
    },
    isTypedArray: function (e) {
      return ArrayBuffer.isView(e) && !(e instanceof DataView);
    },
    getKeyframeOrder: function (e) {
      const t = e.length,
        n = new Array(t);
      for (let e = 0; e !== t; ++e) n[e] = e;
      return (
        n.sort(function (t, n) {
          return e[t] - e[n];
        }),
        n
      );
    },
    sortedArray: function (e, t, n) {
      const i = e.length,
        r = new e.constructor(i);
      for (let o = 0, s = 0; s !== i; ++o) {
        const i = n[o] * t;
        for (let n = 0; n !== t; ++n) r[s++] = e[i + n];
      }
      return r;
    },
    flattenJSON: function (e, t, n, i) {
      let r = 1,
        o = e[0];
      for (; void 0 !== o && void 0 === o[i]; ) o = e[r++];
      if (void 0 === o) return;
      let s = o[i];
      if (void 0 !== s)
        if (Array.isArray(s))
          do {
            (s = o[i]),
              void 0 !== s && (t.push(o.time), n.push.apply(n, s)),
              (o = e[r++]);
          } while (void 0 !== o);
        else if (void 0 !== s.toArray)
          do {
            (s = o[i]),
              void 0 !== s && (t.push(o.time), s.toArray(n, n.length)),
              (o = e[r++]);
          } while (void 0 !== o);
        else
          do {
            (s = o[i]),
              void 0 !== s && (t.push(o.time), n.push(s)),
              (o = e[r++]);
          } while (void 0 !== o);
    },
    subclip: function (e, t, n, i, r = 30) {
      const o = e.clone();
      o.name = t;
      const s = [];
      for (let e = 0; e < o.tracks.length; ++e) {
        const t = o.tracks[e],
          a = t.getValueSize(),
          c = [],
          l = [];
        for (let e = 0; e < t.times.length; ++e) {
          const o = t.times[e] * r;
          if (!(o < n || o >= i)) {
            c.push(t.times[e]);
            for (let n = 0; n < a; ++n) l.push(t.values[e * a + n]);
          }
        }
        0 !== c.length &&
          ((t.times = Fs.convertArray(c, t.times.constructor)),
          (t.values = Fs.convertArray(l, t.values.constructor)),
          s.push(t));
      }
      o.tracks = s;
      let a = 1 / 0;
      for (let e = 0; e < o.tracks.length; ++e)
        a > o.tracks[e].times[0] && (a = o.tracks[e].times[0]);
      for (let e = 0; e < o.tracks.length; ++e) o.tracks[e].shift(-1 * a);
      return o.resetDuration(), o;
    },
    makeClipAdditive: function (e, t = 0, n = e, i = 30) {
      i <= 0 && (i = 30);
      const r = n.tracks.length,
        o = t / i;
      for (let t = 0; t < r; ++t) {
        const i = n.tracks[t],
          r = i.ValueTypeName;
        if ("bool" === r || "string" === r) continue;
        const s = e.tracks.find(function (e) {
          return e.name === i.name && e.ValueTypeName === r;
        });
        if (void 0 === s) continue;
        let a = 0;
        const c = i.getValueSize();
        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (a = c / 3);
        let l = 0;
        const h = s.getValueSize();
        s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
          (l = h / 3);
        const u = i.times.length - 1;
        let d;
        if (o <= i.times[0]) {
          const e = a,
            t = c - a;
          d = Fs.arraySlice(i.values, e, t);
        } else if (o >= i.times[u]) {
          const e = u * c + a,
            t = e + c - a;
          d = Fs.arraySlice(i.values, e, t);
        } else {
          const e = i.createInterpolant(),
            t = a,
            n = c - a;
          e.evaluate(o), (d = Fs.arraySlice(e.resultBuffer, t, n));
        }
        "quaternion" === r &&
          new j().fromArray(d).normalize().conjugate().toArray(d);
        const p = s.times.length;
        for (let e = 0; e < p; ++e) {
          const t = e * h + l;
          if ("quaternion" === r)
            j.multiplyQuaternionsFlat(s.values, t, d, 0, s.values, t);
          else {
            const e = h - 2 * l;
            for (let n = 0; n < e; ++n) s.values[t + n] -= d[n];
          }
        }
      }
      return (e.blendMode = 2501), e;
    },
  };
  function Us(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n);
  }
  function ks(e, t, n, i) {
    Us.call(this, e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0);
  }
  function Bs(e, t, n, i) {
    Us.call(this, e, t, n, i);
  }
  function zs(e, t, n, i) {
    Us.call(this, e, t, n, i);
  }
  function Hs(e, t, n, i) {
    if (void 0 === e)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Fs.convertArray(t, this.TimeBufferType)),
      (this.values = Fs.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  function Gs(e, t, n) {
    Hs.call(this, e, t, n);
  }
  function Vs(e, t, n, i) {
    Hs.call(this, e, t, n, i);
  }
  function js(e, t, n, i) {
    Hs.call(this, e, t, n, i);
  }
  function Ws(e, t, n, i) {
    Us.call(this, e, t, n, i);
  }
  function Xs(e, t, n, i) {
    Hs.call(this, e, t, n, i);
  }
  function qs(e, t, n, i) {
    Hs.call(this, e, t, n, i);
  }
  function Ys(e, t, n, i) {
    Hs.call(this, e, t, n, i);
  }
  function Zs(e, t = -1, n, i = 2500) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = I.generateUUID()),
      this.duration < 0 && this.resetDuration();
  }
  function Js(e) {
    if (void 0 === e.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    const t = (function (e) {
      switch (e.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return js;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Ys;
        case "color":
          return Vs;
        case "quaternion":
          return Xs;
        case "bool":
        case "boolean":
          return Gs;
        case "string":
          return qs;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
    })(e.type);
    if (void 0 === e.times) {
      const t = [],
        n = [];
      Fs.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
    }
    return void 0 !== t.parse
      ? t.parse(e)
      : new t(e.name, e.times, e.values, e.interpolation);
  }
  Object.assign(Us.prototype, {
    evaluate: function (e) {
      const t = this.parameterPositions;
      let n = this._cachedIndex,
        i = t[n],
        r = t[n - 1];
      e: {
        t: {
          let o;
          n: {
            i: if (!(e < i)) {
              for (let o = n + 2; ; ) {
                if (void 0 === i) {
                  if (e < r) break i;
                  return (
                    (n = t.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, e, r)
                  );
                }
                if (n === o) break;
                if (((r = i), (i = t[++n]), e < i)) break t;
              }
              o = t.length;
              break n;
            }
            if (e >= r) break e;
            {
              const s = t[1];
              e < s && ((n = 2), (r = s));
              for (let o = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
                if (n === o) break;
                if (((i = r), (r = t[--n - 1]), e >= r)) break t;
              }
              (o = n), (n = 0);
            }
          }
          for (; n < o; ) {
            const i = (n + o) >>> 1;
            e < t[i] ? (o = i) : (n = i + 1);
          }
          if (((i = t[n]), (r = t[n - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
          if (void 0 === i)
            return (
              (n = t.length),
              (this._cachedIndex = n),
              this.afterEnd_(n - 1, r, e)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, e, i);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function () {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function (e) {
      const t = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = e * i;
      for (let e = 0; e !== i; ++e) t[e] = n[r + e];
      return t;
    },
    interpolate_: function () {
      throw new Error("call to abstract method");
    },
    intervalChanged_: function () {},
  }),
    Object.assign(Us.prototype, {
      beforeStart_: Us.prototype.copySampleValue_,
      afterEnd_: Us.prototype.copySampleValue_,
    }),
    (ks.prototype = Object.assign(Object.create(Us.prototype), {
      constructor: ks,
      DefaultSettings_: { endingStart: b, endingEnd: b },
      intervalChanged_: function (e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2,
          o = e + 1,
          s = i[r],
          a = i[o];
        if (void 0 === s)
          switch (this.getSettings_().endingStart) {
            case w:
              (r = e), (s = 2 * t - n);
              break;
            case M:
              (r = i.length - 2), (s = t + i[r] - i[r + 1]);
              break;
            default:
              (r = e), (s = n);
          }
        if (void 0 === a)
          switch (this.getSettings_().endingEnd) {
            case w:
              (o = e), (a = 2 * n - t);
              break;
            case M:
              (o = 1), (a = n + i[1] - i[0]);
              break;
            default:
              (o = e - 1), (a = t);
          }
        const c = 0.5 * (n - t),
          l = this.valueSize;
        (this._weightPrev = c / (t - s)),
          (this._weightNext = c / (a - n)),
          (this._offsetPrev = r * l),
          (this._offsetNext = o * l);
      },
      interpolate_: function (e, t, n, i) {
        const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = e * s,
          c = a - s,
          l = this._offsetPrev,
          h = this._offsetNext,
          u = this._weightPrev,
          d = this._weightNext,
          p = (n - t) / (i - t),
          f = p * p,
          m = f * p,
          g = -u * m + 2 * u * f - u * p,
          v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
          y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
          x = d * m - d * f;
        for (let e = 0; e !== s; ++e)
          r[e] = g * o[l + e] + v * o[c + e] + y * o[a + e] + x * o[h + e];
        return r;
      },
    })),
    (Bs.prototype = Object.assign(Object.create(Us.prototype), {
      constructor: Bs,
      interpolate_: function (e, t, n, i) {
        const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = e * s,
          c = a - s,
          l = (n - t) / (i - t),
          h = 1 - l;
        for (let e = 0; e !== s; ++e) r[e] = o[c + e] * h + o[a + e] * l;
        return r;
      },
    })),
    (zs.prototype = Object.assign(Object.create(Us.prototype), {
      constructor: zs,
      interpolate_: function (e) {
        return this.copySampleValue_(e - 1);
      },
    })),
    Object.assign(Hs, {
      toJSON: function (e) {
        const t = e.constructor;
        let n;
        if (void 0 !== t.toJSON) n = t.toJSON(e);
        else {
          n = {
            name: e.name,
            times: Fs.convertArray(e.times, Array),
            values: Fs.convertArray(e.values, Array),
          };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (n.interpolation = t);
        }
        return (n.type = e.ValueTypeName), n;
      },
    }),
    Object.assign(Hs.prototype, {
      constructor: Hs,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: x,
      InterpolantFactoryMethodDiscrete: function (e) {
        return new zs(this.times, this.values, this.getValueSize(), e);
      },
      InterpolantFactoryMethodLinear: function (e) {
        return new Bs(this.times, this.values, this.getValueSize(), e);
      },
      InterpolantFactoryMethodSmooth: function (e) {
        return new ks(this.times, this.values, this.getValueSize(), e);
      },
      setInterpolation: function (e) {
        let t;
        switch (e) {
          case y:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case x:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case _:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t) {
          const t =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", t), this;
        }
        return (this.createInterpolant = t), this;
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return y;
          case this.InterpolantFactoryMethodLinear:
            return x;
          case this.InterpolantFactoryMethodSmooth:
            return _;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (e) {
        if (0 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
        }
        return this;
      },
      scale: function (e) {
        if (1 !== e) {
          const t = this.times;
          for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
        }
        return this;
      },
      trim: function (e, t) {
        const n = this.times,
          i = n.length;
        let r = 0,
          o = i - 1;
        for (; r !== i && n[r] < e; ) ++r;
        for (; -1 !== o && n[o] > t; ) --o;
        if ((++o, 0 !== r || o !== i)) {
          r >= o && ((o = Math.max(o, 1)), (r = o - 1));
          const e = this.getValueSize();
          (this.times = Fs.arraySlice(n, r, o)),
            (this.values = Fs.arraySlice(this.values, r * e, o * e));
        }
        return this;
      },
      validate: function () {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (e = !1));
        const n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (e = !1));
        let o = null;
        for (let t = 0; t !== r; t++) {
          const i = n[t];
          if ("number" == typeof i && isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              t,
              i
            ),
              (e = !1);
            break;
          }
          if (null !== o && o > i) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              t,
              i,
              o
            ),
              (e = !1);
            break;
          }
          o = i;
        }
        if (void 0 !== i && Fs.isTypedArray(i))
          for (let t = 0, n = i.length; t !== n; ++t) {
            const n = i[t];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                t,
                n
              ),
                (e = !1);
              break;
            }
          }
        return e;
      },
      optimize: function () {
        const e = Fs.arraySlice(this.times),
          t = Fs.arraySlice(this.values),
          n = this.getValueSize(),
          i = this.getInterpolation() === _,
          r = e.length - 1;
        let o = 1;
        for (let s = 1; s < r; ++s) {
          let r = !1;
          const a = e[s];
          if (a !== e[s + 1] && (1 !== s || a !== a[0]))
            if (i) r = !0;
            else {
              const e = s * n,
                i = e - n,
                o = e + n;
              for (let s = 0; s !== n; ++s) {
                const n = t[e + s];
                if (n !== t[i + s] || n !== t[o + s]) {
                  r = !0;
                  break;
                }
              }
            }
          if (r) {
            if (s !== o) {
              e[o] = e[s];
              const i = s * n,
                r = o * n;
              for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
            }
            ++o;
          }
        }
        if (r > 0) {
          e[o] = e[r];
          for (let e = r * n, i = o * n, s = 0; s !== n; ++s)
            t[i + s] = t[e + s];
          ++o;
        }
        return (
          o !== e.length
            ? ((this.times = Fs.arraySlice(e, 0, o)),
              (this.values = Fs.arraySlice(t, 0, o * n)))
            : ((this.times = e), (this.values = t)),
          this
        );
      },
      clone: function () {
        const e = Fs.arraySlice(this.times, 0),
          t = Fs.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, e, t);
        return (n.createInterpolant = this.createInterpolant), n;
      },
    }),
    (Gs.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: Gs,
      ValueTypeName: "bool",
      ValueBufferType: Array,
      DefaultInterpolation: y,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (Vs.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: Vs,
      ValueTypeName: "color",
    })),
    (js.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: js,
      ValueTypeName: "number",
    })),
    (Ws.prototype = Object.assign(Object.create(Us.prototype), {
      constructor: Ws,
      interpolate_: function (e, t, n, i) {
        const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = (n - t) / (i - t);
        let c = e * s;
        for (let e = c + s; c !== e; c += 4)
          j.slerpFlat(r, 0, o, c - s, o, c, a);
        return r;
      },
    })),
    (Xs.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: Xs,
      ValueTypeName: "quaternion",
      DefaultInterpolation: x,
      InterpolantFactoryMethodLinear: function (e) {
        return new Ws(this.times, this.values, this.getValueSize(), e);
      },
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (qs.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: qs,
      ValueTypeName: "string",
      ValueBufferType: Array,
      DefaultInterpolation: y,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (Ys.prototype = Object.assign(Object.create(Hs.prototype), {
      constructor: Ys,
      ValueTypeName: "vector",
    })),
    Object.assign(Zs, {
      parse: function (e) {
        const t = [],
          n = e.tracks,
          i = 1 / (e.fps || 1);
        for (let e = 0, r = n.length; e !== r; ++e) t.push(Js(n[e]).scale(i));
        const r = new Zs(e.name, e.duration, t, e.blendMode);
        return (r.uuid = e.uuid), r;
      },
      toJSON: function (e) {
        const t = [],
          n = e.tracks,
          i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode,
          };
        for (let e = 0, i = n.length; e !== i; ++e) t.push(Hs.toJSON(n[e]));
        return i;
      },
      CreateFromMorphTargetSequence: function (e, t, n, i) {
        const r = t.length,
          o = [];
        for (let e = 0; e < r; e++) {
          let s = [],
            a = [];
          s.push((e + r - 1) % r, e, (e + 1) % r), a.push(0, 1, 0);
          const c = Fs.getKeyframeOrder(s);
          (s = Fs.sortedArray(s, 1, c)),
            (a = Fs.sortedArray(a, 1, c)),
            i || 0 !== s[0] || (s.push(r), a.push(a[0])),
            o.push(
              new js(".morphTargetInfluences[" + t[e].name + "]", s, a).scale(
                1 / n
              )
            );
        }
        return new Zs(e, -1, o);
      },
      findByName: function (e, t) {
        let n = e;
        if (!Array.isArray(e)) {
          const t = e;
          n = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
        return null;
      },
      CreateClipsFromMorphTargetSequences: function (e, t, n) {
        const i = {},
          r = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t],
            o = n.name.match(r);
          if (o && o.length > 1) {
            const e = o[1];
            let t = i[e];
            t || (i[e] = t = []), t.push(n);
          }
        }
        const o = [];
        for (const e in i)
          o.push(Zs.CreateFromMorphTargetSequence(e, i[e], t, n));
        return o;
      },
      parseAnimation: function (e, t) {
        if (!e)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data."
            ),
            null
          );
        const n = function (e, t, n, i, r) {
            if (0 !== n.length) {
              const o = [],
                s = [];
              Fs.flattenJSON(n, o, s, i),
                0 !== o.length && r.push(new e(t, o, s));
            }
          },
          i = [],
          r = e.name || "default",
          o = e.fps || 30,
          s = e.blendMode;
        let a = e.length || -1;
        const c = e.hierarchy || [];
        for (let e = 0; e < c.length; e++) {
          const r = c[e].keys;
          if (r && 0 !== r.length)
            if (r[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < r.length; t++)
                if (r[t].morphTargets)
                  for (let n = 0; n < r[t].morphTargets.length; n++)
                    e[r[t].morphTargets[n]] = -1;
              for (const n in e) {
                const e = [],
                  o = [];
                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                  const i = r[t];
                  e.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
                }
                i.push(new js(".morphTargetInfluence[" + n + "]", e, o));
              }
              a = e.length * (o || 1);
            } else {
              const o = ".bones[" + t[e].name + "]";
              n(Ys, o + ".position", r, "pos", i),
                n(Xs, o + ".quaternion", r, "rot", i),
                n(Ys, o + ".scale", r, "scl", i);
            }
        }
        return 0 === i.length ? null : new Zs(r, a, i, s);
      },
    }),
    Object.assign(Zs.prototype, {
      resetDuration: function () {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
          const n = this.tracks[t];
          e = Math.max(e, n.times[n.times.length - 1]);
        }
        return (this.duration = e), this;
      },
      trim: function () {
        for (let e = 0; e < this.tracks.length; e++)
          this.tracks[e].trim(0, this.duration);
        return this;
      },
      validate: function () {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
          e = e && this.tracks[t].validate();
        return e;
      },
      optimize: function () {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      },
      clone: function () {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
          e.push(this.tracks[t].clone());
        return new Zs(this.name, this.duration, e, this.blendMode);
      },
      toJSON: function () {
        return Zs.toJSON(this);
      },
    });
  const Ks = {
    enabled: !1,
    files: {},
    add: function (e, t) {
      !1 !== this.enabled && (this.files[e] = t);
    },
    get: function (e) {
      if (!1 !== this.enabled) return this.files[e];
    },
    remove: function (e) {
      delete this.files[e];
    },
    clear: function () {
      this.files = {};
    },
  };
  function Qs(e, t, n) {
    const i = this;
    let r,
      o = !1,
      s = 0,
      a = 0;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (e) {
        a++, !1 === o && void 0 !== i.onStart && i.onStart(e, s, a), (o = !0);
      }),
      (this.itemEnd = function (e) {
        s++,
          void 0 !== i.onProgress && i.onProgress(e, s, a),
          s === a && ((o = !1), void 0 !== i.onLoad && i.onLoad());
      }),
      (this.itemError = function (e) {
        void 0 !== i.onError && i.onError(e);
      }),
      (this.resolveURL = function (e) {
        return r ? r(e) : e;
      }),
      (this.setURLModifier = function (e) {
        return (r = e), this;
      }),
      (this.addHandler = function (e, t) {
        return c.push(e, t), this;
      }),
      (this.removeHandler = function (e) {
        const t = c.indexOf(e);
        return -1 !== t && c.splice(t, 2), this;
      }),
      (this.getHandler = function (e) {
        for (let t = 0, n = c.length; t < n; t += 2) {
          const n = c[t],
            i = c[t + 1];
          if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
        }
        return null;
      });
  }
  const $s = new Qs();
  function ea(e) {
    (this.manager = void 0 !== e ? e : $s),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  Object.assign(ea.prototype, {
    load: function () {},
    loadAsync: function (e, t) {
      const n = this;
      return new Promise(function (i, r) {
        n.load(e, i, t, r);
      });
    },
    parse: function () {},
    setCrossOrigin: function (e) {
      return (this.crossOrigin = e), this;
    },
    setWithCredentials: function (e) {
      return (this.withCredentials = e), this;
    },
    setPath: function (e) {
      return (this.path = e), this;
    },
    setResourcePath: function (e) {
      return (this.resourcePath = e), this;
    },
    setRequestHeader: function (e) {
      return (this.requestHeader = e), this;
    },
  });
  const ta = {};
  function na(e) {
    ea.call(this, e);
  }
  function ia(e) {
    ea.call(this, e);
  }
  function ra(e) {
    ea.call(this, e);
  }
  function oa(e) {
    ea.call(this, e);
  }
  function sa(e) {
    ea.call(this, e);
  }
  function aa(e) {
    ea.call(this, e);
  }
  function ca(e) {
    ea.call(this, e);
  }
  function la() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  function ha(e, t, n, i, r, o, s, a) {
    la.call(this),
      (this.type = "EllipseCurve"),
      (this.aX = e || 0),
      (this.aY = t || 0),
      (this.xRadius = n || 1),
      (this.yRadius = i || 1),
      (this.aStartAngle = r || 0),
      (this.aEndAngle = o || 2 * Math.PI),
      (this.aClockwise = s || !1),
      (this.aRotation = a || 0);
  }
  function ua(e, t, n, i, r, o) {
    ha.call(this, e, t, n, n, i, r, o), (this.type = "ArcCurve");
  }
  function da() {
    let e = 0,
      t = 0,
      n = 0,
      i = 0;
    function r(r, o, s, a) {
      (e = r),
        (t = s),
        (n = -3 * r + 3 * o - 2 * s - a),
        (i = 2 * r - 2 * o + s + a);
    }
    return {
      initCatmullRom: function (e, t, n, i, o) {
        r(t, n, o * (n - e), o * (i - t));
      },
      initNonuniformCatmullRom: function (e, t, n, i, o, s, a) {
        let c = (t - e) / o - (n - e) / (o + s) + (n - t) / s,
          l = (n - t) / s - (i - t) / (s + a) + (i - n) / a;
        (c *= s), (l *= s), r(t, n, c, l);
      },
      calc: function (r) {
        const o = r * r;
        return e + t * r + n * o + i * (o * r);
      },
    };
  }
  (na.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: na,
    load: function (e, t, n, i) {
      void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      const r = this,
        o = Ks.get(e);
      if (void 0 !== o)
        return (
          r.manager.itemStart(e),
          setTimeout(function () {
            t && t(o), r.manager.itemEnd(e);
          }, 0),
          o
        );
      if (void 0 !== ta[e])
        return void ta[e].push({ onLoad: t, onProgress: n, onError: i });
      const s = e.match(/^data:(.*?)(;base64)?,(.*)$/);
      let a;
      if (s) {
        const n = s[1],
          o = !!s[2];
        let a = s[3];
        (a = decodeURIComponent(a)), o && (a = atob(a));
        try {
          let i;
          const o = (this.responseType || "").toLowerCase();
          switch (o) {
            case "arraybuffer":
            case "blob":
              const e = new Uint8Array(a.length);
              for (let t = 0; t < a.length; t++) e[t] = a.charCodeAt(t);
              i = "blob" === o ? new Blob([e.buffer], { type: n }) : e.buffer;
              break;
            case "document":
              const t = new DOMParser();
              i = t.parseFromString(a, n);
              break;
            case "json":
              i = JSON.parse(a);
              break;
            default:
              i = a;
          }
          setTimeout(function () {
            t && t(i), r.manager.itemEnd(e);
          }, 0);
        } catch (t) {
          setTimeout(function () {
            i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
          }, 0);
        }
      } else {
        (ta[e] = []),
          ta[e].push({ onLoad: t, onProgress: n, onError: i }),
          (a = new XMLHttpRequest()),
          a.open("GET", e, !0),
          a.addEventListener(
            "load",
            function (t) {
              const n = this.response,
                i = ta[e];
              if ((delete ta[e], 200 === this.status || 0 === this.status)) {
                0 === this.status &&
                  console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  Ks.add(e, n);
                for (let e = 0, t = i.length; e < t; e++) {
                  const t = i[e];
                  t.onLoad && t.onLoad(n);
                }
                r.manager.itemEnd(e);
              } else {
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e];
                  n.onError && n.onError(t);
                }
                r.manager.itemError(e), r.manager.itemEnd(e);
              }
            },
            !1
          ),
          a.addEventListener(
            "progress",
            function (t) {
              const n = ta[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onProgress && i.onProgress(t);
              }
            },
            !1
          ),
          a.addEventListener(
            "error",
            function (t) {
              const n = ta[e];
              delete ta[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onError && i.onError(t);
              }
              r.manager.itemError(e), r.manager.itemEnd(e);
            },
            !1
          ),
          a.addEventListener(
            "abort",
            function (t) {
              const n = ta[e];
              delete ta[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onError && i.onError(t);
              }
              r.manager.itemError(e), r.manager.itemEnd(e);
            },
            !1
          ),
          void 0 !== this.responseType && (a.responseType = this.responseType),
          void 0 !== this.withCredentials &&
            (a.withCredentials = this.withCredentials),
          a.overrideMimeType &&
            a.overrideMimeType(
              void 0 !== this.mimeType ? this.mimeType : "text/plain"
            );
        for (const e in this.requestHeader)
          a.setRequestHeader(e, this.requestHeader[e]);
        a.send(null);
      }
      return r.manager.itemStart(e), a;
    },
    setResponseType: function (e) {
      return (this.responseType = e), this;
    },
    setMimeType: function (e) {
      return (this.mimeType = e), this;
    },
  })),
    (ia.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: ia,
      load: function (e, t, n, i) {
        const r = this,
          o = new na(r.manager);
        o.setPath(r.path),
          o.setRequestHeader(r.requestHeader),
          o.setWithCredentials(r.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(r.parse(JSON.parse(n)));
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      },
      parse: function (e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
          const i = Zs.parse(e[n]);
          t.push(i);
        }
        return t;
      },
    })),
    (ra.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: ra,
      load: function (e, t, n, i) {
        const r = this,
          o = [],
          s = new Uo(),
          c = new na(this.manager);
        c.setPath(this.path),
          c.setResponseType("arraybuffer"),
          c.setRequestHeader(this.requestHeader),
          c.setWithCredentials(r.withCredentials);
        let l = 0;
        function h(h) {
          c.load(
            e[h],
            function (e) {
              const n = r.parse(e, !0);
              (o[h] = {
                width: n.width,
                height: n.height,
                format: n.format,
                mipmaps: n.mipmaps,
              }),
                (l += 1),
                6 === l &&
                  (1 === n.mipmapCount && (s.minFilter = a),
                  (s.image = o),
                  (s.format = n.format),
                  (s.needsUpdate = !0),
                  t && t(s));
            },
            n,
            i
          );
        }
        if (Array.isArray(e)) for (let t = 0, n = e.length; t < n; ++t) h(t);
        else
          c.load(
            e,
            function (e) {
              const n = r.parse(e, !0);
              if (n.isCubemap) {
                const e = n.mipmaps.length / n.mipmapCount;
                for (let t = 0; t < e; t++) {
                  o[t] = { mipmaps: [] };
                  for (let e = 0; e < n.mipmapCount; e++)
                    o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                      (o[t].format = n.format),
                      (o[t].width = n.width),
                      (o[t].height = n.height);
                }
                s.image = o;
              } else
                (s.image.width = n.width),
                  (s.image.height = n.height),
                  (s.mipmaps = n.mipmaps);
              1 === n.mipmapCount && (s.minFilter = a),
                (s.format = n.format),
                (s.needsUpdate = !0),
                t && t(s);
            },
            n,
            i
          );
        return s;
      },
    })),
    (oa.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: oa,
      load: function (e, t, n, i) {
        void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          o = Ks.get(e);
        if (void 0 !== o)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(o), r.manager.itemEnd(e);
            }, 0),
            o
          );
        const s = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "img"
        );
        function a() {
          s.removeEventListener("load", a, !1),
            s.removeEventListener("error", c, !1),
            Ks.add(e, this),
            t && t(this),
            r.manager.itemEnd(e);
        }
        function c(t) {
          s.removeEventListener("load", a, !1),
            s.removeEventListener("error", c, !1),
            i && i(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e);
        }
        return (
          s.addEventListener("load", a, !1),
          s.addEventListener("error", c, !1),
          "data:" !== e.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (s.crossOrigin = this.crossOrigin),
          r.manager.itemStart(e),
          (s.src = e),
          s
        );
      },
    })),
    (sa.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: sa,
      load: function (e, t, n, i) {
        const r = new yn(),
          o = new oa(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let s = 0;
        function a(n) {
          o.load(
            e[n],
            function (e) {
              (r.images[n] = e),
                s++,
                6 === s && ((r.needsUpdate = !0), t && t(r));
            },
            void 0,
            i
          );
        }
        for (let t = 0; t < e.length; ++t) a(t);
        return r;
      },
    })),
    (aa.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: aa,
      load: function (e, t, i, r) {
        const o = this,
          s = new _n(),
          l = new na(this.manager);
        return (
          l.setResponseType("arraybuffer"),
          l.setRequestHeader(this.requestHeader),
          l.setPath(this.path),
          l.setWithCredentials(o.withCredentials),
          l.load(
            e,
            function (e) {
              const i = o.parse(e);
              i &&
                (void 0 !== i.image
                  ? (s.image = i.image)
                  : void 0 !== i.data &&
                    ((s.image.width = i.width),
                    (s.image.height = i.height),
                    (s.image.data = i.data)),
                (s.wrapS = void 0 !== i.wrapS ? i.wrapS : n),
                (s.wrapT = void 0 !== i.wrapT ? i.wrapT : n),
                (s.magFilter = void 0 !== i.magFilter ? i.magFilter : a),
                (s.minFilter = void 0 !== i.minFilter ? i.minFilter : a),
                (s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
                void 0 !== i.format && (s.format = i.format),
                void 0 !== i.type && (s.type = i.type),
                void 0 !== i.mipmaps &&
                  ((s.mipmaps = i.mipmaps), (s.minFilter = c)),
                1 === i.mipmapCount && (s.minFilter = a),
                (s.needsUpdate = !0),
                t && t(s, i));
            },
            i,
            r
          ),
          s
        );
      },
    })),
    (ca.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: ca,
      load: function (e, t, n, i) {
        const r = new B(),
          o = new oa(this.manager);
        return (
          o.setCrossOrigin(this.crossOrigin),
          o.setPath(this.path),
          o.load(
            e,
            function (n) {
              r.image = n;
              const i =
                e.search(/\.jpe?g($|\?)/i) > 0 ||
                0 === e.search(/^data\:image\/jpeg/);
              (r.format = i ? f : m),
                (r.needsUpdate = !0),
                void 0 !== t && t(r);
            },
            n,
            i
          ),
          r
        );
      },
    })),
    Object.assign(la.prototype, {
      getPoint: function () {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      },
      getPointAt: function (e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
      },
      getPoints: function (e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t;
      },
      getSpacedPoints: function (e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t;
      },
      getLength: function () {
        const e = this.getLengths();
        return e[e.length - 1];
      },
      getLengths: function (e) {
        if (
          (void 0 === e && (e = this.arcLengthDivisions),
          this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
          i = this.getPoint(0),
          r = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
          (n = this.getPoint(o / e)),
            (r += n.distanceTo(i)),
            t.push(r),
            (i = n);
        return (this.cacheArcLengths = t), t;
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0), this.getLengths();
      },
      getUtoTmapping: function (e, t) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let o;
        o = t || e * n[r - 1];
        let s,
          a = 0,
          c = r - 1;
        for (; a <= c; )
          if (((i = Math.floor(a + (c - a) / 2)), (s = n[i] - o), s < 0))
            a = i + 1;
          else {
            if (!(s > 0)) {
              c = i;
              break;
            }
            c = i - 1;
          }
        if (((i = c), n[i] === o)) return i / (r - 1);
        const l = n[i];
        return (i + (o - l) / (n[i + 1] - l)) / (r - 1);
      },
      getTangent: function (e, t) {
        const n = 1e-4;
        let i = e - n,
          r = e + n;
        i < 0 && (i = 0), r > 1 && (r = 1);
        const o = this.getPoint(i),
          s = this.getPoint(r),
          a = t || (o.isVector2 ? new N() : new W());
        return a.copy(s).sub(o).normalize(), a;
      },
      getTangentAt: function (e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
      },
      computeFrenetFrames: function (e, t) {
        const n = new W(),
          i = [],
          r = [],
          o = [],
          s = new W(),
          a = new xe();
        for (let t = 0; t <= e; t++) {
          const n = t / e;
          (i[t] = this.getTangentAt(n, new W())), i[t].normalize();
        }
        (r[0] = new W()), (o[0] = new W());
        let c = Number.MAX_VALUE;
        const l = Math.abs(i[0].x),
          h = Math.abs(i[0].y),
          u = Math.abs(i[0].z);
        l <= c && ((c = l), n.set(1, 0, 0)),
          h <= c && ((c = h), n.set(0, 1, 0)),
          u <= c && n.set(0, 0, 1),
          s.crossVectors(i[0], n).normalize(),
          r[0].crossVectors(i[0], s),
          o[0].crossVectors(i[0], r[0]);
        for (let t = 1; t <= e; t++) {
          if (
            ((r[t] = r[t - 1].clone()),
            (o[t] = o[t - 1].clone()),
            s.crossVectors(i[t - 1], i[t]),
            s.length() > Number.EPSILON)
          ) {
            s.normalize();
            const e = Math.acos(I.clamp(i[t - 1].dot(i[t]), -1, 1));
            r[t].applyMatrix4(a.makeRotationAxis(s, e));
          }
          o[t].crossVectors(i[t], r[t]);
        }
        if (!0 === t) {
          let t = Math.acos(I.clamp(r[0].dot(r[e]), -1, 1));
          (t /= e), i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
          for (let n = 1; n <= e; n++)
            r[n].applyMatrix4(a.makeRotationAxis(i[n], t * n)),
              o[n].crossVectors(i[n], r[n]);
        }
        return { tangents: i, normals: r, binormals: o };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      },
      toJSON: function () {
        const e = {
          metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
        };
        return (
          (e.arcLengthDivisions = this.arcLengthDivisions),
          (e.type = this.type),
          e
        );
      },
      fromJSON: function (e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      },
    }),
    (ha.prototype = Object.create(la.prototype)),
    (ha.prototype.constructor = ha),
    (ha.prototype.isEllipseCurve = !0),
    (ha.prototype.getPoint = function (e, t) {
      const n = t || new N(),
        i = 2 * Math.PI;
      let r = this.aEndAngle - this.aStartAngle;
      const o = Math.abs(r) < Number.EPSILON;
      for (; r < 0; ) r += i;
      for (; r > i; ) r -= i;
      r < Number.EPSILON && (r = o ? 0 : i),
        !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
      const s = this.aStartAngle + e * r;
      let a = this.aX + this.xRadius * Math.cos(s),
        c = this.aY + this.yRadius * Math.sin(s);
      if (0 !== this.aRotation) {
        const e = Math.cos(this.aRotation),
          t = Math.sin(this.aRotation),
          n = a - this.aX,
          i = c - this.aY;
        (a = n * e - i * t + this.aX), (c = n * t + i * e + this.aY);
      }
      return n.set(a, c);
    }),
    (ha.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        (this.aX = e.aX),
        (this.aY = e.aY),
        (this.xRadius = e.xRadius),
        (this.yRadius = e.yRadius),
        (this.aStartAngle = e.aStartAngle),
        (this.aEndAngle = e.aEndAngle),
        (this.aClockwise = e.aClockwise),
        (this.aRotation = e.aRotation),
        this
      );
    }),
    (ha.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (
        (e.aX = this.aX),
        (e.aY = this.aY),
        (e.xRadius = this.xRadius),
        (e.yRadius = this.yRadius),
        (e.aStartAngle = this.aStartAngle),
        (e.aEndAngle = this.aEndAngle),
        (e.aClockwise = this.aClockwise),
        (e.aRotation = this.aRotation),
        e
      );
    }),
    (ha.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        (this.aX = e.aX),
        (this.aY = e.aY),
        (this.xRadius = e.xRadius),
        (this.yRadius = e.yRadius),
        (this.aStartAngle = e.aStartAngle),
        (this.aEndAngle = e.aEndAngle),
        (this.aClockwise = e.aClockwise),
        (this.aRotation = e.aRotation),
        this
      );
    }),
    (ua.prototype = Object.create(ha.prototype)),
    (ua.prototype.constructor = ua),
    (ua.prototype.isArcCurve = !0);
  const pa = new W(),
    fa = new da(),
    ma = new da(),
    ga = new da();
  function va(e = [], t = !1, n = "centripetal", i = 0.5) {
    la.call(this),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  function ya(e, t, n, i, r) {
    const o = 0.5 * (i - t),
      s = 0.5 * (r - n),
      a = e * e;
    return (
      (2 * n - 2 * i + o + s) * (e * a) +
      (-3 * n + 3 * i - 2 * o - s) * a +
      o * e +
      n
    );
  }
  function xa(e, t, n, i) {
    return (
      (function (e, t) {
        const n = 1 - e;
        return n * n * t;
      })(e, t) +
      (function (e, t) {
        return 2 * (1 - e) * e * t;
      })(e, n) +
      (function (e, t) {
        return e * e * t;
      })(e, i)
    );
  }
  function _a(e, t, n, i, r) {
    return (
      (function (e, t) {
        const n = 1 - e;
        return n * n * n * t;
      })(e, t) +
      (function (e, t) {
        const n = 1 - e;
        return 3 * n * n * e * t;
      })(e, n) +
      (function (e, t) {
        return 3 * (1 - e) * e * e * t;
      })(e, i) +
      (function (e, t) {
        return e * e * e * t;
      })(e, r)
    );
  }
  function ba(e = new N(), t = new N(), n = new N(), i = new N()) {
    la.call(this),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  function wa(e = new W(), t = new W(), n = new W(), i = new W()) {
    la.call(this),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  function Ma(e = new N(), t = new N()) {
    la.call(this), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
  }
  function Sa(e = new W(), t = new W()) {
    la.call(this), (this.type = "LineCurve3"), (this.v1 = e), (this.v2 = t);
  }
  function Ea(e = new N(), t = new N(), n = new N()) {
    la.call(this),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  function Ta(e = new W(), t = new W(), n = new W()) {
    la.call(this),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  function Aa(e = []) {
    la.call(this), (this.type = "SplineCurve"), (this.points = e);
  }
  (va.prototype = Object.create(la.prototype)),
    (va.prototype.constructor = va),
    (va.prototype.isCatmullRomCurve3 = !0),
    (va.prototype.getPoint = function (e, t = new W()) {
      const n = t,
        i = this.points,
        r = i.length,
        o = (r - (this.closed ? 0 : 1)) * e;
      let s,
        a,
        c = Math.floor(o),
        l = o - c;
      this.closed
        ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r)
        : 0 === l && c === r - 1 && ((c = r - 2), (l = 1)),
        this.closed || c > 0
          ? (s = i[(c - 1) % r])
          : (pa.subVectors(i[0], i[1]).add(i[0]), (s = pa));
      const h = i[c % r],
        u = i[(c + 1) % r];
      if (
        (this.closed || c + 2 < r
          ? (a = i[(c + 2) % r])
          : (pa.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = pa)),
        "centripetal" === this.curveType || "chordal" === this.curveType)
      ) {
        const e = "chordal" === this.curveType ? 0.5 : 0.25;
        let t = Math.pow(s.distanceToSquared(h), e),
          n = Math.pow(h.distanceToSquared(u), e),
          i = Math.pow(u.distanceToSquared(a), e);
        n < 1e-4 && (n = 1),
          t < 1e-4 && (t = n),
          i < 1e-4 && (i = n),
          fa.initNonuniformCatmullRom(s.x, h.x, u.x, a.x, t, n, i),
          ma.initNonuniformCatmullRom(s.y, h.y, u.y, a.y, t, n, i),
          ga.initNonuniformCatmullRom(s.z, h.z, u.z, a.z, t, n, i);
      } else
        "catmullrom" === this.curveType &&
          (fa.initCatmullRom(s.x, h.x, u.x, a.x, this.tension),
          ma.initCatmullRom(s.y, h.y, u.y, a.y, this.tension),
          ga.initCatmullRom(s.z, h.z, u.z, a.z, this.tension));
      return n.set(fa.calc(l), ma.calc(l), ga.calc(l)), n;
    }),
    (va.prototype.copy = function (e) {
      la.prototype.copy.call(this, e), (this.points = []);
      for (let t = 0, n = e.points.length; t < n; t++) {
        const n = e.points[t];
        this.points.push(n.clone());
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }),
    (va.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const n = this.points[t];
        e.points.push(n.toArray());
      }
      return (
        (e.closed = this.closed),
        (e.curveType = this.curveType),
        (e.tension = this.tension),
        e
      );
    }),
    (va.prototype.fromJSON = function (e) {
      la.prototype.fromJSON.call(this, e), (this.points = []);
      for (let t = 0, n = e.points.length; t < n; t++) {
        const n = e.points[t];
        this.points.push(new W().fromArray(n));
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }),
    (ba.prototype = Object.create(la.prototype)),
    (ba.prototype.constructor = ba),
    (ba.prototype.isCubicBezierCurve = !0),
    (ba.prototype.getPoint = function (e, t = new N()) {
      const n = t,
        i = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
      return n.set(_a(e, i.x, r.x, o.x, s.x), _a(e, i.y, r.y, o.y, s.y)), n;
    }),
    (ba.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
      );
    }),
    (ba.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        (e.v3 = this.v3.toArray()),
        e
      );
    }),
    (ba.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
      );
    }),
    (wa.prototype = Object.create(la.prototype)),
    (wa.prototype.constructor = wa),
    (wa.prototype.isCubicBezierCurve3 = !0),
    (wa.prototype.getPoint = function (e, t = new W()) {
      const n = t,
        i = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
      return (
        n.set(
          _a(e, i.x, r.x, o.x, s.x),
          _a(e, i.y, r.y, o.y, s.y),
          _a(e, i.z, r.z, o.z, s.z)
        ),
        n
      );
    }),
    (wa.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
      );
    }),
    (wa.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        (e.v3 = this.v3.toArray()),
        e
      );
    }),
    (wa.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
      );
    }),
    (Ma.prototype = Object.create(la.prototype)),
    (Ma.prototype.constructor = Ma),
    (Ma.prototype.isLineCurve = !0),
    (Ma.prototype.getPoint = function (e, t = new N()) {
      const n = t;
      return (
        1 === e
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
        n
      );
    }),
    (Ma.prototype.getPointAt = function (e, t) {
      return this.getPoint(e, t);
    }),
    (Ma.prototype.getTangent = function (e, t) {
      const n = t || new N();
      return n.copy(this.v2).sub(this.v1).normalize(), n;
    }),
    (Ma.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }),
    (Ma.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }),
    (Ma.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }),
    (Sa.prototype = Object.create(la.prototype)),
    (Sa.prototype.constructor = Sa),
    (Sa.prototype.isLineCurve3 = !0),
    (Sa.prototype.getPoint = function (e, t = new W()) {
      const n = t;
      return (
        1 === e
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
        n
      );
    }),
    (Sa.prototype.getPointAt = function (e, t) {
      return this.getPoint(e, t);
    }),
    (Sa.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }),
    (Sa.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }),
    (Sa.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }),
    (Ea.prototype = Object.create(la.prototype)),
    (Ea.prototype.constructor = Ea),
    (Ea.prototype.isQuadraticBezierCurve = !0),
    (Ea.prototype.getPoint = function (e, t = new N()) {
      const n = t,
        i = this.v0,
        r = this.v1,
        o = this.v2;
      return n.set(xa(e, i.x, r.x, o.x), xa(e, i.y, r.y, o.y)), n;
    }),
    (Ea.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }),
    (Ea.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        e
      );
    }),
    (Ea.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }),
    (Ta.prototype = Object.create(la.prototype)),
    (Ta.prototype.constructor = Ta),
    (Ta.prototype.isQuadraticBezierCurve3 = !0),
    (Ta.prototype.getPoint = function (e, t = new W()) {
      const n = t,
        i = this.v0,
        r = this.v1,
        o = this.v2;
      return (
        n.set(xa(e, i.x, r.x, o.x), xa(e, i.y, r.y, o.y), xa(e, i.z, r.z, o.z)),
        n
      );
    }),
    (Ta.prototype.copy = function (e) {
      return (
        la.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }),
    (Ta.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        e
      );
    }),
    (Ta.prototype.fromJSON = function (e) {
      return (
        la.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }),
    (Aa.prototype = Object.create(la.prototype)),
    (Aa.prototype.constructor = Aa),
    (Aa.prototype.isSplineCurve = !0),
    (Aa.prototype.getPoint = function (e, t = new N()) {
      const n = t,
        i = this.points,
        r = (i.length - 1) * e,
        o = Math.floor(r),
        s = r - o,
        a = i[0 === o ? o : o - 1],
        c = i[o],
        l = i[o > i.length - 2 ? i.length - 1 : o + 1],
        h = i[o > i.length - 3 ? i.length - 1 : o + 2];
      return n.set(ya(s, a.x, c.x, l.x, h.x), ya(s, a.y, c.y, l.y, h.y)), n;
    }),
    (Aa.prototype.copy = function (e) {
      la.prototype.copy.call(this, e), (this.points = []);
      for (let t = 0, n = e.points.length; t < n; t++) {
        const n = e.points[t];
        this.points.push(n.clone());
      }
      return this;
    }),
    (Aa.prototype.toJSON = function () {
      const e = la.prototype.toJSON.call(this);
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const n = this.points[t];
        e.points.push(n.toArray());
      }
      return e;
    }),
    (Aa.prototype.fromJSON = function (e) {
      la.prototype.fromJSON.call(this, e), (this.points = []);
      for (let t = 0, n = e.points.length; t < n; t++) {
        const n = e.points[t];
        this.points.push(new N().fromArray(n));
      }
      return this;
    });
  var La = Object.freeze({
    __proto__: null,
    ArcCurve: ua,
    CatmullRomCurve3: va,
    CubicBezierCurve: ba,
    CubicBezierCurve3: wa,
    EllipseCurve: ha,
    LineCurve: Ma,
    LineCurve3: Sa,
    QuadraticBezierCurve: Ea,
    QuadraticBezierCurve3: Ta,
    SplineCurve: Aa,
  });
  function Ra() {
    la.call(this),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  function Ca(e) {
    Ra.call(this),
      (this.type = "Path"),
      (this.currentPoint = new N()),
      e && this.setFromPoints(e);
  }
  function Pa(e) {
    Ca.call(this, e),
      (this.uuid = I.generateUUID()),
      (this.type = "Shape"),
      (this.holes = []);
  }
  function Oa(e, t = 1) {
    je.call(this),
      (this.type = "Light"),
      (this.color = new dt(e)),
      (this.intensity = t);
  }
  function Ia(e, t, n) {
    Oa.call(this, e, n),
      (this.type = "HemisphereLight"),
      this.position.copy(je.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new dt(t));
  }
  function Na(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.mapSize = new N(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new xe()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Mn()),
      (this._frameExtents = new N(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new H(0, 0, 1, 1)]);
  }
  function Da() {
    Na.call(this, new mn(50, 1, 0.5, 500)), (this.focus = 1);
  }
  function Fa(e, t, n, i, r, o) {
    Oa.call(this, e, t),
      (this.type = "SpotLight"),
      this.position.copy(je.DefaultUp),
      this.updateMatrix(),
      (this.target = new je()),
      Object.defineProperty(this, "power", {
        get: function () {
          return this.intensity * Math.PI;
        },
        set: function (e) {
          this.intensity = e / Math.PI;
        },
      }),
      (this.distance = void 0 !== n ? n : 0),
      (this.angle = void 0 !== i ? i : Math.PI / 3),
      (this.penumbra = void 0 !== r ? r : 0),
      (this.decay = void 0 !== o ? o : 1),
      (this.shadow = new Da());
  }
  function Ua() {
    Na.call(this, new mn(90, 1, 0.5, 500)),
      (this._frameExtents = new N(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new H(2, 1, 1, 1),
        new H(0, 1, 1, 1),
        new H(3, 1, 1, 1),
        new H(1, 1, 1, 1),
        new H(3, 0, 1, 1),
        new H(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new W(1, 0, 0),
        new W(-1, 0, 0),
        new W(0, 0, 1),
        new W(0, 0, -1),
        new W(0, 1, 0),
        new W(0, -1, 0),
      ]),
      (this._cubeUps = [
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 1, 0),
        new W(0, 0, 1),
        new W(0, 0, -1),
      ]);
  }
  function ka(e, t, n, i) {
    Oa.call(this, e, t),
      (this.type = "PointLight"),
      Object.defineProperty(this, "power", {
        get: function () {
          return 4 * this.intensity * Math.PI;
        },
        set: function (e) {
          this.intensity = e / (4 * Math.PI);
        },
      }),
      (this.distance = void 0 !== n ? n : 0),
      (this.decay = void 0 !== i ? i : 1),
      (this.shadow = new Ua());
  }
  function Ba(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    fn.call(this),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  function za() {
    Na.call(this, new Ba(-5, 5, 5, -5, 0.5, 500));
  }
  function Ha(e, t) {
    Oa.call(this, e, t),
      (this.type = "DirectionalLight"),
      this.position.copy(je.DefaultUp),
      this.updateMatrix(),
      (this.target = new je()),
      (this.shadow = new za());
  }
  function Ga(e, t) {
    Oa.call(this, e, t), (this.type = "AmbientLight");
  }
  function Va(e, t, n, i) {
    Oa.call(this, e, t),
      (this.type = "RectAreaLight"),
      (this.width = void 0 !== n ? n : 10),
      (this.height = void 0 !== i ? i : 10);
  }
  (Ra.prototype = Object.assign(Object.create(la.prototype), {
    constructor: Ra,
    add: function (e) {
      this.curves.push(e);
    },
    closePath: function () {
      const e = this.curves[0].getPoint(0),
        t = this.curves[this.curves.length - 1].getPoint(1);
      e.equals(t) || this.curves.push(new Ma(t, e));
    },
    getPoint: function (e) {
      const t = e * this.getLength(),
        n = this.getCurveLengths();
      let i = 0;
      for (; i < n.length; ) {
        if (n[i] >= t) {
          const e = n[i] - t,
            r = this.curves[i],
            o = r.getLength(),
            s = 0 === o ? 0 : 1 - e / o;
          return r.getPointAt(s);
        }
        i++;
      }
      return null;
    },
    getLength: function () {
      const e = this.getCurveLengths();
      return e[e.length - 1];
    },
    updateArcLengths: function () {
      (this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths();
    },
    getCurveLengths: function () {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const e = [];
      let t = 0;
      for (let n = 0, i = this.curves.length; n < i; n++)
        (t += this.curves[n].getLength()), e.push(t);
      return (this.cacheLengths = e), e;
    },
    getSpacedPoints: function (e = 40) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return this.autoClose && t.push(t[0]), t;
    },
    getPoints: function (e = 12) {
      const t = [];
      let n;
      for (let i = 0, r = this.curves; i < r.length; i++) {
        const o = r[i],
          s =
            o && o.isEllipseCurve
              ? 2 * e
              : o && (o.isLineCurve || o.isLineCurve3)
              ? 1
              : o && o.isSplineCurve
              ? e * o.points.length
              : e,
          a = o.getPoints(s);
        for (let e = 0; e < a.length; e++) {
          const i = a[e];
          (n && n.equals(i)) || (t.push(i), (n = i));
        }
      }
      return (
        this.autoClose &&
          t.length > 1 &&
          !t[t.length - 1].equals(t[0]) &&
          t.push(t[0]),
        t
      );
    },
    copy: function (e) {
      la.prototype.copy.call(this, e), (this.curves = []);
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const n = e.curves[t];
        this.curves.push(n.clone());
      }
      return (this.autoClose = e.autoClose), this;
    },
    toJSON: function () {
      const e = la.prototype.toJSON.call(this);
      (e.autoClose = this.autoClose), (e.curves = []);
      for (let t = 0, n = this.curves.length; t < n; t++) {
        const n = this.curves[t];
        e.curves.push(n.toJSON());
      }
      return e;
    },
    fromJSON: function (e) {
      la.prototype.fromJSON.call(this, e),
        (this.autoClose = e.autoClose),
        (this.curves = []);
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const n = e.curves[t];
        this.curves.push(new La[n.type]().fromJSON(n));
      }
      return this;
    },
  })),
    (Ca.prototype = Object.assign(Object.create(Ra.prototype), {
      constructor: Ca,
      setFromPoints: function (e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      },
      moveTo: function (e, t) {
        return this.currentPoint.set(e, t), this;
      },
      lineTo: function (e, t) {
        const n = new Ma(this.currentPoint.clone(), new N(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
      },
      quadraticCurveTo: function (e, t, n, i) {
        const r = new Ea(this.currentPoint.clone(), new N(e, t), new N(n, i));
        return this.curves.push(r), this.currentPoint.set(n, i), this;
      },
      bezierCurveTo: function (e, t, n, i, r, o) {
        const s = new ba(
          this.currentPoint.clone(),
          new N(e, t),
          new N(n, i),
          new N(r, o)
        );
        return this.curves.push(s), this.currentPoint.set(r, o), this;
      },
      splineThru: function (e) {
        const t = new Aa([this.currentPoint.clone()].concat(e));
        return (
          this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
        );
      },
      arc: function (e, t, n, i, r, o) {
        const s = this.currentPoint.x,
          a = this.currentPoint.y;
        return this.absarc(e + s, t + a, n, i, r, o), this;
      },
      absarc: function (e, t, n, i, r, o) {
        return this.absellipse(e, t, n, n, i, r, o), this;
      },
      ellipse: function (e, t, n, i, r, o, s, a) {
        const c = this.currentPoint.x,
          l = this.currentPoint.y;
        return this.absellipse(e + c, t + l, n, i, r, o, s, a), this;
      },
      absellipse: function (e, t, n, i, r, o, s, a) {
        const c = new ha(e, t, n, i, r, o, s, a);
        if (this.curves.length > 0) {
          const e = c.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }
        this.curves.push(c);
        const l = c.getPoint(1);
        return this.currentPoint.copy(l), this;
      },
      copy: function (e) {
        return (
          Ra.prototype.copy.call(this, e),
          this.currentPoint.copy(e.currentPoint),
          this
        );
      },
      toJSON: function () {
        const e = Ra.prototype.toJSON.call(this);
        return (e.currentPoint = this.currentPoint.toArray()), e;
      },
      fromJSON: function (e) {
        return (
          Ra.prototype.fromJSON.call(this, e),
          this.currentPoint.fromArray(e.currentPoint),
          this
        );
      },
    })),
    (Pa.prototype = Object.assign(Object.create(Ca.prototype), {
      constructor: Pa,
      getPointsHoles: function (e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
          t[n] = this.holes[n].getPoints(e);
        return t;
      },
      extractPoints: function (e) {
        return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
      },
      copy: function (e) {
        Ca.prototype.copy.call(this, e), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      },
      toJSON: function () {
        const e = Ca.prototype.toJSON.call(this);
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, n = this.holes.length; t < n; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }
        return e;
      },
      fromJSON: function (e) {
        Ca.prototype.fromJSON.call(this, e),
          (this.uuid = e.uuid),
          (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(new Ca().fromJSON(n));
        }
        return this;
      },
    })),
    (Oa.prototype = Object.assign(Object.create(je.prototype), {
      constructor: Oa,
      isLight: !0,
      copy: function (e) {
        return (
          je.prototype.copy.call(this, e),
          this.color.copy(e.color),
          (this.intensity = e.intensity),
          this
        );
      },
      toJSON: function (e) {
        const t = je.prototype.toJSON.call(this, e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      },
    })),
    (Ia.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: Ia,
      isHemisphereLight: !0,
      copy: function (e) {
        return (
          Oa.prototype.copy.call(this, e),
          this.groundColor.copy(e.groundColor),
          this
        );
      },
    })),
    Object.assign(Na.prototype, {
      _projScreenMatrix: new xe(),
      _lightPositionWorld: new W(),
      _lookTarget: new W(),
      getViewportCount: function () {
        return this._viewportCount;
      },
      getFrustum: function () {
        return this._frustum;
      },
      updateMatrices: function (e) {
        const t = this.camera,
          n = this.matrix,
          i = this._projScreenMatrix,
          r = this._lookTarget,
          o = this._lightPositionWorld;
        o.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(o),
          r.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(r),
          t.updateMatrixWorld(),
          i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(i),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(t.projectionMatrix),
          n.multiply(t.matrixWorldInverse);
      },
      getViewport: function (e) {
        return this._viewports[e];
      },
      getFrameExtents: function () {
        return this._frameExtents;
      },
      copy: function (e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        const e = {};
        return (
          0 !== this.bias && (e.bias = this.bias),
          0 !== this.normalBias && (e.normalBias = this.normalBias),
          1 !== this.radius && (e.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      },
    }),
    (Da.prototype = Object.assign(Object.create(Na.prototype), {
      constructor: Da,
      isSpotLightShadow: !0,
      updateMatrices: function (e) {
        const t = this.camera,
          n = 2 * I.RAD2DEG * e.angle * this.focus,
          i = this.mapSize.width / this.mapSize.height,
          r = e.distance || t.far;
        (n === t.fov && i === t.aspect && r === t.far) ||
          ((t.fov = n),
          (t.aspect = i),
          (t.far = r),
          t.updateProjectionMatrix()),
          Na.prototype.updateMatrices.call(this, e);
      },
    })),
    (Fa.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: Fa,
      isSpotLight: !0,
      copy: function (e) {
        return (
          Oa.prototype.copy.call(this, e),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      },
    })),
    (Ua.prototype = Object.assign(Object.create(Na.prototype), {
      constructor: Ua,
      isPointLightShadow: !0,
      updateMatrices: function (e, t = 0) {
        const n = this.camera,
          i = this.matrix,
          r = this._lightPositionWorld,
          o = this._lookTarget,
          s = this._projScreenMatrix;
        r.setFromMatrixPosition(e.matrixWorld),
          n.position.copy(r),
          o.copy(n.position),
          o.add(this._cubeDirections[t]),
          n.up.copy(this._cubeUps[t]),
          n.lookAt(o),
          n.updateMatrixWorld(),
          i.makeTranslation(-r.x, -r.y, -r.z),
          s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(s);
      },
    })),
    (ka.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: ka,
      isPointLight: !0,
      copy: function (e) {
        return (
          Oa.prototype.copy.call(this, e),
          (this.distance = e.distance),
          (this.decay = e.decay),
          (this.shadow = e.shadow.clone()),
          this
        );
      },
    })),
    (Ba.prototype = Object.assign(Object.create(fn.prototype), {
      constructor: Ba,
      isOrthographicCamera: !0,
      copy: function (e, t) {
        return (
          fn.prototype.copy.call(this, e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          this
        );
      },
      setViewOffset: function (e, t, n, i, r, o) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = o),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        const e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
        let r = n - e,
          o = n + e,
          s = i + t,
          a = i - t;
        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (r += e * this.view.offsetX),
            (o = r + e * this.view.width),
            (s -= t * this.view.offsetY),
            (a = s - t * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      },
      toJSON: function (e) {
        const t = je.prototype.toJSON.call(this, e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      },
    })),
    (za.prototype = Object.assign(Object.create(Na.prototype), {
      constructor: za,
      isDirectionalLightShadow: !0,
      updateMatrices: function (e) {
        Na.prototype.updateMatrices.call(this, e);
      },
    })),
    (Ha.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: Ha,
      isDirectionalLight: !0,
      copy: function (e) {
        return (
          Oa.prototype.copy.call(this, e),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      },
    })),
    (Ga.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: Ga,
      isAmbientLight: !0,
    })),
    (Va.prototype = Object.assign(Object.create(Oa.prototype), {
      constructor: Va,
      isRectAreaLight: !0,
      copy: function (e) {
        return (
          Oa.prototype.copy.call(this, e),
          (this.width = e.width),
          (this.height = e.height),
          this
        );
      },
      toJSON: function (e) {
        const t = Oa.prototype.toJSON.call(this, e);
        return (
          (t.object.width = this.width), (t.object.height = this.height), t
        );
      },
    }));
  class ja {
    constructor() {
      Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }),
        (this.coefficients = []);
      for (let e = 0; e < 9; e++) this.coefficients.push(new W());
    }
    set(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
      return this;
    }
    zero() {
      for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
      return this;
    }
    getAt(e, t) {
      const n = e.x,
        i = e.y,
        r = e.z,
        o = this.coefficients;
      return (
        t.copy(o[0]).multiplyScalar(0.282095),
        t.addScaledVector(o[1], 0.488603 * i),
        t.addScaledVector(o[2], 0.488603 * r),
        t.addScaledVector(o[3], 0.488603 * n),
        t.addScaledVector(o[4], n * i * 1.092548),
        t.addScaledVector(o[5], i * r * 1.092548),
        t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
        t.addScaledVector(o[7], n * r * 1.092548),
        t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
        t
      );
    }
    getIrradianceAt(e, t) {
      const n = e.x,
        i = e.y,
        r = e.z,
        o = this.coefficients;
      return (
        t.copy(o[0]).multiplyScalar(0.886227),
        t.addScaledVector(o[1], 1.023328 * i),
        t.addScaledVector(o[2], 1.023328 * r),
        t.addScaledVector(o[3], 1.023328 * n),
        t.addScaledVector(o[4], 0.858086 * n * i),
        t.addScaledVector(o[5], 0.858086 * i * r),
        t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
        t.addScaledVector(o[7], 0.858086 * n * r),
        t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
        t
      );
    }
    add(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
      return this;
    }
    addScaledSH(e, t) {
      for (let n = 0; n < 9; n++)
        this.coefficients[n].addScaledVector(e.coefficients[n], t);
      return this;
    }
    scale(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
      return this;
    }
    lerp(e, t) {
      for (let n = 0; n < 9; n++)
        this.coefficients[n].lerp(e.coefficients[n], t);
      return this;
    }
    equals(e) {
      for (let t = 0; t < 9; t++)
        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
      return !0;
    }
    copy(e) {
      return this.set(e.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
      return e;
    }
    static getBasisAt(e, t) {
      const n = e.x,
        i = e.y,
        r = e.z;
      (t[0] = 0.282095),
        (t[1] = 0.488603 * i),
        (t[2] = 0.488603 * r),
        (t[3] = 0.488603 * n),
        (t[4] = 1.092548 * n * i),
        (t[5] = 1.092548 * i * r),
        (t[6] = 0.315392 * (3 * r * r - 1)),
        (t[7] = 1.092548 * n * r),
        (t[8] = 0.546274 * (n * n - i * i));
    }
  }
  function Wa(e, t) {
    Oa.call(this, void 0, t),
      (this.type = "LightProbe"),
      (this.sh = void 0 !== e ? e : new ja());
  }
  function Xa(e) {
    ea.call(this, e), (this.textures = {});
  }
  (Wa.prototype = Object.assign(Object.create(Oa.prototype), {
    constructor: Wa,
    isLightProbe: !0,
    copy: function (e) {
      return Oa.prototype.copy.call(this, e), this.sh.copy(e.sh), this;
    },
    fromJSON: function (e) {
      return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
    },
    toJSON: function (e) {
      const t = Oa.prototype.toJSON.call(this, e);
      return (t.object.sh = this.sh.toArray()), t;
    },
  })),
    (Xa.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: Xa,
      load: function (e, t, n, i) {
        const r = this,
          o = new na(r.manager);
        o.setPath(r.path),
          o.setRequestHeader(r.requestHeader),
          o.setWithCredentials(r.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(r.parse(JSON.parse(n)));
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      },
      parse: function (e) {
        const t = this.textures;
        function n(e) {
          return (
            void 0 === t[e] &&
              console.warn("THREE.MaterialLoader: Undefined texture", e),
            t[e]
          );
        }
        const i = new Ds[e.type]();
        if (
          (void 0 !== e.uuid && (i.uuid = e.uuid),
          void 0 !== e.name && (i.name = e.name),
          void 0 !== e.color && void 0 !== i.color && i.color.setHex(e.color),
          void 0 !== e.roughness && (i.roughness = e.roughness),
          void 0 !== e.metalness && (i.metalness = e.metalness),
          void 0 !== e.sheen && (i.sheen = new dt().setHex(e.sheen)),
          void 0 !== e.emissive &&
            void 0 !== i.emissive &&
            i.emissive.setHex(e.emissive),
          void 0 !== e.specular &&
            void 0 !== i.specular &&
            i.specular.setHex(e.specular),
          void 0 !== e.shininess && (i.shininess = e.shininess),
          void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat),
          void 0 !== e.clearcoatRoughness &&
            (i.clearcoatRoughness = e.clearcoatRoughness),
          void 0 !== e.fog && (i.fog = e.fog),
          void 0 !== e.flatShading && (i.flatShading = e.flatShading),
          void 0 !== e.blending && (i.blending = e.blending),
          void 0 !== e.combine && (i.combine = e.combine),
          void 0 !== e.side && (i.side = e.side),
          void 0 !== e.opacity && (i.opacity = e.opacity),
          void 0 !== e.transparent && (i.transparent = e.transparent),
          void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
          void 0 !== e.depthTest && (i.depthTest = e.depthTest),
          void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
          void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
          void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite),
          void 0 !== e.stencilWriteMask &&
            (i.stencilWriteMask = e.stencilWriteMask),
          void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc),
          void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef),
          void 0 !== e.stencilFuncMask &&
            (i.stencilFuncMask = e.stencilFuncMask),
          void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail),
          void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail),
          void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass),
          void 0 !== e.wireframe && (i.wireframe = e.wireframe),
          void 0 !== e.wireframeLinewidth &&
            (i.wireframeLinewidth = e.wireframeLinewidth),
          void 0 !== e.wireframeLinecap &&
            (i.wireframeLinecap = e.wireframeLinecap),
          void 0 !== e.wireframeLinejoin &&
            (i.wireframeLinejoin = e.wireframeLinejoin),
          void 0 !== e.rotation && (i.rotation = e.rotation),
          1 !== e.linewidth && (i.linewidth = e.linewidth),
          void 0 !== e.dashSize && (i.dashSize = e.dashSize),
          void 0 !== e.gapSize && (i.gapSize = e.gapSize),
          void 0 !== e.scale && (i.scale = e.scale),
          void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
          void 0 !== e.polygonOffsetFactor &&
            (i.polygonOffsetFactor = e.polygonOffsetFactor),
          void 0 !== e.polygonOffsetUnits &&
            (i.polygonOffsetUnits = e.polygonOffsetUnits),
          void 0 !== e.skinning && (i.skinning = e.skinning),
          void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets),
          void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals),
          void 0 !== e.dithering && (i.dithering = e.dithering),
          void 0 !== e.vertexTangents && (i.vertexTangents = e.vertexTangents),
          void 0 !== e.visible && (i.visible = e.visible),
          void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped),
          void 0 !== e.userData && (i.userData = e.userData),
          void 0 !== e.vertexColors &&
            ("number" == typeof e.vertexColors
              ? (i.vertexColors = e.vertexColors > 0)
              : (i.vertexColors = e.vertexColors)),
          void 0 !== e.uniforms)
        )
          for (const t in e.uniforms) {
            const r = e.uniforms[t];
            switch (((i.uniforms[t] = {}), r.type)) {
              case "t":
                i.uniforms[t].value = n(r.value);
                break;
              case "c":
                i.uniforms[t].value = new dt().setHex(r.value);
                break;
              case "v2":
                i.uniforms[t].value = new N().fromArray(r.value);
                break;
              case "v3":
                i.uniforms[t].value = new W().fromArray(r.value);
                break;
              case "v4":
                i.uniforms[t].value = new H().fromArray(r.value);
                break;
              case "m3":
                i.uniforms[t].value = new D().fromArray(r.value);
                break;
              case "m4":
                i.uniforms[t].value = new xe().fromArray(r.value);
                break;
              default:
                i.uniforms[t].value = r.value;
            }
          }
        if (
          (void 0 !== e.defines && (i.defines = e.defines),
          void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader),
          void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader),
          void 0 !== e.extensions)
        )
          for (const t in e.extensions) i.extensions[t] = e.extensions[t];
        if (
          (void 0 !== e.shading && (i.flatShading = 1 === e.shading),
          void 0 !== e.size && (i.size = e.size),
          void 0 !== e.sizeAttenuation &&
            (i.sizeAttenuation = e.sizeAttenuation),
          void 0 !== e.map && (i.map = n(e.map)),
          void 0 !== e.matcap && (i.matcap = n(e.matcap)),
          void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)),
          void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)),
          void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
          void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)),
          void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
          void 0 !== e.normalScale)
        ) {
          let t = e.normalScale;
          !1 === Array.isArray(t) && (t = [t, t]),
            (i.normalScale = new N().fromArray(t));
        }
        return (
          void 0 !== e.displacementMap &&
            (i.displacementMap = n(e.displacementMap)),
          void 0 !== e.displacementScale &&
            (i.displacementScale = e.displacementScale),
          void 0 !== e.displacementBias &&
            (i.displacementBias = e.displacementBias),
          void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)),
          void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)),
          void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)),
          void 0 !== e.emissiveIntensity &&
            (i.emissiveIntensity = e.emissiveIntensity),
          void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)),
          void 0 !== e.envMap && (i.envMap = n(e.envMap)),
          void 0 !== e.envMapIntensity &&
            (i.envMapIntensity = e.envMapIntensity),
          void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
          void 0 !== e.refractionRatio &&
            (i.refractionRatio = e.refractionRatio),
          void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)),
          void 0 !== e.lightMapIntensity &&
            (i.lightMapIntensity = e.lightMapIntensity),
          void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)),
          void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity),
          void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)),
          void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)),
          void 0 !== e.clearcoatRoughnessMap &&
            (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
          void 0 !== e.clearcoatNormalMap &&
            (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
          void 0 !== e.clearcoatNormalScale &&
            (i.clearcoatNormalScale = new N().fromArray(
              e.clearcoatNormalScale
            )),
          void 0 !== e.transmission && (i.transmission = e.transmission),
          void 0 !== e.transmissionMap &&
            (i.transmissionMap = n(e.transmissionMap)),
          i
        );
      },
      setTextures: function (e) {
        return (this.textures = e), this;
      },
    }));
  const qa = function (e) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
      let t = "";
      for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
      try {
        return decodeURIComponent(escape(t));
      } catch (e) {
        return t;
      }
    },
    Ya = function (e) {
      const t = e.lastIndexOf("/");
      return -1 === t ? "./" : e.substr(0, t + 1);
    };
  function Za() {
    Ht.call(this),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  function Ja(e, t, n, i) {
    "number" == typeof n &&
      ((i = n),
      (n = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      )),
      xt.call(this, e, t, n),
      (this.meshPerAttribute = i || 1);
  }
  function Ka(e) {
    ea.call(this, e);
  }
  function Qa(e) {
    "undefined" == typeof createImageBitmap &&
      console.warn(
        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
      ),
      "undefined" == typeof fetch &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      ea.call(this, e),
      (this.options = { premultiplyAlpha: "none" });
  }
  function $a() {
    (this.type = "ShapePath"),
      (this.color = new dt()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  function ec(e) {
    (this.type = "Font"), (this.data = e);
  }
  function tc(e, t, n, i, r) {
    const o = r.glyphs[e] || r.glyphs["?"];
    if (!o)
      return void console.error(
        'THREE.Font: character "' +
          e +
          '" does not exists in font family ' +
          r.familyName +
          "."
      );
    const s = new $a();
    let a, c, l, h, u, d, p, f;
    if (o.o) {
      const e = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
      for (let r = 0, o = e.length; r < o; )
        switch (e[r++]) {
          case "m":
            (a = e[r++] * t + n), (c = e[r++] * t + i), s.moveTo(a, c);
            break;
          case "l":
            (a = e[r++] * t + n), (c = e[r++] * t + i), s.lineTo(a, c);
            break;
          case "q":
            (l = e[r++] * t + n),
              (h = e[r++] * t + i),
              (u = e[r++] * t + n),
              (d = e[r++] * t + i),
              s.quadraticCurveTo(u, d, l, h);
            break;
          case "b":
            (l = e[r++] * t + n),
              (h = e[r++] * t + i),
              (u = e[r++] * t + n),
              (d = e[r++] * t + i),
              (p = e[r++] * t + n),
              (f = e[r++] * t + i),
              s.bezierCurveTo(u, d, p, f, l, h);
        }
    }
    return { offsetX: o.ha * t, path: s };
  }
  function nc(e) {
    ea.call(this, e);
  }
  let ic;
  (Za.prototype = Object.assign(Object.create(Ht.prototype), {
    constructor: Za,
    isInstancedBufferGeometry: !0,
    copy: function (e) {
      return (
        Ht.prototype.copy.call(this, e),
        (this.instanceCount = e.instanceCount),
        this
      );
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    toJSON: function () {
      const e = Ht.prototype.toJSON.call(this);
      return (
        (e.instanceCount = this.instanceCount),
        (e.isInstancedBufferGeometry = !0),
        e
      );
    },
  })),
    (Ja.prototype = Object.assign(Object.create(xt.prototype), {
      constructor: Ja,
      isInstancedBufferAttribute: !0,
      copy: function (e) {
        return (
          xt.prototype.copy.call(this, e),
          (this.meshPerAttribute = e.meshPerAttribute),
          this
        );
      },
      toJSON: function () {
        const e = xt.prototype.toJSON.call(this);
        return (
          (e.meshPerAttribute = this.meshPerAttribute),
          (e.isInstancedBufferAttribute = !0),
          e
        );
      },
    })),
    (Ka.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: Ka,
      load: function (e, t, n, i) {
        const r = this,
          o = new na(r.manager);
        o.setPath(r.path),
          o.setRequestHeader(r.requestHeader),
          o.setWithCredentials(r.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(r.parse(JSON.parse(n)));
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      },
      parse: function (e) {
        const t = {},
          n = {};
        function i(e, i) {
          if (void 0 !== t[i]) return t[i];
          const r = e.interleavedBuffers[i],
            o = (function (e, t) {
              if (void 0 !== n[t]) return n[t];
              const i = e.arrayBuffers[t],
                r = new Uint32Array(i).buffer;
              return (n[t] = r), r;
            })(e, r.buffer),
            s = new Nr(It(r.type, o), r.stride);
          return (s.uuid = r.uuid), (t[i] = s), s;
        }
        const r = e.isInstancedBufferGeometry ? new Za() : new Ht(),
          o = e.data.index;
        if (void 0 !== o) {
          const e = It(o.type, o.array);
          r.setIndex(new xt(e, 1));
        }
        const s = e.data.attributes;
        for (const t in s) {
          const n = s[t];
          let o;
          if (n.isInterleavedBufferAttribute)
            o = new Fr(i(e.data, n.data), n.itemSize, n.offset, n.normalized);
          else {
            const e = It(n.type, n.array);
            o = new (n.isInstancedBufferAttribute ? Ja : xt)(
              e,
              n.itemSize,
              n.normalized
            );
          }
          void 0 !== n.name && (o.name = n.name), r.setAttribute(t, o);
        }
        const a = e.data.morphAttributes;
        if (a)
          for (const t in a) {
            const n = a[t],
              o = [];
            for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              let s;
              (s = r.isInterleavedBufferAttribute
                ? new Fr(i(e.data, r.data), r.itemSize, r.offset, r.normalized)
                : new xt(It(r.type, r.array), r.itemSize, r.normalized)),
                void 0 !== r.name && (s.name = r.name),
                o.push(s);
            }
            r.morphAttributes[t] = o;
          }
        e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
        const c = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (void 0 !== c)
          for (let e = 0, t = c.length; e !== t; ++e) {
            const t = c[e];
            r.addGroup(t.start, t.count, t.materialIndex);
          }
        const l = e.data.boundingSphere;
        if (void 0 !== l) {
          const e = new W();
          void 0 !== l.center && e.fromArray(l.center),
            (r.boundingSphere = new he(e, l.radius));
        }
        return (
          e.name && (r.name = e.name),
          e.userData && (r.userData = e.userData),
          r
        );
      },
    })),
    (Qa.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: Qa,
      isImageBitmapLoader: !0,
      setOptions: function (e) {
        return (this.options = e), this;
      },
      load: function (e, t, n, i) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const r = this,
          o = Ks.get(e);
        if (void 0 !== o)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(o), r.manager.itemEnd(e);
            }, 0),
            o
          );
        const s = {};
        (s.credentials =
          "anonymous" === this.crossOrigin ? "same-origin" : "include"),
          fetch(e, s)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(e, r.options);
            })
            .then(function (n) {
              Ks.add(e, n), t && t(n), r.manager.itemEnd(e);
            })
            .catch(function (t) {
              i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
            }),
          r.manager.itemStart(e);
      },
    })),
    Object.assign($a.prototype, {
      moveTo: function (e, t) {
        return (
          (this.currentPath = new Ca()),
          this.subPaths.push(this.currentPath),
          this.currentPath.moveTo(e, t),
          this
        );
      },
      lineTo: function (e, t) {
        return this.currentPath.lineTo(e, t), this;
      },
      quadraticCurveTo: function (e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i), this;
      },
      bezierCurveTo: function (e, t, n, i, r, o) {
        return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
      },
      splineThru: function (e) {
        return this.currentPath.splineThru(e), this;
      },
      toShapes: function (e, t) {
        function n(e) {
          const t = [];
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n],
              r = new Pa();
            (r.curves = i.curves), t.push(r);
          }
          return t;
        }
        function i(e, t) {
          const n = t.length;
          let i = !1;
          for (let r = n - 1, o = 0; o < n; r = o++) {
            let n = t[r],
              s = t[o],
              a = s.x - n.x,
              c = s.y - n.y;
            if (Math.abs(c) > Number.EPSILON) {
              if (
                (c < 0 && ((n = t[o]), (a = -a), (s = t[r]), (c = -c)),
                e.y < n.y || e.y > s.y)
              )
                continue;
              if (e.y === n.y) {
                if (e.x === n.x) return !0;
              } else {
                const t = c * (e.x - n.x) - a * (e.y - n.y);
                if (0 === t) return !0;
                if (t < 0) continue;
                i = !i;
              }
            } else {
              if (e.y !== n.y) continue;
              if ((s.x <= e.x && e.x <= n.x) || (n.x <= e.x && e.x <= s.x))
                return !0;
            }
          }
          return i;
        }
        const r = ms.isClockWise,
          o = this.subPaths;
        if (0 === o.length) return [];
        if (!0 === t) return n(o);
        let s, a, c;
        const l = [];
        if (1 === o.length)
          return (
            (a = o[0]), (c = new Pa()), (c.curves = a.curves), l.push(c), l
          );
        let h = !r(o[0].getPoints());
        h = e ? !h : h;
        const u = [],
          d = [];
        let p,
          f,
          m = [],
          g = 0;
        (d[g] = void 0), (m[g] = []);
        for (let t = 0, n = o.length; t < n; t++)
          (a = o[t]),
            (p = a.getPoints()),
            (s = r(p)),
            (s = e ? !s : s),
            s
              ? (!h && d[g] && g++,
                (d[g] = { s: new Pa(), p }),
                (d[g].s.curves = a.curves),
                h && g++,
                (m[g] = []))
              : m[g].push({ h: a, p: p[0] });
        if (!d[0]) return n(o);
        if (d.length > 1) {
          let e = !1;
          const t = [];
          for (let e = 0, t = d.length; e < t; e++) u[e] = [];
          for (let n = 0, r = d.length; n < r; n++) {
            const r = m[n];
            for (let o = 0; o < r.length; o++) {
              const s = r[o];
              let a = !0;
              for (let r = 0; r < d.length; r++)
                i(s.p, d[r].p) &&
                  (n !== r && t.push({ froms: n, tos: r, hole: o }),
                  a ? ((a = !1), u[r].push(s)) : (e = !0));
              a && u[n].push(s);
            }
          }
          t.length > 0 && (e || (m = u));
        }
        for (let e = 0, t = d.length; e < t; e++) {
          (c = d[e].s), l.push(c), (f = m[e]);
          for (let e = 0, t = f.length; e < t; e++) c.holes.push(f[e].h);
        }
        return l;
      },
    }),
    Object.assign(ec.prototype, {
      isFont: !0,
      generateShapes: function (e, t = 100) {
        const n = [],
          i = (function (e, t, n) {
            const i = Array.from ? Array.from(e) : String(e).split(""),
              r = t / n.resolution,
              o =
                (n.boundingBox.yMax -
                  n.boundingBox.yMin +
                  n.underlineThickness) *
                r,
              s = [];
            let a = 0,
              c = 0;
            for (let e = 0; e < i.length; e++) {
              const t = i[e];
              if ("\n" === t) (a = 0), (c -= o);
              else {
                const e = tc(t, r, a, c, n);
                (a += e.offsetX), s.push(e.path);
              }
            }
            return s;
          })(e, t, this.data);
        for (let e = 0, t = i.length; e < t; e++)
          Array.prototype.push.apply(n, i[e].toShapes());
        return n;
      },
    }),
    (nc.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: nc,
      load: function (e, t, n, i) {
        const r = this,
          o = new na(this.manager);
        o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(r.withCredentials),
          o.load(
            e,
            function (e) {
              let n;
              try {
                n = JSON.parse(e);
              } catch (t) {
                console.warn(
                  "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                ),
                  (n = JSON.parse(e.substring(65, e.length - 2)));
              }
              const i = r.parse(n);
              t && t(i);
            },
            n,
            i
          );
      },
      parse: function (e) {
        return new ec(e);
      },
    }));
  function rc(e) {
    ea.call(this, e);
  }
  function oc(e, t, n) {
    Wa.call(this, void 0, n);
    const i = new dt().set(e),
      r = new dt().set(t),
      o = new W(i.r, i.g, i.b),
      s = new W(r.r, r.g, r.b),
      a = Math.sqrt(Math.PI),
      c = a * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
      this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
  }
  function sc(e, t) {
    Wa.call(this, void 0, t);
    const n = new dt().set(e);
    this.sh.coefficients[0]
      .set(n.r, n.g, n.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  (rc.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: rc,
    load: function (e, t, n, i) {
      const r = this,
        o = new na(r.manager);
      o.setResponseType("arraybuffer"),
        o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.setWithCredentials(r.withCredentials),
        o.load(
          e,
          function (n) {
            try {
              const e = n.slice(0);
              (void 0 === ic &&
                (ic = new (window.AudioContext || window.webkitAudioContext)()),
              ic).decodeAudioData(e, function (e) {
                t(e);
              });
            } catch (t) {
              i ? i(t) : console.error(t), r.manager.itemError(e);
            }
          },
          n,
          i
        );
    },
  })),
    (oc.prototype = Object.assign(Object.create(Wa.prototype), {
      constructor: oc,
      isHemisphereLightProbe: !0,
      copy: function (e) {
        return Wa.prototype.copy.call(this, e), this;
      },
      toJSON: function (e) {
        return Wa.prototype.toJSON.call(this, e);
      },
    })),
    (sc.prototype = Object.assign(Object.create(Wa.prototype), {
      constructor: sc,
      isAmbientLightProbe: !0,
      copy: function (e) {
        return Wa.prototype.copy.call(this, e), this;
      },
      toJSON: function (e) {
        return Wa.prototype.toJSON.call(this, e);
      },
    }));
  const ac = new xe(),
    cc = new xe();
  Object.assign(
    function () {
      (this.type = "StereoCamera"),
        (this.aspect = 1),
        (this.eyeSep = 0.064),
        (this.cameraL = new mn()),
        this.cameraL.layers.enable(1),
        (this.cameraL.matrixAutoUpdate = !1),
        (this.cameraR = new mn()),
        this.cameraR.layers.enable(2),
        (this.cameraR.matrixAutoUpdate = !1),
        (this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null,
        });
    }.prototype,
    {
      update: function (e) {
        const t = this._cache;
        if (
          t.focus !== e.focus ||
          t.fov !== e.fov ||
          t.aspect !== e.aspect * this.aspect ||
          t.near !== e.near ||
          t.far !== e.far ||
          t.zoom !== e.zoom ||
          t.eyeSep !== this.eyeSep
        ) {
          (t.focus = e.focus),
            (t.fov = e.fov),
            (t.aspect = e.aspect * this.aspect),
            (t.near = e.near),
            (t.far = e.far),
            (t.zoom = e.zoom),
            (t.eyeSep = this.eyeSep);
          const n = e.projectionMatrix.clone(),
            i = t.eyeSep / 2,
            r = (i * t.near) / t.focus,
            o = (t.near * Math.tan(I.DEG2RAD * t.fov * 0.5)) / t.zoom;
          let s, a;
          (cc.elements[12] = -i),
            (ac.elements[12] = i),
            (s = -o * t.aspect + r),
            (a = o * t.aspect + r),
            (n.elements[0] = (2 * t.near) / (a - s)),
            (n.elements[8] = (a + s) / (a - s)),
            this.cameraL.projectionMatrix.copy(n),
            (s = -o * t.aspect - r),
            (a = o * t.aspect - r),
            (n.elements[0] = (2 * t.near) / (a - s)),
            (n.elements[8] = (a + s) / (a - s)),
            this.cameraR.projectionMatrix.copy(n);
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(cc),
          this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ac);
      },
    }
  );
  function lc() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  function hc(e, t, n) {
    let i, r, o;
    switch (((this.binding = e), (this.valueSize = n), t)) {
      case "quaternion":
        (i = this._slerp),
          (r = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(6 * n)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (r = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(5 * n));
        break;
      default:
        (i = this._lerp),
          (r = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(5 * n));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = r),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  Object.assign(hc.prototype, {
    accumulate: function (e, t) {
      const n = this.buffer,
        i = this.valueSize,
        r = e * i + i;
      let o = this.cumulativeWeight;
      if (0 === o) {
        for (let e = 0; e !== i; ++e) n[r + e] = n[e];
        o = t;
      } else {
        o += t;
        const e = t / o;
        this._mixBufferRegion(n, r, 0, e, i);
      }
      this.cumulativeWeight = o;
    },
    accumulateAdditive: function (e) {
      const t = this.buffer,
        n = this.valueSize,
        i = n * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, n),
        (this.cumulativeWeightAdditive += e);
    },
    apply: function (e) {
      const t = this.valueSize,
        n = this.buffer,
        i = e * t + t,
        r = this.cumulativeWeight,
        o = this.cumulativeWeightAdditive,
        s = this.binding;
      if (
        ((this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        r < 1)
      ) {
        const e = t * this._origIndex;
        this._mixBufferRegion(n, i, e, 1 - r, t);
      }
      o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
      for (let e = t, r = t + t; e !== r; ++e)
        if (n[e] !== n[e + t]) {
          s.setValue(n, i);
          break;
        }
    },
    saveOriginalState: function () {
      const e = this.binding,
        t = this.buffer,
        n = this.valueSize,
        i = n * this._origIndex;
      e.getValue(t, i);
      for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
      this._setIdentity(),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0);
    },
    restoreOriginalState: function () {
      const e = 3 * this.valueSize;
      this.binding.setValue(this.buffer, e);
    },
    _setAdditiveIdentityNumeric: function () {
      const e = this._addIndex * this.valueSize,
        t = e + this.valueSize;
      for (let n = e; n < t; n++) this.buffer[n] = 0;
    },
    _setAdditiveIdentityQuaternion: function () {
      this._setAdditiveIdentityNumeric(),
        (this.buffer[this._addIndex * this.valueSize + 3] = 1);
    },
    _setAdditiveIdentityOther: function () {
      const e = this._origIndex * this.valueSize,
        t = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++)
        this.buffer[t + n] = this.buffer[e + n];
    },
    _select: function (e, t, n, i, r) {
      if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
    },
    _slerp: function (e, t, n, i) {
      j.slerpFlat(e, t, e, t, e, n, i);
    },
    _slerpAdditive: function (e, t, n, i, r) {
      const o = this._workIndex * r;
      j.multiplyQuaternionsFlat(e, o, e, t, e, n),
        j.slerpFlat(e, t, e, t, e, o, i);
    },
    _lerp: function (e, t, n, i, r) {
      const o = 1 - i;
      for (let s = 0; s !== r; ++s) {
        const r = t + s;
        e[r] = e[r] * o + e[n + s] * i;
      }
    },
    _lerpAdditive: function (e, t, n, i, r) {
      for (let o = 0; o !== r; ++o) {
        const r = t + o;
        e[r] = e[r] + e[n + o] * i;
      }
    },
  });
  const uc = new RegExp("[\\[\\]\\.:\\/]", "g"),
    dc = "[^\\[\\]\\.:\\/]",
    pc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
    fc = /((?:WC+[\/:])*)/.source.replace("WC", dc),
    mc = /(WCOD+)?/.source.replace("WCOD", pc),
    gc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", dc),
    vc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", dc),
    yc = new RegExp("^" + fc + mc + gc + vc + "$"),
    xc = ["material", "materials", "bones"];
  function _c(e, t, n) {
    const i = n || bc.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  function bc(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || bc.parseTrackName(t)),
      (this.node = bc.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e);
  }
  Object.assign(_c.prototype, {
    getValue: function (e, t) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(e, t);
    },
    setValue: function (e, t) {
      const n = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(e, t);
    },
    bind: function () {
      const e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, n = e.length;
        t !== n;
        ++t
      )
        e[t].bind();
    },
    unbind: function () {
      const e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, n = e.length;
        t !== n;
        ++t
      )
        e[t].unbind();
    },
  }),
    Object.assign(bc, {
      Composite: _c,
      create: function (e, t, n) {
        return e && e.isAnimationObjectGroup
          ? new bc.Composite(e, t, n)
          : new bc(e, t, n);
      },
      sanitizeNodeName: function (e) {
        return e.replace(/\s/g, "_").replace(uc, "");
      },
      parseTrackName: function (e) {
        const t = yc.exec(e);
        if (!t)
          throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
          const e = n.nodeName.substring(i + 1);
          -1 !== xc.indexOf(e) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + e
          );
        return n;
      },
      findNode: function (e, t) {
        if (
          !t ||
          "" === t ||
          "." === t ||
          -1 === t ||
          t === e.name ||
          t === e.uuid
        )
          return e;
        if (e.skeleton) {
          const n = e.skeleton.getBoneByName(t);
          if (void 0 !== n) return n;
        }
        if (e.children) {
          const n = function (e) {
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                if (r.name === t || r.uuid === t) return r;
                const o = n(r.children);
                if (o) return o;
              }
              return null;
            },
            i = n(e.children);
          if (i) return i;
        }
        return null;
      },
    }),
    Object.assign(bc.prototype, {
      _getValue_unavailable: function () {},
      _setValue_unavailable: function () {},
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      },
      Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
      GetterByBindingType: [
        function (e, t) {
          e[t] = this.node[this.propertyName];
        },
        function (e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        },
        function (e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        },
        function (e, t) {
          this.resolvedProperty.toArray(e, t);
        },
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function (e, t) {
            this.targetObject[this.propertyName] = e[t];
          },
          function (e, t) {
            (this.targetObject[this.propertyName] = e[t]),
              (this.targetObject.needsUpdate = !0);
          },
          function (e, t) {
            (this.targetObject[this.propertyName] = e[t]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          },
          function (e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0;
          },
          function (e, t) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          },
        ],
        [
          function (e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t];
          },
          function (e, t) {
            (this.resolvedProperty[this.propertyIndex] = e[t]),
              (this.targetObject.needsUpdate = !0);
          },
          function (e, t) {
            (this.resolvedProperty[this.propertyIndex] = e[t]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (e, t) {
            this.resolvedProperty.fromArray(e, t);
          },
          function (e, t) {
            this.resolvedProperty.fromArray(e, t),
              (this.targetObject.needsUpdate = !0);
          },
          function (e, t) {
            this.resolvedProperty.fromArray(e, t),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
      ],
      getValue: function (e, t) {
        this.bind(), this.getValue(e, t);
      },
      setValue: function (e, t) {
        this.bind(), this.setValue(e, t);
      },
      bind: function () {
        let e = this.node;
        const t = this.parsedPath,
          n = t.objectName,
          i = t.propertyName;
        let r = t.propertyIndex;
        if (
          (e ||
            ((e = bc.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        )
          return void console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
        if (n) {
          let i = t.objectIndex;
          switch (n) {
            case "materials":
              if (!e.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!e.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              e = e.skeleton.bones;
              for (let t = 0; t < e.length; t++)
                if (e[t].name === i) {
                  i = t;
                  break;
                }
              break;
            default:
              if (void 0 === e[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              e = e[n];
          }
          if (void 0 !== i) {
            if (void 0 === e[i])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                e
              );
            e = e[i];
          }
        }
        const o = e[i];
        if (void 0 === o) {
          const n = t.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              i +
              " but it wasn't found.",
            e
          );
        }
        let s = this.Versioning.None;
        (this.targetObject = e),
          void 0 !== e.needsUpdate
            ? (s = this.Versioning.NeedsUpdate)
            : void 0 !== e.matrixWorldNeedsUpdate &&
              (s = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === i) {
            if (!e.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!e.geometry.isBufferGeometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                this
              );
            if (!e.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== e.morphTargetDictionary[r] &&
              (r = e.morphTargetDictionary[r]);
          }
          (a = this.BindingType.ArrayElement),
            (this.resolvedProperty = o),
            (this.propertyIndex = r);
        } else
          void 0 !== o.fromArray && void 0 !== o.toArray
            ? ((a = this.BindingType.HasFromToArray),
              (this.resolvedProperty = o))
            : Array.isArray(o)
            ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = o))
            : (this.propertyName = i);
        (this.getValue = this.GetterByBindingType[a]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
      },
      unbind: function () {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      },
    }),
    Object.assign(bc.prototype, {
      _getValue_unbound: bc.prototype.getValue,
      _setValue_unbound: bc.prototype.setValue,
    }),
    Object.assign(
      function () {
        (this.uuid = I.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        const e = {};
        this._indicesByUUID = e;
        for (let t = 0, n = arguments.length; t !== n; ++t)
          e[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        const t = this;
        this.stats = {
          objects: {
            get total() {
              return t._objects.length;
            },
            get inUse() {
              return this.total - t.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return t._bindings.length;
          },
        };
      }.prototype,
      {
        isAnimationObjectGroup: !0,
        add: function () {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            r = this._bindings,
            o = r.length;
          let s,
            a = e.length,
            c = this.nCachedObjects_;
          for (let l = 0, h = arguments.length; l !== h; ++l) {
            const h = arguments[l],
              u = h.uuid;
            let d = t[u];
            if (void 0 === d) {
              (d = a++), (t[u] = d), e.push(h);
              for (let e = 0, t = o; e !== t; ++e)
                r[e].push(new bc(h, n[e], i[e]));
            } else if (d < c) {
              s = e[d];
              const a = --c,
                l = e[a];
              (t[l.uuid] = d), (e[d] = l), (t[u] = a), (e[a] = h);
              for (let e = 0, t = o; e !== t; ++e) {
                const t = r[e],
                  o = t[a];
                let s = t[d];
                (t[d] = o),
                  void 0 === s && (s = new bc(h, n[e], i[e])),
                  (t[a] = s);
              }
            } else
              e[d] !== s &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = c;
        },
        remove: function () {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_;
          for (let o = 0, s = arguments.length; o !== s; ++o) {
            const s = arguments[o],
              a = s.uuid,
              c = t[a];
            if (void 0 !== c && c >= r) {
              const o = r++,
                l = e[o];
              (t[l.uuid] = c), (e[c] = l), (t[a] = o), (e[o] = s);
              for (let e = 0, t = i; e !== t; ++e) {
                const t = n[e],
                  i = t[o],
                  r = t[c];
                (t[c] = i), (t[o] = r);
              }
            }
          }
          this.nCachedObjects_ = r;
        },
        uncache: function () {
          const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
          let r = this.nCachedObjects_,
            o = e.length;
          for (let s = 0, a = arguments.length; s !== a; ++s) {
            const a = arguments[s].uuid,
              c = t[a];
            if (void 0 !== c)
              if ((delete t[a], c < r)) {
                const s = --r,
                  a = e[s],
                  l = --o,
                  h = e[l];
                (t[a.uuid] = c),
                  (e[c] = a),
                  (t[h.uuid] = s),
                  (e[s] = h),
                  e.pop();
                for (let e = 0, t = i; e !== t; ++e) {
                  const t = n[e],
                    i = t[s],
                    r = t[l];
                  (t[c] = i), (t[s] = r), t.pop();
                }
              } else {
                const r = --o,
                  s = e[r];
                r > 0 && (t[s.uuid] = c), (e[c] = s), e.pop();
                for (let e = 0, t = i; e !== t; ++e) {
                  const t = n[e];
                  (t[c] = t[r]), t.pop();
                }
              }
          }
          this.nCachedObjects_ = r;
        },
        subscribe_: function (e, t) {
          const n = this._bindingsIndicesByPath;
          let i = n[e];
          const r = this._bindings;
          if (void 0 !== i) return r[i];
          const o = this._paths,
            s = this._parsedPaths,
            a = this._objects,
            c = a.length,
            l = this.nCachedObjects_,
            h = new Array(c);
          (i = r.length), (n[e] = i), o.push(e), s.push(t), r.push(h);
          for (let n = l, i = a.length; n !== i; ++n) {
            const i = a[n];
            h[n] = new bc(i, e, t);
          }
          return h;
        },
        unsubscribe_: function (e) {
          const t = this._bindingsIndicesByPath,
            n = t[e];
          if (void 0 !== n) {
            const i = this._paths,
              r = this._parsedPaths,
              o = this._bindings,
              s = o.length - 1,
              a = o[s];
            (t[e[s]] = n),
              (o[n] = a),
              o.pop(),
              (r[n] = r[s]),
              r.pop(),
              (i[n] = i[s]),
              i.pop();
          }
        },
      }
    );
  class wc {
    constructor(e, t, n = null, i = t.blendMode) {
      (this._mixer = e),
        (this._clip = t),
        (this._localRoot = n),
        (this.blendMode = i);
      const r = t.tracks,
        o = r.length,
        s = new Array(o),
        a = { endingStart: b, endingEnd: b };
      for (let e = 0; e !== o; ++e) {
        const t = r[e].createInterpolant(null);
        (s[e] = t), (t.settings = a);
      }
      (this._interpolantSettings = a),
        (this._interpolants = s),
        (this._propertyBindings = new Array(o)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = 2201),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return (
        (this.paused = !1),
        (this.enabled = !0),
        (this.time = 0),
        (this._loopCount = -1),
        (this._startTime = null),
        this.stopFading().stopWarping()
      );
    }
    isRunning() {
      return (
        this.enabled &&
        !this.paused &&
        0 !== this.timeScale &&
        null === this._startTime &&
        this._mixer._isActiveAction(this)
      );
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e) {
      return (this._startTime = e), this;
    }
    setLoop(e, t) {
      return (this.loop = e), (this.repetitions = t), this;
    }
    setEffectiveWeight(e) {
      return (
        (this.weight = e),
        (this._effectiveWeight = this.enabled ? e : 0),
        this.stopFading()
      );
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e) {
      return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
      return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, n) {
      if ((e.fadeOut(t), this.fadeIn(t), n)) {
        const n = this._clip.duration,
          i = e._clip.duration,
          r = i / n,
          o = n / i;
        e.warp(1, r, t), this.warp(o, 1, t);
      }
      return this;
    }
    crossFadeTo(e, t, n) {
      return e.crossFadeFrom(this, t, n);
    }
    stopFading() {
      const e = this._weightInterpolant;
      return (
        null !== e &&
          ((this._weightInterpolant = null),
          this._mixer._takeBackControlInterpolant(e)),
        this
      );
    }
    setEffectiveTimeScale(e) {
      return (
        (this.timeScale = e),
        (this._effectiveTimeScale = this.paused ? 0 : e),
        this.stopWarping()
      );
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e) {
      return (this.timeScale = this._clip.duration / e), this.stopWarping();
    }
    syncWith(e) {
      return (
        (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
      );
    }
    halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, n) {
      const i = this._mixer,
        r = i.time,
        o = this.timeScale;
      let s = this._timeScaleInterpolant;
      null === s &&
        ((s = i._lendControlInterpolant()), (this._timeScaleInterpolant = s));
      const a = s.parameterPositions,
        c = s.sampleValues;
      return (a[0] = r), (a[1] = r + n), (c[0] = e / o), (c[1] = t / o), this;
    }
    stopWarping() {
      const e = this._timeScaleInterpolant;
      return (
        null !== e &&
          ((this._timeScaleInterpolant = null),
          this._mixer._takeBackControlInterpolant(e)),
        this
      );
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e, t, n, i) {
      if (!this.enabled) return void this._updateWeight(e);
      const r = this._startTime;
      if (null !== r) {
        const i = (e - r) * n;
        if (i < 0 || 0 === n) return;
        (this._startTime = null), (t = n * i);
      }
      t *= this._updateTimeScale(e);
      const o = this._updateTime(t),
        s = this._updateWeight(e);
      if (s > 0) {
        const e = this._interpolants,
          t = this._propertyBindings;
        if (2501 === this.blendMode)
          for (let n = 0, i = e.length; n !== i; ++n)
            e[n].evaluate(o), t[n].accumulateAdditive(s);
        else
          for (let n = 0, r = e.length; n !== r; ++n)
            e[n].evaluate(o), t[n].accumulate(i, s);
      }
    }
    _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
        t = this.weight;
        const n = this._weightInterpolant;
        if (null !== n) {
          const i = n.evaluate(e)[0];
          (t *= i),
            e > n.parameterPositions[1] &&
              (this.stopFading(), 0 === i && (this.enabled = !1));
        }
      }
      return (this._effectiveWeight = t), t;
    }
    _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
        t = this.timeScale;
        const n = this._timeScaleInterpolant;
        null !== n &&
          ((t *= n.evaluate(e)[0]),
          e > n.parameterPositions[1] &&
            (this.stopWarping(),
            0 === t ? (this.paused = !0) : (this.timeScale = t)));
      }
      return (this._effectiveTimeScale = t), t;
    }
    _updateTime(e) {
      const t = this._clip.duration,
        n = this.loop;
      let i = this.time + e,
        r = this._loopCount;
      const o = 2202 === n;
      if (0 === e) return -1 === r ? i : o && 1 == (1 & r) ? t - i : i;
      if (2200 === n) {
        -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
        e: {
          if (i >= t) i = t;
          else {
            if (!(i < 0)) {
              this.time = i;
              break e;
            }
            i = 0;
          }
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e < 0 ? -1 : 1,
            });
        }
      } else {
        if (
          (-1 === r &&
            (e >= 0
              ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
              : this._setEndings(0 === this.repetitions, !0, o)),
          i >= t || i < 0)
        ) {
          const n = Math.floor(i / t);
          (i -= t * n), (r += Math.abs(n));
          const s = this.repetitions - r;
          if (s <= 0)
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (i = e > 0 ? t : 0),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e > 0 ? 1 : -1,
              });
          else {
            if (1 === s) {
              const t = e < 0;
              this._setEndings(t, !t, o);
            } else this._setEndings(!1, !1, o);
            (this._loopCount = r),
              (this.time = i),
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: n,
              });
          }
        } else this.time = i;
        if (o && 1 == (1 & r)) return t - i;
      }
      return i;
    }
    _setEndings(e, t, n) {
      const i = this._interpolantSettings;
      n
        ? ((i.endingStart = w), (i.endingEnd = w))
        : ((i.endingStart = e ? (this.zeroSlopeAtStart ? w : b) : M),
          (i.endingEnd = t ? (this.zeroSlopeAtEnd ? w : b) : M));
    }
    _scheduleFading(e, t, n) {
      const i = this._mixer,
        r = i.time;
      let o = this._weightInterpolant;
      null === o &&
        ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
      const s = o.parameterPositions,
        a = o.sampleValues;
      return (s[0] = r), (a[0] = t), (s[1] = r + e), (a[1] = n), this;
    }
  }
  function Mc(e) {
    (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  Mc.prototype = Object.assign(Object.create(C.prototype), {
    constructor: Mc,
    _bindAction: function (e, t) {
      const n = e._localRoot || this._root,
        i = e._clip.tracks,
        r = i.length,
        o = e._propertyBindings,
        s = e._interpolants,
        a = n.uuid,
        c = this._bindingsByRootAndName;
      let l = c[a];
      void 0 === l && ((l = {}), (c[a] = l));
      for (let e = 0; e !== r; ++e) {
        const r = i[e],
          c = r.name;
        let h = l[c];
        if (void 0 !== h) o[e] = h;
        else {
          if (((h = o[e]), void 0 !== h)) {
            null === h._cacheIndex &&
              (++h.referenceCount, this._addInactiveBinding(h, a, c));
            continue;
          }
          const i = t && t._propertyBindings[e].binding.parsedPath;
          (h = new hc(bc.create(n, c, i), r.ValueTypeName, r.getValueSize())),
            ++h.referenceCount,
            this._addInactiveBinding(h, a, c),
            (o[e] = h);
        }
        s[e].resultBuffer = h.buffer;
      }
    },
    _activateAction: function (e) {
      if (!this._isActiveAction(e)) {
        if (null === e._cacheIndex) {
          const t = (e._localRoot || this._root).uuid,
            n = e._clip.uuid,
            i = this._actionsByClip[n];
          this._bindAction(e, i && i.knownActions[0]),
            this._addInactiveAction(e, n, t);
        }
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
        }
        this._lendAction(e);
      }
    },
    _deactivateAction: function (e) {
      if (this._isActiveAction(e)) {
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == --n.useCount &&
            (n.restoreOriginalState(), this._takeBackBinding(n));
        }
        this._takeBackAction(e);
      }
    },
    _initMemoryManager: function () {
      (this._actions = []),
        (this._nActiveActions = 0),
        (this._actionsByClip = {}),
        (this._bindings = []),
        (this._nActiveBindings = 0),
        (this._bindingsByRootAndName = {}),
        (this._controlInterpolants = []),
        (this._nActiveControlInterpolants = 0);
      const e = this;
      this.stats = {
        actions: {
          get total() {
            return e._actions.length;
          },
          get inUse() {
            return e._nActiveActions;
          },
        },
        bindings: {
          get total() {
            return e._bindings.length;
          },
          get inUse() {
            return e._nActiveBindings;
          },
        },
        controlInterpolants: {
          get total() {
            return e._controlInterpolants.length;
          },
          get inUse() {
            return e._nActiveControlInterpolants;
          },
        },
      };
    },
    _isActiveAction: function (e) {
      const t = e._cacheIndex;
      return null !== t && t < this._nActiveActions;
    },
    _addInactiveAction: function (e, t, n) {
      const i = this._actions,
        r = this._actionsByClip;
      let o = r[t];
      if (void 0 === o)
        (o = { knownActions: [e], actionByRoot: {} }),
          (e._byClipCacheIndex = 0),
          (r[t] = o);
      else {
        const t = o.knownActions;
        (e._byClipCacheIndex = t.length), t.push(e);
      }
      (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
    },
    _removeInactiveAction: function (e) {
      const t = this._actions,
        n = t[t.length - 1],
        i = e._cacheIndex;
      (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
      const r = e._clip.uuid,
        o = this._actionsByClip,
        s = o[r],
        a = s.knownActions,
        c = a[a.length - 1],
        l = e._byClipCacheIndex;
      (c._byClipCacheIndex = l),
        (a[l] = c),
        a.pop(),
        (e._byClipCacheIndex = null),
        delete s.actionByRoot[(e._localRoot || this._root).uuid],
        0 === a.length && delete o[r],
        this._removeInactiveBindingsForAction(e);
    },
    _removeInactiveBindingsForAction: function (e) {
      const t = e._propertyBindings;
      for (let e = 0, n = t.length; e !== n; ++e) {
        const n = t[e];
        0 == --n.referenceCount && this._removeInactiveBinding(n);
      }
    },
    _lendAction: function (e) {
      const t = this._actions,
        n = e._cacheIndex,
        i = this._nActiveActions++,
        r = t[i];
      (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
    },
    _takeBackAction: function (e) {
      const t = this._actions,
        n = e._cacheIndex,
        i = --this._nActiveActions,
        r = t[i];
      (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
    },
    _addInactiveBinding: function (e, t, n) {
      const i = this._bindingsByRootAndName,
        r = this._bindings;
      let o = i[t];
      void 0 === o && ((o = {}), (i[t] = o)),
        (o[n] = e),
        (e._cacheIndex = r.length),
        r.push(e);
    },
    _removeInactiveBinding: function (e) {
      const t = this._bindings,
        n = e.binding,
        i = n.rootNode.uuid,
        r = n.path,
        o = this._bindingsByRootAndName,
        s = o[i],
        a = t[t.length - 1],
        c = e._cacheIndex;
      (a._cacheIndex = c),
        (t[c] = a),
        t.pop(),
        delete s[r],
        0 === Object.keys(s).length && delete o[i];
    },
    _lendBinding: function (e) {
      const t = this._bindings,
        n = e._cacheIndex,
        i = this._nActiveBindings++,
        r = t[i];
      (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
    },
    _takeBackBinding: function (e) {
      const t = this._bindings,
        n = e._cacheIndex,
        i = --this._nActiveBindings,
        r = t[i];
      (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
    },
    _lendControlInterpolant: function () {
      const e = this._controlInterpolants,
        t = this._nActiveControlInterpolants++;
      let n = e[t];
      return (
        void 0 === n &&
          ((n = new Bs(
            new Float32Array(2),
            new Float32Array(2),
            1,
            this._controlInterpolantsResultBuffer
          )),
          (n.__cacheIndex = t),
          (e[t] = n)),
        n
      );
    },
    _takeBackControlInterpolant: function (e) {
      const t = this._controlInterpolants,
        n = e.__cacheIndex,
        i = --this._nActiveControlInterpolants,
        r = t[i];
      (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function (e, t, n) {
      const i = t || this._root,
        r = i.uuid;
      let o = "string" == typeof e ? Zs.findByName(i, e) : e;
      const s = null !== o ? o.uuid : e,
        a = this._actionsByClip[s];
      let c = null;
      if (
        (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== a)
      ) {
        const e = a.actionByRoot[r];
        if (void 0 !== e && e.blendMode === n) return e;
        (c = a.knownActions[0]), null === o && (o = c._clip);
      }
      if (null === o) return null;
      const l = new wc(this, o, t, n);
      return this._bindAction(l, c), this._addInactiveAction(l, s, r), l;
    },
    existingAction: function (e, t) {
      const n = t || this._root,
        i = n.uuid,
        r = "string" == typeof e ? Zs.findByName(n, e) : e,
        o = r ? r.uuid : e,
        s = this._actionsByClip[o];
      return (void 0 !== s && s.actionByRoot[i]) || null;
    },
    stopAllAction: function () {
      const e = this._actions;
      for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
      return this;
    },
    update: function (e) {
      e *= this.timeScale;
      const t = this._actions,
        n = this._nActiveActions,
        i = (this.time += e),
        r = Math.sign(e),
        o = (this._accuIndex ^= 1);
      for (let s = 0; s !== n; ++s) t[s]._update(i, e, r, o);
      const s = this._bindings,
        a = this._nActiveBindings;
      for (let e = 0; e !== a; ++e) s[e].apply(o);
      return this;
    },
    setTime: function (e) {
      this.time = 0;
      for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
      return this.update(e);
    },
    getRoot: function () {
      return this._root;
    },
    uncacheClip: function (e) {
      const t = this._actions,
        n = e.uuid,
        i = this._actionsByClip,
        r = i[n];
      if (void 0 !== r) {
        const e = r.knownActions;
        for (let n = 0, i = e.length; n !== i; ++n) {
          const i = e[n];
          this._deactivateAction(i);
          const r = i._cacheIndex,
            o = t[t.length - 1];
          (i._cacheIndex = null),
            (i._byClipCacheIndex = null),
            (o._cacheIndex = r),
            (t[r] = o),
            t.pop(),
            this._removeInactiveBindingsForAction(i);
        }
        delete i[n];
      }
    },
    uncacheRoot: function (e) {
      const t = e.uuid,
        n = this._actionsByClip;
      for (const e in n) {
        const i = n[e].actionByRoot[t];
        void 0 !== i &&
          (this._deactivateAction(i), this._removeInactiveAction(i));
      }
      const i = this._bindingsByRootAndName[t];
      if (void 0 !== i)
        for (const e in i) {
          const t = i[e];
          t.restoreOriginalState(), this._removeInactiveBinding(t);
        }
    },
    uncacheAction: function (e, t) {
      const n = this.existingAction(e, t);
      null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
    },
  });
  class Sc {
    constructor(e) {
      "string" == typeof e &&
        (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        (e = arguments[1])),
        (this.value = e);
    }
    clone() {
      return new Sc(
        void 0 === this.value.clone ? this.value : this.value.clone()
      );
    }
  }
  function Ec(e, t, n) {
    Nr.call(this, e, t), (this.meshPerAttribute = n || 1);
  }
  function Tc(e, t, n, i, r) {
    (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = r),
      (this.version = 0);
  }
  function Ac(e, t, n, i) {
    (this.ray = new ye(e, t)),
      (this.near = n || 0),
      (this.far = i || 1 / 0),
      (this.camera = null),
      (this.layers = new Ce()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }),
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function () {
            return (
              console.warn(
                "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
              ),
              this.Points
            );
          },
        },
      });
  }
  function Lc(e, t) {
    return e.distance - t.distance;
  }
  function Rc(e, t, n, i) {
    if ((e.layers.test(t.layers) && e.raycast(t, n), !0 === i)) {
      const i = e.children;
      for (let e = 0, r = i.length; e < r; e++) Rc(i[e], t, n, !0);
    }
  }
  (Ec.prototype = Object.assign(Object.create(Nr.prototype), {
    constructor: Ec,
    isInstancedInterleavedBuffer: !0,
    copy: function (e) {
      return (
        Nr.prototype.copy.call(this, e),
        (this.meshPerAttribute = e.meshPerAttribute),
        this
      );
    },
    clone: function (e) {
      const t = Nr.prototype.clone.call(this, e);
      return (t.meshPerAttribute = this.meshPerAttribute), t;
    },
    toJSON: function (e) {
      const t = Nr.prototype.toJSON.call(this, e);
      return (
        (t.isInstancedInterleavedBuffer = !0),
        (t.meshPerAttribute = this.meshPerAttribute),
        t
      );
    },
  })),
    Object.defineProperty(Tc.prototype, "needsUpdate", {
      set: function (e) {
        !0 === e && this.version++;
      },
    }),
    Object.assign(Tc.prototype, {
      isGLBufferAttribute: !0,
      setBuffer: function (e) {
        return (this.buffer = e), this;
      },
      setType: function (e, t) {
        return (this.type = e), (this.elementSize = t), this;
      },
      setItemSize: function (e) {
        return (this.itemSize = e), this;
      },
      setCount: function (e) {
        return (this.count = e), this;
      },
    }),
    Object.assign(Ac.prototype, {
      set: function (e, t) {
        this.ray.set(e, t);
      },
      setFromCamera: function (e, t) {
        t && t.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction
              .set(e.x, e.y, 0.5)
              .unproject(t)
              .sub(this.ray.origin)
              .normalize(),
            (this.camera = t))
          : t && t.isOrthographicCamera
          ? (this.ray.origin
              .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
              .unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            (this.camera = t))
          : console.error(
              "THREE.Raycaster: Unsupported camera type: " + t.type
            );
      },
      intersectObject: function (e, t, n) {
        const i = n || [];
        return Rc(e, this, i, t), i.sort(Lc), i;
      },
      intersectObjects: function (e, t, n) {
        const i = n || [];
        if (!1 === Array.isArray(e))
          return (
            console.warn(
              "THREE.Raycaster.intersectObjects: objects is not an Array."
            ),
            i
          );
        for (let n = 0, r = e.length; n < r; n++) Rc(e[n], this, i, t);
        return i.sort(Lc), i;
      },
    });
  class Cc {
    constructor(e = 1, t = 0, n = 0) {
      return (this.radius = e), (this.phi = t), (this.theta = n), this;
    }
    set(e, t, n) {
      return (this.radius = e), (this.phi = t), (this.theta = n), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.radius = e.radius),
        (this.phi = e.phi),
        (this.theta = e.theta),
        this
      );
    }
    makeSafe() {
      const e = 1e-6;
      return (this.phi = Math.max(e, Math.min(Math.PI - e, this.phi))), this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
      return (
        (this.radius = Math.sqrt(e * e + t * t + n * n)),
        0 === this.radius
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(e, n)),
            (this.phi = Math.acos(I.clamp(t / this.radius, -1, 1)))),
        this
      );
    }
  }
  const Pc = new N();
  function Oc(e) {
    je.call(this),
      (this.material = e),
      (this.render = function () {}),
      (this.hasPositions = !1),
      (this.hasNormals = !1),
      (this.hasColors = !1),
      (this.hasUvs = !1),
      (this.positionArray = null),
      (this.normalArray = null),
      (this.colorArray = null),
      (this.uvArray = null),
      (this.count = 0);
  }
  (Oc.prototype = Object.create(je.prototype)),
    (Oc.prototype.constructor = Oc),
    (Oc.prototype.isImmediateRenderObject = !0);
  const Ic = new W(),
    Nc = new xe(),
    Dc = new xe();
  function Fc(e) {
    const t = [];
    e && e.isBone && t.push(e);
    for (let n = 0; n < e.children.length; n++)
      t.push.apply(t, Fc(e.children[n]));
    return t;
  }
  const Uc = new Float32Array(1),
    kc =
      (new Int32Array(Uc.buffer),
      Math.pow(2, 8),
      [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]),
    Bc = 5 + kc.length,
    { _lodPlanes: zc, _sizeLods: Hc, _sigmas: Gc } = Vc();
  function Vc() {
    const e = [],
      t = [],
      n = [];
    let i = 8;
    for (let r = 0; r < Bc; r++) {
      const o = Math.pow(2, i);
      t.push(o);
      let s = 1 / o;
      r > 4 ? (s = kc[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
      const a = 1 / (o - 1),
        c = -a / 2,
        l = 1 + a / 2,
        h = [c, c, l, c, l, l, c, c, l, l, c, l],
        u = 6,
        d = 6,
        p = 3,
        f = 2,
        m = 1,
        g = new Float32Array(p * d * u),
        v = new Float32Array(f * d * u),
        y = new Float32Array(m * d * u);
      for (let e = 0; e < u; e++) {
        const t = ((e % 3) * 2) / 3 - 1,
          n = e > 2 ? 0 : -1,
          i = [
            t,
            n,
            0,
            t + 2 / 3,
            n,
            0,
            t + 2 / 3,
            n + 1,
            0,
            t,
            n,
            0,
            t + 2 / 3,
            n + 1,
            0,
            t,
            n + 1,
            0,
          ];
        g.set(i, p * d * e), v.set(h, f * d * e);
        const r = [e, e, e, e, e, e];
        y.set(r, m * d * e);
      }
      const x = new Ht();
      x.setAttribute("position", new xt(g, p)),
        x.setAttribute("uv", new xt(v, f)),
        x.setAttribute("faceIndex", new xt(y, m)),
        e.push(x),
        i > 4 && i--;
    }
    return { _lodPlanes: e, _sizeLods: t, _sigmas: n };
  }
  function jc(e) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
    ),
      va.call(this, e),
      (this.type = "catmullrom");
  }
  function Wc(e, t) {
    var n = e.__state.conversionName.toString(),
      i = Math.round(e.r),
      r = Math.round(e.g),
      o = Math.round(e.b),
      s = e.a,
      a = Math.round(e.h),
      c = e.s.toFixed(1),
      l = e.v.toFixed(1);
    if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
      for (var h = e.hex.toString(16); h.length < 6; ) h = "0" + h;
      return "#" + h;
    }
    return "CSS_RGB" === n
      ? "rgb(" + i + "," + r + "," + o + ")"
      : "CSS_RGBA" === n
      ? "rgba(" + i + "," + r + "," + o + "," + s + ")"
      : "HEX" === n
      ? "0x" + e.hex.toString(16)
      : "RGB_ARRAY" === n
      ? "[" + i + "," + r + "," + o + "]"
      : "RGBA_ARRAY" === n
      ? "[" + i + "," + r + "," + o + "," + s + "]"
      : "RGB_OBJ" === n
      ? "{r:" + i + ",g:" + r + ",b:" + o + "}"
      : "RGBA_OBJ" === n
      ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + s + "}"
      : "HSV_OBJ" === n
      ? "{h:" + a + ",s:" + c + ",v:" + l + "}"
      : "HSVA_OBJ" === n
      ? "{h:" + a + ",s:" + c + ",v:" + l + ",a:" + s + "}"
      : "unknown format";
  }
  Math.sqrt(5),
    (la.create = function (e, t) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (e.prototype = Object.create(la.prototype)),
        (e.prototype.constructor = e),
        (e.prototype.getPoint = t),
        e
      );
    }),
    Object.assign(Ra.prototype, {
      createPointsGeometry: function (e) {
        console.warn(
          "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
        );
        const t = this.getPoints(e);
        return this.createGeometry(t);
      },
      createSpacedPointsGeometry: function (e) {
        console.warn(
          "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
        );
        const t = this.getSpacedPoints(e);
        return this.createGeometry(t);
      },
      createGeometry: function (e) {
        console.warn(
          "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
        );
        const t = new jo();
        for (let n = 0, i = e.length; n < i; n++) {
          const i = e[n];
          t.vertices.push(new W(i.x, i.y, i.z || 0));
        }
        return t;
      },
    }),
    Object.assign(Ca.prototype, {
      fromPoints: function (e) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(e)
        );
      },
    }),
    Object.create(va.prototype),
    Object.create(va.prototype),
    (jc.prototype = Object.create(va.prototype)),
    Object.assign(jc.prototype, {
      initFromArray: function () {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      },
      getControlPointsArray: function () {
        console.error(
          "THREE.Spline: .getControlPointsArray() has been removed."
        );
      },
      reparametrizeByArcLength: function () {
        console.error(
          "THREE.Spline: .reparametrizeByArcLength() has been removed."
        );
      },
    }),
    (class extends Ao {
      constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
        (n = new dt(n)), (i = new dt(i));
        const r = t / 2,
          o = e / t,
          s = e / 2,
          a = [],
          c = [];
        for (let e = 0, l = 0, h = -s; e <= t; e++, h += o) {
          a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
          const t = e === r ? n : i;
          t.toArray(c, l),
            (l += 3),
            t.toArray(c, l),
            (l += 3),
            t.toArray(c, l),
            (l += 3),
            t.toArray(c, l),
            (l += 3);
        }
        const l = new Ht();
        l.setAttribute("position", new Lt(a, 3)),
          l.setAttribute("color", new Lt(c, 3)),
          super(l, new yo({ vertexColors: !0, toneMapped: !1 })),
          (this.type = "GridHelper");
      }
    }.prototype.setColors = function () {
      console.error(
        "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
      );
    }),
    (class extends Ao {
      constructor(e) {
        const t = Fc(e),
          n = new Ht(),
          i = [],
          r = [],
          o = new dt(0, 0, 1),
          s = new dt(0, 1, 0);
        for (let e = 0; e < t.length; e++) {
          const n = t[e];
          n.parent &&
            n.parent.isBone &&
            (i.push(0, 0, 0),
            i.push(0, 0, 0),
            r.push(o.r, o.g, o.b),
            r.push(s.r, s.g, s.b));
        }
        n.setAttribute("position", new Lt(i, 3)),
          n.setAttribute("color", new Lt(r, 3)),
          super(
            n,
            new yo({
              vertexColors: !0,
              depthTest: !1,
              depthWrite: !1,
              toneMapped: !1,
              transparent: !0,
            })
          ),
          (this.type = "SkeletonHelper"),
          (this.isSkeletonHelper = !0),
          (this.root = e),
          (this.bones = t),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1);
      }
      updateMatrixWorld(e) {
        const t = this.bones,
          n = this.geometry,
          i = n.getAttribute("position");
        Dc.copy(this.root.matrixWorld).invert();
        for (let e = 0, n = 0; e < t.length; e++) {
          const r = t[e];
          r.parent &&
            r.parent.isBone &&
            (Nc.multiplyMatrices(Dc, r.matrixWorld),
            Ic.setFromMatrixPosition(Nc),
            i.setXYZ(n, Ic.x, Ic.y, Ic.z),
            Nc.multiplyMatrices(Dc, r.parent.matrixWorld),
            Ic.setFromMatrixPosition(Nc),
            i.setXYZ(n + 1, Ic.x, Ic.y, Ic.z),
            (n += 2));
        }
        (n.getAttribute("position").needsUpdate = !0),
          super.updateMatrixWorld(e);
      }
    }.prototype.update = function () {
      console.error(
        "THREE.SkeletonHelper: update() no longer needs to be called."
      );
    }),
    Object.assign(ea.prototype, {
      extractUrlBase: function (e) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          Ya(e)
        );
      },
    }),
    (ea.Handlers = {
      add: function () {
        console.error(
          "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
        );
      },
      get: function () {
        console.error(
          "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
        );
      },
    }),
    Object.assign(
      class {
        constructor(e, t) {
          Object.defineProperty(this, "isBox2", { value: !0 }),
            (this.min = void 0 !== e ? e : new N(1 / 0, 1 / 0)),
            (this.max = void 0 !== t ? t : new N(-1 / 0, -1 / 0));
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = Pc.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box2: .getCenter() target is now required"),
              (e = new N())),
            this.isEmpty()
              ? e.set(0, 0)
              : e.addVectors(this.min, this.max).multiplyScalar(0.5)
          );
        }
        getSize(e) {
          return (
            void 0 === e &&
              (console.warn("THREE.Box2: .getSize() target is now required"),
              (e = new N())),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
          );
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
          );
        }
        getParameter(e, t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Box2: .getParameter() target is now required"
              ),
              (t = new N())),
            t.set(
              (e.x - this.min.x) / (this.max.x - this.min.x),
              (e.y - this.min.y) / (this.max.y - this.min.y)
            )
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y
          );
        }
        clampPoint(e, t) {
          return (
            void 0 === t &&
              (console.warn("THREE.Box2: .clampPoint() target is now required"),
              (t = new N())),
            t.copy(e).clamp(this.min, this.max)
          );
        }
        distanceToPoint(e) {
          return Pc.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }.prototype,
      {
        center: function (e) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(e)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (e) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(e)
          );
        },
        size: function (e) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(e)
          );
        },
      }
    ),
    Object.assign(Y.prototype, {
      center: function (e) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      },
      empty: function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      },
      isIntersectionSphere: function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      },
      size: function (e) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      },
    }),
    Object.assign(he.prototype, {
      empty: function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      },
    }),
    (Mn.prototype.setFromMatrix = function (e) {
      return (
        console.warn(
          "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
        ),
        this.setFromProjectionMatrix(e)
      );
    }),
    Object.assign(I, {
      random16: function () {
        return (
          console.warn(
            "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
          ),
          Math.random()
        );
      },
      nearestPowerOfTwo: function (e) {
        return (
          console.warn(
            "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
          ),
          I.floorPowerOfTwo(e)
        );
      },
      nextPowerOfTwo: function (e) {
        return (
          console.warn(
            "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
          ),
          I.ceilPowerOfTwo(e)
        );
      },
    }),
    Object.assign(D.prototype, {
      flattenToArrayOffset: function (e, t) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      },
      multiplyVector3: function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      },
      applyToBufferAttribute: function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      },
      applyToVector3Array: function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      },
      getInverse: function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      },
    }),
    Object.assign(xe.prototype, {
      extractPosition: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(e)
        );
      },
      flattenToArrayOffset: function (e, t) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      },
      getPosition: function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new W().setFromMatrixColumn(this, 3)
        );
      },
      setRotationFromQuaternion: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(e)
        );
      },
      multiplyToArray: function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      },
      multiplyVector3: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      },
      multiplyVector4: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      },
      rotateAxis: function (e) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          e.transformDirection(this);
      },
      crossVector: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      },
      translate: function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      },
      rotateX: function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      },
      rotateY: function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      },
      rotateZ: function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      },
      rotateByAxis: function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      },
      applyToBufferAttribute: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      },
      applyToVector3Array: function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      },
      makeFrustum: function (e, t, n, i, r, o) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(e, t, i, n, r, o)
        );
      },
      getInverse: function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      },
    }),
    (Ye.prototype.isIntersectionLine = function (e) {
      return (
        console.warn(
          "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
        ),
        this.intersectsLine(e)
      );
    }),
    Object.assign(j.prototype, {
      multiplyVector3: function (e) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          e.applyQuaternion(this)
        );
      },
      inverse: function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      },
    }),
    Object.assign(ye.prototype, {
      isIntersectionBox: function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      },
      isIntersectionPlane: function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(e)
        );
      },
      isIntersectionSphere: function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      },
    }),
    Object.assign(ot.prototype, {
      area: function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      },
      barycoordFromPoint: function (e, t) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(e, t)
        );
      },
      midpoint: function (e) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(e)
        );
      },
      normal: function (e) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(e)
        );
      },
      plane: function (e) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(e)
        );
      },
    }),
    Object.assign(ot, {
      barycoordFromPoint: function (e, t, n, i, r) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          ot.getBarycoord(e, t, n, i, r)
        );
      },
      normal: function (e, t, n, i) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          ot.getNormal(e, t, n, i)
        );
      },
    }),
    Object.assign(Pa.prototype, {
      extractAllPoints: function (e) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(e)
        );
      },
      extrude: function (e) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new _s(this, e)
        );
      },
      makeGeometry: function (e) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new Ss(this, e)
        );
      },
    }),
    Object.assign(N.prototype, {
      fromAttribute: function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      },
      distanceToManhattan: function (e) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(W.prototype, {
      setEulerFromRotationMatrix: function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      },
      setEulerFromQuaternion: function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      },
      getPositionFromMatrix: function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(e)
        );
      },
      getScaleFromMatrix: function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(e)
        );
      },
      getColumnFromMatrix: function (e, t) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(t, e)
        );
      },
      applyProjection: function (e) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(e)
        );
      },
      fromAttribute: function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      },
      distanceToManhattan: function (e) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(H.prototype, {
      fromAttribute: function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(jo.prototype, {
      computeTangents: function () {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      },
      computeLineDistances: function () {
        console.error(
          "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
        );
      },
      applyMatrix: function (e) {
        return (
          console.warn(
            "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      },
    }),
    Object.assign(je.prototype, {
      getChildByName: function (e) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(e)
        );
      },
      renderDepth: function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      },
      translate: function (e, t) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(t, e)
        );
      },
      getWorldRotation: function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      },
      applyMatrix: function (e) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      },
    }),
    Object.defineProperties(je.prototype, {
      eulerOrder: {
        get: function () {
          return (
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
          );
        },
        set: function (e) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            (this.rotation.order = e);
        },
      },
      useQuaternion: {
        get: function () {
          console.warn(
            "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
          );
        },
        set: function () {
          console.warn(
            "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
          );
        },
      },
    }),
    Object.assign(sn.prototype, {
      setDrawMode: function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      },
    }),
    Object.defineProperties(sn.prototype, {
      drawMode: {
        get: function () {
          return (
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
            ),
            0
          );
        },
        set: function () {
          console.error(
            "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
          );
        },
      },
    }),
    Object.defineProperties(to.prototype, {
      objects: {
        get: function () {
          return (
            console.warn("THREE.LOD: .objects has been renamed to .levels."),
            this.levels
          );
        },
      },
    }),
    Object.defineProperty(uo.prototype, "useVertexTexture", {
      get: function () {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
      set: function () {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
    }),
    (ao.prototype.initBones = function () {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    }),
    Object.defineProperty(la.prototype, "__arcLengthDivisions", {
      get: function () {
        return (
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
          ),
          this.arcLengthDivisions
        );
      },
      set: function (e) {
        console.warn(
          "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
        ),
          (this.arcLengthDivisions = e);
      },
    }),
    (mn.prototype.setLens = function (e, t) {
      console.warn(
        "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
      ),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e);
    }),
    Object.defineProperties(Oa.prototype, {
      onlyShadow: {
        set: function () {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        },
      },
      shadowCameraFov: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
          ),
            (this.shadow.camera.fov = e);
        },
      },
      shadowCameraLeft: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
          ),
            (this.shadow.camera.left = e);
        },
      },
      shadowCameraRight: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
          ),
            (this.shadow.camera.right = e);
        },
      },
      shadowCameraTop: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
          ),
            (this.shadow.camera.top = e);
        },
      },
      shadowCameraBottom: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
          ),
            (this.shadow.camera.bottom = e);
        },
      },
      shadowCameraNear: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
          ),
            (this.shadow.camera.near = e);
        },
      },
      shadowCameraFar: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
          ),
            (this.shadow.camera.far = e);
        },
      },
      shadowCameraVisible: {
        set: function () {
          console.warn(
            "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
          );
        },
      },
      shadowBias: {
        set: function (e) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            (this.shadow.bias = e);
        },
      },
      shadowDarkness: {
        set: function () {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        },
      },
      shadowMapWidth: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
          ),
            (this.shadow.mapSize.width = e);
        },
      },
      shadowMapHeight: {
        set: function (e) {
          console.warn(
            "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
          ),
            (this.shadow.mapSize.height = e);
        },
      },
    }),
    Object.defineProperties(xt.prototype, {
      length: {
        get: function () {
          return (
            console.warn(
              "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
            ),
            this.array.length
          );
        },
      },
      dynamic: {
        get: function () {
          return (
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
            this.usage === L
          );
        },
        set: function () {
          console.warn(
            "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
          ),
            this.setUsage(L);
        },
      },
    }),
    Object.assign(xt.prototype, {
      setDynamic: function (e) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? L : A),
          this
        );
      },
      copyIndicesArray: function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      },
      setArray: function () {
        console.error(
          "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      },
    }),
    Object.assign(Ht.prototype, {
      addIndex: function (e) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(e);
      },
      addAttribute: function (e, t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
            ? "index" === e
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(t),
                this)
              : this.setAttribute(e, t)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(e, new xt(arguments[1], arguments[2])))
        );
      },
      addDrawCall: function (e, t, n) {
        void 0 !== n &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(e, t);
      },
      clearDrawCalls: function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      },
      computeTangents: function () {
        console.warn(
          "THREE.BufferGeometry: .computeTangents() has been removed."
        );
      },
      computeOffsets: function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      },
      removeAttribute: function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(e)
        );
      },
      applyMatrix: function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      },
    }),
    Object.defineProperties(Ht.prototype, {
      drawcalls: {
        get: function () {
          return (
            console.error(
              "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
            ),
            this.groups
          );
        },
      },
      offsets: {
        get: function () {
          return (
            console.warn(
              "THREE.BufferGeometry: .offsets has been renamed to .groups."
            ),
            this.groups
          );
        },
      },
    }),
    Object.defineProperties(Za.prototype, {
      maxInstancedCount: {
        get: function () {
          return (
            console.warn(
              "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
            ),
            this.instanceCount
          );
        },
        set: function (e) {
          console.warn(
            "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
          ),
            (this.instanceCount = e);
        },
      },
    }),
    Object.defineProperties(Ac.prototype, {
      linePrecision: {
        get: function () {
          return (
            console.warn(
              "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
            ),
            this.params.Line.threshold
          );
        },
        set: function (e) {
          console.warn(
            "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
          ),
            (this.params.Line.threshold = e);
        },
      },
    }),
    Object.defineProperties(Nr.prototype, {
      dynamic: {
        get: function () {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
            ),
            this.usage === L
          );
        },
        set: function (e) {
          console.warn(
            "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
          ),
            this.setUsage(e);
        },
      },
    }),
    Object.assign(Nr.prototype, {
      setDynamic: function (e) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? L : A),
          this
        );
      },
      setArray: function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      },
    }),
    Object.assign(ys.prototype, {
      getArrays: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
        );
      },
      addShapeList: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
        );
      },
      addShape: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
        );
      },
    }),
    Object.assign(Ir.prototype, {
      dispose: function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      },
    }),
    Object.defineProperties(Sc.prototype, {
      dynamic: {
        set: function () {
          console.warn(
            "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
          );
        },
      },
      onUpdate: {
        value: function () {
          return (
            console.warn(
              "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
            ),
            this
          );
        },
      },
    }),
    Object.defineProperties(mt.prototype, {
      wrapAround: {
        get: function () {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function () {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
      },
      overdraw: {
        get: function () {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function () {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
      },
      wrapRGB: {
        get: function () {
          return (
            console.warn("THREE.Material: .wrapRGB has been removed."), new dt()
          );
        },
      },
      shading: {
        get: function () {
          console.error(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          );
        },
        set: function (e) {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = 1 === e);
        },
      },
      stencilMask: {
        get: function () {
          return (
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
            this.stencilFuncMask
          );
        },
        set: function (e) {
          console.warn(
            "THREE." +
              this.type +
              ": .stencilMask has been removed. Use .stencilFuncMask instead."
          ),
            (this.stencilFuncMask = e);
        },
      },
    }),
    Object.defineProperties(Rs.prototype, {
      metal: {
        get: function () {
          return (
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
          );
        },
      },
    }),
    Object.defineProperties(Ls.prototype, {
      transparency: {
        get: function () {
          return (
            console.warn(
              "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
            ),
            this.transmission
          );
        },
        set: function (e) {
          console.warn(
            "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
          ),
            (this.transmission = e);
        },
      },
    }),
    Object.defineProperties(pn.prototype, {
      derivatives: {
        get: function () {
          return (
            console.warn(
              "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
            this.extensions.derivatives
          );
        },
        set: function (e) {
          console.warn(
            "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
          ),
            (this.extensions.derivatives = e);
        },
      },
    }),
    Object.assign(Cr.prototype, {
      clearTarget: function (e, t, n, i) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(e),
          this.clear(t, n, i);
      },
      animate: function (e) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(e);
      },
      getCurrentRenderTarget: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      },
      getMaxAnisotropy: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      },
      getPrecision: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      },
      resetGLState: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      },
      supportsFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      },
      supportsHalfFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      },
      supportsStandardDerivatives: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      },
      supportsCompressedTextureS3TC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      },
      supportsCompressedTexturePVRTC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      },
      supportsBlendMinMax: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      },
      supportsVertexTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      },
      supportsInstancedArrays: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      },
      enableScissorTest: function (e) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(e);
      },
      initMaterial: function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      },
      addPrePlugin: function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      },
      addPostPlugin: function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      },
      updateShadowMap: function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      },
      setFaceCulling: function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      },
      allocTextureUnit: function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      },
      setTexture: function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      },
      setTexture2D: function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      },
      setTextureCube: function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      },
      getActiveMipMapLevel: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      },
    }),
    Object.defineProperties(Cr.prototype, {
      shadowMapEnabled: {
        get: function () {
          return this.shadowMap.enabled;
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
          ),
            (this.shadowMap.enabled = e);
        },
      },
      shadowMapType: {
        get: function () {
          return this.shadowMap.type;
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
          ),
            (this.shadowMap.type = e);
        },
      },
      shadowMapCullFace: {
        get: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
          );
        },
      },
      context: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
            ),
            this.getContext()
          );
        },
      },
      vr: {
        get: function () {
          return (
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
            this.xr
          );
        },
      },
      gammaInput: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
          );
        },
      },
      gammaOutput: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
            !1
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
          ),
            (this.outputEncoding = !0 === e ? E : S);
        },
      },
      toneMappingWhitePoint: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            ),
            1
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
          );
        },
      },
    }),
    Object.defineProperties(br.prototype, {
      cullFace: {
        get: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
          );
        },
      },
      renderReverseSided: {
        get: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
          );
        },
      },
      renderSingleSided: {
        get: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
          );
        },
        set: function () {
          console.warn(
            "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
          );
        },
      },
    }),
    Object.defineProperties(G.prototype, {
      wrapS: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
            this.texture.wrapS
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
          ),
            (this.texture.wrapS = e);
        },
      },
      wrapT: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
            this.texture.wrapT
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
          ),
            (this.texture.wrapT = e);
        },
      },
      magFilter: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
            this.texture.magFilter
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
          ),
            (this.texture.magFilter = e);
        },
      },
      minFilter: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
            this.texture.minFilter
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
          ),
            (this.texture.minFilter = e);
        },
      },
      anisotropy: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
            this.texture.anisotropy
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
          ),
            (this.texture.anisotropy = e);
        },
      },
      offset: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
            this.texture.offset
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .offset is now .texture.offset."
          ),
            (this.texture.offset = e);
        },
      },
      repeat: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
            this.texture.repeat
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
          ),
            (this.texture.repeat = e);
        },
      },
      format: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
            this.texture.format
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .format is now .texture.format."
          ),
            (this.texture.format = e);
        },
      },
      type: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
            this.texture.type
          );
        },
        set: function (e) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            (this.texture.type = e);
        },
      },
      generateMipmaps: {
        get: function () {
          return (
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
            this.texture.generateMipmaps
          );
        },
        set: function (e) {
          console.warn(
            "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
          ),
            (this.texture.generateMipmaps = e);
        },
      },
    }),
    Object.defineProperties(
      class extends je {
        constructor(e) {
          super(),
            (this.type = "Audio"),
            (this.listener = e),
            (this.context = e.context),
            (this.gain = this.context.createGain()),
            this.gain.connect(e.getInput()),
            (this.autoplay = !1),
            (this.buffer = null),
            (this.detune = 0),
            (this.loop = !1),
            (this.loopStart = 0),
            (this.loopEnd = 0),
            (this.offset = 0),
            (this.duration = void 0),
            (this.playbackRate = 1),
            (this.isPlaying = !1),
            (this.hasPlaybackControl = !0),
            (this.source = null),
            (this.sourceType = "empty"),
            (this._startedAt = 0),
            (this._progress = 0),
            (this._connected = !1),
            (this.filters = []);
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = e),
            this.connect(),
            this
          );
        }
        setMediaElementSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(e)),
            this.connect(),
            this
          );
        }
        setMediaStreamSource(e) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(e)),
            this.connect(),
            this
          );
        }
        setBuffer(e) {
          return (
            (this.buffer = e),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        }
        play(e = 0) {
          if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (!1 === this.hasPlaybackControl)
            return void console.warn(
              "THREE.Audio: this Audio has no playback control."
            );
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return (
            (t.buffer = this.buffer),
            (t.loop = this.loop),
            (t.loopStart = this.loopStart),
            (t.loopEnd = this.loopEnd),
            (t.onended = this.onEnded.bind(this)),
            t.start(
              this._startedAt,
              this._progress + this.offset,
              this.duration
            ),
            (this.isPlaying = !0),
            (this.source = t),
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
          );
        }
        pause() {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this._progress = 0),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return (this._connected = !0), this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
              this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return (this._connected = !1), this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return (
            e || (e = []),
            !0 === this._connected
              ? (this.disconnect(), (this.filters = e.slice()), this.connect())
              : (this.filters = e.slice()),
            this
          );
        }
        setDetune(e) {
          if (((this.detune = e), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = e),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = !1;
        }
        getLoop() {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        }
        setLoop(e) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = e),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(e) {
          return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
          return (this.loopEnd = e), this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return (
            this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
            this
          );
        }
      }.prototype,
      {
        load: {
          value: function (e) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            const t = this;
            return (
              new rc().load(e, function (e) {
                t.setBuffer(e);
              }),
              this
            );
          },
        },
        startTime: {
          set: function () {
            console.warn("THREE.Audio: .startTime is now .play( delay ).");
          },
        },
      }
    ),
    (vn.prototype.updateCubeMap = function (e, t) {
      return (
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
      );
    }),
    (vn.prototype.clear = function (e, t, n, i) {
      return (
        console.warn(
          "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
        ),
        this.renderTarget.clear(e, t, n, i)
      );
    }),
    (U.crossOrigin = void 0),
    (U.loadTexture = function (e, t, n, i) {
      console.warn(
        "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
      );
      const r = new ca();
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(e, n, void 0, i);
      return t && (o.mapping = t), o;
    }),
    (U.loadTextureCube = function (e, t, n, i) {
      console.warn(
        "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
      );
      const r = new sa();
      r.setCrossOrigin(this.crossOrigin);
      const o = r.load(e, n, void 0, i);
      return t && (o.mapping = t), o;
    }),
    (U.loadCompressedTexture = function () {
      console.error(
        "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
      );
    }),
    (U.loadCompressedTextureCube = function () {
      console.error(
        "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
      );
    }),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: "124" } })
      );
  var Xc = Array.prototype.forEach,
    qc = Array.prototype.slice,
    Yc = {
      BREAK: {},
      extend: function (e) {
        return (
          this.each(
            qc.call(arguments, 1),
            function (t) {
              (this.isObject(t) ? Object.keys(t) : []).forEach(
                function (n) {
                  this.isUndefined(t[n]) || (e[n] = t[n]);
                }.bind(this)
              );
            },
            this
          ),
          e
        );
      },
      defaults: function (e) {
        return (
          this.each(
            qc.call(arguments, 1),
            function (t) {
              (this.isObject(t) ? Object.keys(t) : []).forEach(
                function (n) {
                  this.isUndefined(e[n]) && (e[n] = t[n]);
                }.bind(this)
              );
            },
            this
          ),
          e
        );
      },
      compose: function () {
        var e = qc.call(arguments);
        return function () {
          for (var t = qc.call(arguments), n = e.length - 1; n >= 0; n--)
            t = [e[n].apply(this, t)];
          return t[0];
        };
      },
      each: function (e, t, n) {
        if (e)
          if (Xc && e.forEach && e.forEach === Xc) e.forEach(t, n);
          else if (e.length === e.length + 0) {
            var i,
              r = void 0;
            for (r = 0, i = e.length; r < i; r++)
              if (r in e && t.call(n, e[r], r) === this.BREAK) return;
          } else for (var o in e) if (t.call(n, e[o], o) === this.BREAK) return;
      },
      defer: function (e) {
        setTimeout(e, 0);
      },
      debounce: function (e, t, n) {
        var i = void 0;
        return function () {
          var r = this,
            o = arguments;
          function s() {
            (i = null), n || e.apply(r, o);
          }
          var a = n || !i;
          clearTimeout(i), (i = setTimeout(s, t)), a && e.apply(r, o);
        };
      },
      toArray: function (e) {
        return e.toArray ? e.toArray() : qc.call(e);
      },
      isUndefined: function (e) {
        return void 0 === e;
      },
      isNull: function (e) {
        return null === e;
      },
      isNaN: (function (e) {
        function t(t) {
          return e.apply(this, arguments);
        }
        return (
          (t.toString = function () {
            return e.toString();
          }),
          t
        );
      })(function (e) {
        return isNaN(e);
      }),
      isArray:
        Array.isArray ||
        function (e) {
          return e.constructor === Array;
        },
      isObject: function (e) {
        return e === Object(e);
      },
      isNumber: function (e) {
        return e === e + 0;
      },
      isString: function (e) {
        return e === e + "";
      },
      isBoolean: function (e) {
        return !1 === e || !0 === e;
      },
      isFunction: function (e) {
        return e instanceof Function;
      },
    },
    Zc = [
      {
        litmus: Yc.isString,
        conversions: {
          THREE_CHAR_HEX: {
            read: function (e) {
              var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
              return (
                null !== t && {
                  space: "HEX",
                  hex: parseInt(
                    "0x" +
                      t[1].toString() +
                      t[1].toString() +
                      t[2].toString() +
                      t[2].toString() +
                      t[3].toString() +
                      t[3].toString(),
                    0
                  ),
                }
              );
            },
            write: Wc,
          },
          SIX_CHAR_HEX: {
            read: function (e) {
              var t = e.match(/^#([A-F0-9]{6})$/i);
              return (
                null !== t && {
                  space: "HEX",
                  hex: parseInt("0x" + t[1].toString(), 0),
                }
              );
            },
            write: Wc,
          },
          CSS_RGB: {
            read: function (e) {
              var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
              return (
                null !== t && {
                  space: "RGB",
                  r: parseFloat(t[1]),
                  g: parseFloat(t[2]),
                  b: parseFloat(t[3]),
                }
              );
            },
            write: Wc,
          },
          CSS_RGBA: {
            read: function (e) {
              var t = e.match(
                /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/
              );
              return (
                null !== t && {
                  space: "RGB",
                  r: parseFloat(t[1]),
                  g: parseFloat(t[2]),
                  b: parseFloat(t[3]),
                  a: parseFloat(t[4]),
                }
              );
            },
            write: Wc,
          },
        },
      },
      {
        litmus: Yc.isNumber,
        conversions: {
          HEX: {
            read: function (e) {
              return { space: "HEX", hex: e, conversionName: "HEX" };
            },
            write: function (e) {
              return e.hex;
            },
          },
        },
      },
      {
        litmus: Yc.isArray,
        conversions: {
          RGB_ARRAY: {
            read: function (e) {
              return (
                3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] }
              );
            },
            write: function (e) {
              return [e.r, e.g, e.b];
            },
          },
          RGBA_ARRAY: {
            read: function (e) {
              return (
                4 === e.length && {
                  space: "RGB",
                  r: e[0],
                  g: e[1],
                  b: e[2],
                  a: e[3],
                }
              );
            },
            write: function (e) {
              return [e.r, e.g, e.b, e.a];
            },
          },
        },
      },
      {
        litmus: Yc.isObject,
        conversions: {
          RGBA_OBJ: {
            read: function (e) {
              return (
                !!(
                  Yc.isNumber(e.r) &&
                  Yc.isNumber(e.g) &&
                  Yc.isNumber(e.b) &&
                  Yc.isNumber(e.a)
                ) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a }
              );
            },
            write: function (e) {
              return { r: e.r, g: e.g, b: e.b, a: e.a };
            },
          },
          RGB_OBJ: {
            read: function (e) {
              return (
                !!(
                  Yc.isNumber(e.r) &&
                  Yc.isNumber(e.g) &&
                  Yc.isNumber(e.b)
                ) && { space: "RGB", r: e.r, g: e.g, b: e.b }
              );
            },
            write: function (e) {
              return { r: e.r, g: e.g, b: e.b };
            },
          },
          HSVA_OBJ: {
            read: function (e) {
              return (
                !!(
                  Yc.isNumber(e.h) &&
                  Yc.isNumber(e.s) &&
                  Yc.isNumber(e.v) &&
                  Yc.isNumber(e.a)
                ) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a }
              );
            },
            write: function (e) {
              return { h: e.h, s: e.s, v: e.v, a: e.a };
            },
          },
          HSV_OBJ: {
            read: function (e) {
              return (
                !!(
                  Yc.isNumber(e.h) &&
                  Yc.isNumber(e.s) &&
                  Yc.isNumber(e.v)
                ) && { space: "HSV", h: e.h, s: e.s, v: e.v }
              );
            },
            write: function (e) {
              return { h: e.h, s: e.s, v: e.v };
            },
          },
        },
      },
    ],
    Jc = void 0,
    Kc = void 0,
    Qc = function () {
      Kc = !1;
      var e = arguments.length > 1 ? Yc.toArray(arguments) : arguments[0];
      return (
        Yc.each(Zc, function (t) {
          if (t.litmus(e))
            return (
              Yc.each(t.conversions, function (t, n) {
                if (((Jc = t.read(e)), !1 === Kc && !1 !== Jc))
                  return (
                    (Kc = Jc),
                    (Jc.conversionName = n),
                    (Jc.conversion = t),
                    Yc.BREAK
                  );
              }),
              Yc.BREAK
            );
        }),
        Kc
      );
    },
    $c = void 0,
    el = {
      hsv_to_rgb: function (e, t, n) {
        var i = Math.floor(e / 60) % 6,
          r = e / 60 - Math.floor(e / 60),
          o = n * (1 - t),
          s = n * (1 - r * t),
          a = n * (1 - (1 - r) * t),
          c = [
            [n, a, o],
            [s, n, o],
            [o, n, a],
            [o, s, n],
            [a, o, n],
            [n, o, s],
          ][i];
        return { r: 255 * c[0], g: 255 * c[1], b: 255 * c[2] };
      },
      rgb_to_hsv: function (e, t, n) {
        var i = Math.min(e, t, n),
          r = Math.max(e, t, n),
          o = r - i,
          s = void 0;
        return 0 === r
          ? { h: NaN, s: 0, v: 0 }
          : ((s =
              e === r
                ? (t - n) / o
                : t === r
                ? 2 + (n - e) / o
                : 4 + (e - t) / o),
            (s /= 6) < 0 && (s += 1),
            { h: 360 * s, s: o / r, v: r / 255 });
      },
      rgb_to_hex: function (e, t, n) {
        var i = this.hex_with_component(0, 2, e);
        return (
          (i = this.hex_with_component(i, 1, t)),
          this.hex_with_component(i, 0, n)
        );
      },
      component_from_hex: function (e, t) {
        return (e >> (8 * t)) & 255;
      },
      hex_with_component: function (e, t, n) {
        return (n << ($c = 8 * t)) | (e & ~(255 << $c));
      },
    },
    tl =
      "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              "function" == typeof Symbol &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          },
    nl = function (e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    },
    il = (function () {
      function e(e, t) {
        for (var n = 0; n < t.length; n++) {
          var i = t[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i);
        }
      }
      return function (t, n, i) {
        return n && e(t.prototype, n), i && e(t, i), t;
      };
    })(),
    rl = function e(t, n, i) {
      null === t && (t = Function.prototype);
      var r = Object.getOwnPropertyDescriptor(t, n);
      if (void 0 === r) {
        var o = Object.getPrototypeOf(t);
        return null === o ? void 0 : e(o, n, i);
      }
      if ("value" in r) return r.value;
      var s = r.get;
      return void 0 !== s ? s.call(i) : void 0;
    },
    ol = function (e, t) {
      if ("function" != typeof t && null !== t)
        throw new TypeError(
          "Super expression must either be null or a function, not " + typeof t
        );
      (e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0,
        },
      })),
        t &&
          (Object.setPrototypeOf
            ? Object.setPrototypeOf(e, t)
            : (e.__proto__ = t));
    },
    sl = function (e, t) {
      if (!e)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
    },
    al = (function () {
      function e() {
        if (
          (nl(this, e),
          (this.__state = Qc.apply(this, arguments)),
          !1 === this.__state)
        )
          throw new Error("Failed to interpret color arguments");
        this.__state.a = this.__state.a || 1;
      }
      return (
        il(e, [
          {
            key: "toString",
            value: function () {
              return Wc(this);
            },
          },
          {
            key: "toHexString",
            value: function () {
              return Wc(this, !0);
            },
          },
          {
            key: "toOriginal",
            value: function () {
              return this.__state.conversion.write(this);
            },
          },
        ]),
        e
      );
    })();
  function cl(e, t, n) {
    Object.defineProperty(e, t, {
      get: function () {
        return (
          "RGB" === this.__state.space || al.recalculateRGB(this, t, n),
          this.__state[t]
        );
      },
      set: function (e) {
        "RGB" !== this.__state.space &&
          (al.recalculateRGB(this, t, n), (this.__state.space = "RGB")),
          (this.__state[t] = e);
      },
    });
  }
  function ll(e, t) {
    Object.defineProperty(e, t, {
      get: function () {
        return (
          "HSV" === this.__state.space || al.recalculateHSV(this),
          this.__state[t]
        );
      },
      set: function (e) {
        "HSV" !== this.__state.space &&
          (al.recalculateHSV(this), (this.__state.space = "HSV")),
          (this.__state[t] = e);
      },
    });
  }
  (al.recalculateRGB = function (e, t, n) {
    if ("HEX" === e.__state.space)
      e.__state[t] = el.component_from_hex(e.__state.hex, n);
    else {
      if ("HSV" !== e.__state.space) throw new Error("Corrupted color state");
      Yc.extend(
        e.__state,
        el.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)
      );
    }
  }),
    (al.recalculateHSV = function (e) {
      var t = el.rgb_to_hsv(e.r, e.g, e.b);
      Yc.extend(e.__state, { s: t.s, v: t.v }),
        Yc.isNaN(t.h)
          ? Yc.isUndefined(e.__state.h) && (e.__state.h = 0)
          : (e.__state.h = t.h);
    }),
    (al.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"]),
    cl(al.prototype, "r", 2),
    cl(al.prototype, "g", 1),
    cl(al.prototype, "b", 0),
    ll(al.prototype, "h"),
    ll(al.prototype, "s"),
    ll(al.prototype, "v"),
    Object.defineProperty(al.prototype, "a", {
      get: function () {
        return this.__state.a;
      },
      set: function (e) {
        this.__state.a = e;
      },
    }),
    Object.defineProperty(al.prototype, "hex", {
      get: function () {
        return (
          "HEX" !== this.__state.space &&
            ((this.__state.hex = el.rgb_to_hex(this.r, this.g, this.b)),
            (this.__state.space = "HEX")),
          this.__state.hex
        );
      },
      set: function (e) {
        (this.__state.space = "HEX"), (this.__state.hex = e);
      },
    });
  var hl = (function () {
      function e(t, n) {
        nl(this, e),
          (this.initialValue = t[n]),
          (this.domElement = document.createElement("div")),
          (this.object = t),
          (this.property = n),
          (this.__onChange = void 0),
          (this.__onFinishChange = void 0);
      }
      return (
        il(e, [
          {
            key: "onChange",
            value: function (e) {
              return (this.__onChange = e), this;
            },
          },
          {
            key: "onFinishChange",
            value: function (e) {
              return (this.__onFinishChange = e), this;
            },
          },
          {
            key: "setValue",
            value: function (e) {
              return (
                (this.object[this.property] = e),
                this.__onChange && this.__onChange.call(this, e),
                this.updateDisplay(),
                this
              );
            },
          },
          {
            key: "getValue",
            value: function () {
              return this.object[this.property];
            },
          },
          {
            key: "updateDisplay",
            value: function () {
              return this;
            },
          },
          {
            key: "isModified",
            value: function () {
              return this.initialValue !== this.getValue();
            },
          },
        ]),
        e
      );
    })(),
    ul = {};
  Yc.each(
    {
      HTMLEvents: ["change"],
      MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
      KeyboardEvents: ["keydown"],
    },
    function (e, t) {
      Yc.each(e, function (e) {
        ul[e] = t;
      });
    }
  );
  var dl = /(\d+(\.\d+)?)px/;
  function pl(e) {
    if ("0" === e || Yc.isUndefined(e)) return 0;
    var t = e.match(dl);
    return Yc.isNull(t) ? 0 : parseFloat(t[1]);
  }
  var fl = {
      makeSelectable: function (e, t) {
        void 0 !== e &&
          void 0 !== e.style &&
          ((e.onselectstart = t
            ? function () {
                return !1;
              }
            : function () {}),
          (e.style.MozUserSelect = t ? "auto" : "none"),
          (e.style.KhtmlUserSelect = t ? "auto" : "none"),
          (e.unselectable = t ? "on" : "off"));
      },
      makeFullscreen: function (e, t, n) {
        var i = n,
          r = t;
        Yc.isUndefined(r) && (r = !0),
          Yc.isUndefined(i) && (i = !0),
          (e.style.position = "absolute"),
          r && ((e.style.left = 0), (e.style.right = 0)),
          i && ((e.style.top = 0), (e.style.bottom = 0));
      },
      fakeEvent: function (e, t, n, i) {
        var r = n || {},
          o = ul[t];
        if (!o) throw new Error("Event type " + t + " not supported.");
        var s = document.createEvent(o);
        switch (o) {
          case "MouseEvents":
            var a = r.x || r.clientX || 0,
              c = r.y || r.clientY || 0;
            s.initMouseEvent(
              t,
              r.bubbles || !1,
              r.cancelable || !0,
              window,
              r.clickCount || 1,
              0,
              0,
              a,
              c,
              !1,
              !1,
              !1,
              !1,
              0,
              null
            );
            break;
          case "KeyboardEvents":
            var l = s.initKeyboardEvent || s.initKeyEvent;
            Yc.defaults(r, {
              cancelable: !0,
              ctrlKey: !1,
              altKey: !1,
              shiftKey: !1,
              metaKey: !1,
              keyCode: void 0,
              charCode: void 0,
            }),
              l(
                t,
                r.bubbles || !1,
                r.cancelable,
                window,
                r.ctrlKey,
                r.altKey,
                r.shiftKey,
                r.metaKey,
                r.keyCode,
                r.charCode
              );
            break;
          default:
            s.initEvent(t, r.bubbles || !1, r.cancelable || !0);
        }
        Yc.defaults(s, i), e.dispatchEvent(s);
      },
      bind: function (e, t, n, i) {
        var r = i || !1;
        return (
          e.addEventListener
            ? e.addEventListener(t, n, r)
            : e.attachEvent && e.attachEvent("on" + t, n),
          fl
        );
      },
      unbind: function (e, t, n, i) {
        var r = i || !1;
        return (
          e.removeEventListener
            ? e.removeEventListener(t, n, r)
            : e.detachEvent && e.detachEvent("on" + t, n),
          fl
        );
      },
      addClass: function (e, t) {
        if (void 0 === e.className) e.className = t;
        else if (e.className !== t) {
          var n = e.className.split(/ +/);
          -1 === n.indexOf(t) &&
            (n.push(t),
            (e.className = n
              .join(" ")
              .replace(/^\s+/, "")
              .replace(/\s+$/, "")));
        }
        return fl;
      },
      removeClass: function (e, t) {
        if (t)
          if (e.className === t) e.removeAttribute("class");
          else {
            var n = e.className.split(/ +/),
              i = n.indexOf(t);
            -1 !== i && (n.splice(i, 1), (e.className = n.join(" ")));
          }
        else e.className = void 0;
        return fl;
      },
      hasClass: function (e, t) {
        return (
          new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
        );
      },
      getWidth: function (e) {
        var t = getComputedStyle(e);
        return (
          pl(t["border-left-width"]) +
          pl(t["border-right-width"]) +
          pl(t["padding-left"]) +
          pl(t["padding-right"]) +
          pl(t.width)
        );
      },
      getHeight: function (e) {
        var t = getComputedStyle(e);
        return (
          pl(t["border-top-width"]) +
          pl(t["border-bottom-width"]) +
          pl(t["padding-top"]) +
          pl(t["padding-bottom"]) +
          pl(t.height)
        );
      },
      getOffset: function (e) {
        var t = e,
          n = { left: 0, top: 0 };
        if (t.offsetParent)
          do {
            (n.left += t.offsetLeft),
              (n.top += t.offsetTop),
              (t = t.offsetParent);
          } while (t);
        return n;
      },
      isActive: function (e) {
        return e === document.activeElement && (e.type || e.href);
      },
    },
    ml = (function (e) {
      function t(e, n) {
        nl(this, t);
        var i = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          r = i;
        return (
          (i.__prev = i.getValue()),
          (i.__checkbox = document.createElement("input")),
          i.__checkbox.setAttribute("type", "checkbox"),
          fl.bind(
            i.__checkbox,
            "change",
            function () {
              r.setValue(!r.__prev);
            },
            !1
          ),
          i.domElement.appendChild(i.__checkbox),
          i.updateDisplay(),
          i
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "setValue",
            value: function (e) {
              var n = rl(
                t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                "setValue",
                this
              ).call(this, e);
              return (
                this.__onFinishChange &&
                  this.__onFinishChange.call(this, this.getValue()),
                (this.__prev = this.getValue()),
                n
              );
            },
          },
          {
            key: "updateDisplay",
            value: function () {
              return (
                !0 === this.getValue()
                  ? (this.__checkbox.setAttribute("checked", "checked"),
                    (this.__checkbox.checked = !0),
                    (this.__prev = !0))
                  : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                rl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "updateDisplay",
                  this
                ).call(this)
              );
            },
          },
        ]),
        t
      );
    })(hl),
    gl = (function (e) {
      function t(e, n, i) {
        nl(this, t);
        var r = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          o = i,
          s = r;
        if (((r.__select = document.createElement("select")), Yc.isArray(o))) {
          var a = {};
          Yc.each(o, function (e) {
            a[e] = e;
          }),
            (o = a);
        }
        return (
          Yc.each(o, function (e, t) {
            var n = document.createElement("option");
            (n.innerHTML = t),
              n.setAttribute("value", e),
              s.__select.appendChild(n);
          }),
          r.updateDisplay(),
          fl.bind(r.__select, "change", function () {
            var e = this.options[this.selectedIndex].value;
            s.setValue(e);
          }),
          r.domElement.appendChild(r.__select),
          r
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "setValue",
            value: function (e) {
              var n = rl(
                t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                "setValue",
                this
              ).call(this, e);
              return (
                this.__onFinishChange &&
                  this.__onFinishChange.call(this, this.getValue()),
                n
              );
            },
          },
          {
            key: "updateDisplay",
            value: function () {
              return fl.isActive(this.__select)
                ? this
                : ((this.__select.value = this.getValue()),
                  rl(
                    t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                    "updateDisplay",
                    this
                  ).call(this));
            },
          },
        ]),
        t
      );
    })(hl),
    vl = (function (e) {
      function t(e, n) {
        nl(this, t);
        var i = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          r = i;
        function o() {
          r.setValue(r.__input.value);
        }
        return (
          (i.__input = document.createElement("input")),
          i.__input.setAttribute("type", "text"),
          fl.bind(i.__input, "keyup", o),
          fl.bind(i.__input, "change", o),
          fl.bind(i.__input, "blur", function () {
            r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
          }),
          fl.bind(i.__input, "keydown", function (e) {
            13 === e.keyCode && this.blur();
          }),
          i.updateDisplay(),
          i.domElement.appendChild(i.__input),
          i
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "updateDisplay",
            value: function () {
              return (
                fl.isActive(this.__input) ||
                  (this.__input.value = this.getValue()),
                rl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "updateDisplay",
                  this
                ).call(this)
              );
            },
          },
        ]),
        t
      );
    })(hl);
  function yl(e) {
    var t = e.toString();
    return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0;
  }
  var xl = (function (e) {
      function t(e, n, i) {
        nl(this, t);
        var r = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          o = i || {};
        return (
          (r.__min = o.min),
          (r.__max = o.max),
          (r.__step = o.step),
          Yc.isUndefined(r.__step)
            ? 0 === r.initialValue
              ? (r.__impliedStep = 1)
              : (r.__impliedStep =
                  Math.pow(
                    10,
                    Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)
                  ) / 10)
            : (r.__impliedStep = r.__step),
          (r.__precision = yl(r.__impliedStep)),
          r
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "setValue",
            value: function (e) {
              var n = e;
              return (
                void 0 !== this.__min && n < this.__min
                  ? (n = this.__min)
                  : void 0 !== this.__max && n > this.__max && (n = this.__max),
                void 0 !== this.__step &&
                  n % this.__step != 0 &&
                  (n = Math.round(n / this.__step) * this.__step),
                rl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "setValue",
                  this
                ).call(this, n)
              );
            },
          },
          {
            key: "min",
            value: function (e) {
              return (this.__min = e), this;
            },
          },
          {
            key: "max",
            value: function (e) {
              return (this.__max = e), this;
            },
          },
          {
            key: "step",
            value: function (e) {
              return (
                (this.__step = e),
                (this.__impliedStep = e),
                (this.__precision = yl(e)),
                this
              );
            },
          },
        ]),
        t
      );
    })(hl),
    _l = (function (e) {
      function t(e, n, i) {
        nl(this, t);
        var r = sl(
          this,
          (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, i)
        );
        r.__truncationSuspended = !1;
        var o = r,
          s = void 0;
        function a() {
          o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
        }
        function c(e) {
          var t = s - e.clientY;
          o.setValue(o.getValue() + t * o.__impliedStep), (s = e.clientY);
        }
        function l() {
          fl.unbind(window, "mousemove", c),
            fl.unbind(window, "mouseup", l),
            a();
        }
        return (
          (r.__input = document.createElement("input")),
          r.__input.setAttribute("type", "text"),
          fl.bind(r.__input, "change", function () {
            var e = parseFloat(o.__input.value);
            Yc.isNaN(e) || o.setValue(e);
          }),
          fl.bind(r.__input, "blur", function () {
            a();
          }),
          fl.bind(r.__input, "mousedown", function (e) {
            fl.bind(window, "mousemove", c),
              fl.bind(window, "mouseup", l),
              (s = e.clientY);
          }),
          fl.bind(r.__input, "keydown", function (e) {
            13 === e.keyCode &&
              ((o.__truncationSuspended = !0),
              this.blur(),
              (o.__truncationSuspended = !1),
              a());
          }),
          r.updateDisplay(),
          r.domElement.appendChild(r.__input),
          r
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "updateDisplay",
            value: function () {
              var e, n, i;
              return (
                (this.__input.value = this.__truncationSuspended
                  ? this.getValue()
                  : ((e = this.getValue()),
                    (n = this.__precision),
                    (i = Math.pow(10, n)),
                    Math.round(e * i) / i)),
                rl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "updateDisplay",
                  this
                ).call(this)
              );
            },
          },
        ]),
        t
      );
    })(xl);
  function bl(e, t, n, i, r) {
    return i + ((e - t) / (n - t)) * (r - i);
  }
  var wl = (function (e) {
      function t(e, n, i, r, o) {
        nl(this, t);
        var s = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, {
              min: i,
              max: r,
              step: o,
            })
          ),
          a = s;
        function c(e) {
          e.preventDefault();
          var t = a.__background.getBoundingClientRect();
          return (
            a.setValue(bl(e.clientX, t.left, t.right, a.__min, a.__max)), !1
          );
        }
        function l() {
          fl.unbind(window, "mousemove", c),
            fl.unbind(window, "mouseup", l),
            a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
        }
        function h(e) {
          var t = e.touches[0].clientX,
            n = a.__background.getBoundingClientRect();
          a.setValue(bl(t, n.left, n.right, a.__min, a.__max));
        }
        function u() {
          fl.unbind(window, "touchmove", h),
            fl.unbind(window, "touchend", u),
            a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
        }
        return (
          (s.__background = document.createElement("div")),
          (s.__foreground = document.createElement("div")),
          fl.bind(s.__background, "mousedown", function (e) {
            document.activeElement.blur(),
              fl.bind(window, "mousemove", c),
              fl.bind(window, "mouseup", l),
              c(e);
          }),
          fl.bind(s.__background, "touchstart", function (e) {
            1 === e.touches.length &&
              (fl.bind(window, "touchmove", h),
              fl.bind(window, "touchend", u),
              h(e));
          }),
          fl.addClass(s.__background, "slider"),
          fl.addClass(s.__foreground, "slider-fg"),
          s.updateDisplay(),
          s.__background.appendChild(s.__foreground),
          s.domElement.appendChild(s.__background),
          s
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "updateDisplay",
            value: function () {
              var e =
                (this.getValue() - this.__min) / (this.__max - this.__min);
              return (
                (this.__foreground.style.width = 100 * e + "%"),
                rl(
                  t.prototype.__proto__ || Object.getPrototypeOf(t.prototype),
                  "updateDisplay",
                  this
                ).call(this)
              );
            },
          },
        ]),
        t
      );
    })(xl),
    Ml = (function (e) {
      function t(e, n, i) {
        nl(this, t);
        var r = sl(
            this,
            (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
          ),
          o = r;
        return (
          (r.__button = document.createElement("div")),
          (r.__button.innerHTML = void 0 === i ? "Fire" : i),
          fl.bind(r.__button, "click", function (e) {
            return e.preventDefault(), o.fire(), !1;
          }),
          fl.addClass(r.__button, "button"),
          r.domElement.appendChild(r.__button),
          r
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "fire",
            value: function () {
              this.__onChange && this.__onChange.call(this),
                this.getValue().call(this.object),
                this.__onFinishChange &&
                  this.__onFinishChange.call(this, this.getValue());
            },
          },
        ]),
        t
      );
    })(hl),
    Sl = (function (e) {
      function t(e, n) {
        nl(this, t);
        var i = sl(
          this,
          (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
        );
        (i.__color = new al(i.getValue())), (i.__temp = new al(0));
        var r = i;
        (i.domElement = document.createElement("div")),
          fl.makeSelectable(i.domElement, !1),
          (i.__selector = document.createElement("div")),
          (i.__selector.className = "selector"),
          (i.__saturation_field = document.createElement("div")),
          (i.__saturation_field.className = "saturation-field"),
          (i.__field_knob = document.createElement("div")),
          (i.__field_knob.className = "field-knob"),
          (i.__field_knob_border = "2px solid "),
          (i.__hue_knob = document.createElement("div")),
          (i.__hue_knob.className = "hue-knob"),
          (i.__hue_field = document.createElement("div")),
          (i.__hue_field.className = "hue-field"),
          (i.__input = document.createElement("input")),
          (i.__input.type = "text"),
          (i.__input_textShadow = "0 1px 1px "),
          fl.bind(i.__input, "keydown", function (e) {
            13 === e.keyCode && u.call(this);
          }),
          fl.bind(i.__input, "blur", u),
          fl.bind(i.__selector, "mousedown", function () {
            fl.addClass(this, "drag").bind(window, "mouseup", function () {
              fl.removeClass(r.__selector, "drag");
            });
          }),
          fl.bind(i.__selector, "touchstart", function () {
            fl.addClass(this, "drag").bind(window, "touchend", function () {
              fl.removeClass(r.__selector, "drag");
            });
          });
        var o,
          s = document.createElement("div");
        function a(e) {
          p(e),
            fl.bind(window, "mousemove", p),
            fl.bind(window, "touchmove", p),
            fl.bind(window, "mouseup", l),
            fl.bind(window, "touchend", l);
        }
        function c(e) {
          f(e),
            fl.bind(window, "mousemove", f),
            fl.bind(window, "touchmove", f),
            fl.bind(window, "mouseup", h),
            fl.bind(window, "touchend", h);
        }
        function l() {
          fl.unbind(window, "mousemove", p),
            fl.unbind(window, "touchmove", p),
            fl.unbind(window, "mouseup", l),
            fl.unbind(window, "touchend", l),
            d();
        }
        function h() {
          fl.unbind(window, "mousemove", f),
            fl.unbind(window, "touchmove", f),
            fl.unbind(window, "mouseup", h),
            fl.unbind(window, "touchend", h),
            d();
        }
        function u() {
          var e = Qc(this.value);
          !1 !== e
            ? ((r.__color.__state = e), r.setValue(r.__color.toOriginal()))
            : (this.value = r.__color.toString());
        }
        function d() {
          r.__onFinishChange &&
            r.__onFinishChange.call(r, r.__color.toOriginal());
        }
        function p(e) {
          -1 === e.type.indexOf("touch") && e.preventDefault();
          var t = r.__saturation_field.getBoundingClientRect(),
            n = (e.touches && e.touches[0]) || e,
            i = n.clientX,
            o = n.clientY,
            s = (i - t.left) / (t.right - t.left),
            a = 1 - (o - t.top) / (t.bottom - t.top);
          return (
            a > 1 ? (a = 1) : a < 0 && (a = 0),
            s > 1 ? (s = 1) : s < 0 && (s = 0),
            (r.__color.v = a),
            (r.__color.s = s),
            r.setValue(r.__color.toOriginal()),
            !1
          );
        }
        function f(e) {
          -1 === e.type.indexOf("touch") && e.preventDefault();
          var t = r.__hue_field.getBoundingClientRect(),
            n =
              1 -
              (((e.touches && e.touches[0]) || e).clientY - t.top) /
                (t.bottom - t.top);
          return (
            n > 1 ? (n = 1) : n < 0 && (n = 0),
            (r.__color.h = 360 * n),
            r.setValue(r.__color.toOriginal()),
            !1
          );
        }
        return (
          Yc.extend(i.__selector.style, {
            width: "122px",
            height: "102px",
            padding: "3px",
            backgroundColor: "#222",
            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
          }),
          Yc.extend(i.__field_knob.style, {
            position: "absolute",
            width: "12px",
            height: "12px",
            border:
              i.__field_knob_border + (i.__color.v < 0.5 ? "#fff" : "#000"),
            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
            borderRadius: "12px",
            zIndex: 1,
          }),
          Yc.extend(i.__hue_knob.style, {
            position: "absolute",
            width: "15px",
            height: "2px",
            borderRight: "4px solid #fff",
            zIndex: 1,
          }),
          Yc.extend(i.__saturation_field.style, {
            width: "100px",
            height: "100px",
            border: "1px solid #555",
            marginRight: "3px",
            display: "inline-block",
            cursor: "pointer",
          }),
          Yc.extend(s.style, {
            width: "100%",
            height: "100%",
            background: "none",
          }),
          Tl(s, "top", "rgba(0,0,0,0)", "#000"),
          Yc.extend(i.__hue_field.style, {
            width: "15px",
            height: "100px",
            border: "1px solid #555",
            cursor: "ns-resize",
            position: "absolute",
            top: "3px",
            right: "3px",
          }),
          ((o = i.__hue_field).style.background = ""),
          (o.style.cssText +=
            "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
          (o.style.cssText +=
            "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
          (o.style.cssText +=
            "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
          (o.style.cssText +=
            "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
          (o.style.cssText +=
            "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
          Yc.extend(i.__input.style, {
            outline: "none",
            textAlign: "center",
            color: "#fff",
            border: 0,
            fontWeight: "bold",
            textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)",
          }),
          fl.bind(i.__saturation_field, "mousedown", a),
          fl.bind(i.__saturation_field, "touchstart", a),
          fl.bind(i.__field_knob, "mousedown", a),
          fl.bind(i.__field_knob, "touchstart", a),
          fl.bind(i.__hue_field, "mousedown", c),
          fl.bind(i.__hue_field, "touchstart", c),
          i.__saturation_field.appendChild(s),
          i.__selector.appendChild(i.__field_knob),
          i.__selector.appendChild(i.__saturation_field),
          i.__selector.appendChild(i.__hue_field),
          i.__hue_field.appendChild(i.__hue_knob),
          i.domElement.appendChild(i.__input),
          i.domElement.appendChild(i.__selector),
          i.updateDisplay(),
          i
        );
      }
      return (
        ol(t, e),
        il(t, [
          {
            key: "updateDisplay",
            value: function () {
              var e = Qc(this.getValue());
              if (!1 !== e) {
                var t = !1;
                Yc.each(
                  al.COMPONENTS,
                  function (n) {
                    if (
                      !Yc.isUndefined(e[n]) &&
                      !Yc.isUndefined(this.__color.__state[n]) &&
                      e[n] !== this.__color.__state[n]
                    )
                      return (t = !0), {};
                  },
                  this
                ),
                  t && Yc.extend(this.__color.__state, e);
              }
              Yc.extend(this.__temp.__state, this.__color.__state),
                (this.__temp.a = 1);
              var n = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                i = 255 - n;
              Yc.extend(this.__field_knob.style, {
                marginLeft: 100 * this.__color.s - 7 + "px",
                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                backgroundColor: this.__temp.toHexString(),
                border:
                  this.__field_knob_border +
                  "rgb(" +
                  n +
                  "," +
                  n +
                  "," +
                  n +
                  ")",
              }),
                (this.__hue_knob.style.marginTop =
                  100 * (1 - this.__color.h / 360) + "px"),
                (this.__temp.s = 1),
                (this.__temp.v = 1),
                Tl(
                  this.__saturation_field,
                  "left",
                  "#fff",
                  this.__temp.toHexString()
                ),
                (this.__input.value = this.__color.toString()),
                Yc.extend(this.__input.style, {
                  backgroundColor: this.__color.toHexString(),
                  color: "rgb(" + n + "," + n + "," + n + ")",
                  textShadow:
                    this.__input_textShadow +
                    "rgba(" +
                    i +
                    "," +
                    i +
                    "," +
                    i +
                    ",.7)",
                });
            },
          },
        ]),
        t
      );
    })(hl),
    El = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
  function Tl(e, t, n, i) {
    (e.style.background = ""),
      Yc.each(El, function (r) {
        e.style.cssText +=
          "background: " +
          r +
          "linear-gradient(" +
          t +
          ", " +
          n +
          " 0%, " +
          i +
          " 100%); ";
      });
  }
  var Al =
      '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
    Ll = function (e, t) {
      var n = e[t];
      return Yc.isArray(arguments[2]) || Yc.isObject(arguments[2])
        ? new gl(e, t, arguments[2])
        : Yc.isNumber(n)
        ? Yc.isNumber(arguments[2]) && Yc.isNumber(arguments[3])
          ? Yc.isNumber(arguments[4])
            ? new wl(e, t, arguments[2], arguments[3], arguments[4])
            : new wl(e, t, arguments[2], arguments[3])
          : Yc.isNumber(arguments[4])
          ? new _l(e, t, {
              min: arguments[2],
              max: arguments[3],
              step: arguments[4],
            })
          : new _l(e, t, { min: arguments[2], max: arguments[3] })
        : Yc.isString(n)
        ? new vl(e, t)
        : Yc.isFunction(n)
        ? new Ml(e, t, "")
        : Yc.isBoolean(n)
        ? new ml(e, t)
        : null;
    },
    Rl =
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function (e) {
        setTimeout(e, 1e3 / 60);
      },
    Cl = (function () {
      function e() {
        nl(this, e),
          (this.backgroundElement = document.createElement("div")),
          Yc.extend(this.backgroundElement.style, {
            backgroundColor: "rgba(0,0,0,0.8)",
            top: 0,
            left: 0,
            display: "none",
            zIndex: "1000",
            opacity: 0,
            WebkitTransition: "opacity 0.2s linear",
            transition: "opacity 0.2s linear",
          }),
          fl.makeFullscreen(this.backgroundElement),
          (this.backgroundElement.style.position = "fixed"),
          (this.domElement = document.createElement("div")),
          Yc.extend(this.domElement.style, {
            position: "fixed",
            display: "none",
            zIndex: "1001",
            opacity: 0,
            WebkitTransition:
              "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
            transition: "transform 0.2s ease-out, opacity 0.2s linear",
          }),
          document.body.appendChild(this.backgroundElement),
          document.body.appendChild(this.domElement);
        var t = this;
        fl.bind(this.backgroundElement, "click", function () {
          t.hide();
        });
      }
      return (
        il(e, [
          {
            key: "show",
            value: function () {
              var e = this;
              (this.backgroundElement.style.display = "block"),
                (this.domElement.style.display = "block"),
                (this.domElement.style.opacity = 0),
                (this.domElement.style.webkitTransform = "scale(1.1)"),
                this.layout(),
                Yc.defer(function () {
                  (e.backgroundElement.style.opacity = 1),
                    (e.domElement.style.opacity = 1),
                    (e.domElement.style.webkitTransform = "scale(1)");
                });
            },
          },
          {
            key: "hide",
            value: function () {
              var e = this,
                t = function t() {
                  (e.domElement.style.display = "none"),
                    (e.backgroundElement.style.display = "none"),
                    fl.unbind(e.domElement, "webkitTransitionEnd", t),
                    fl.unbind(e.domElement, "transitionend", t),
                    fl.unbind(e.domElement, "oTransitionEnd", t);
                };
              fl.bind(this.domElement, "webkitTransitionEnd", t),
                fl.bind(this.domElement, "transitionend", t),
                fl.bind(this.domElement, "oTransitionEnd", t),
                (this.backgroundElement.style.opacity = 0),
                (this.domElement.style.opacity = 0),
                (this.domElement.style.webkitTransform = "scale(1.1)");
            },
          },
          {
            key: "layout",
            value: function () {
              (this.domElement.style.left =
                window.innerWidth / 2 -
                fl.getWidth(this.domElement) / 2 +
                "px"),
                (this.domElement.style.top =
                  window.innerHeight / 2 -
                  fl.getHeight(this.domElement) / 2 +
                  "px");
            },
          },
        ]),
        e
      );
    })();
  !(function (e, t) {
    var n = t || document,
      i = document.createElement("style");
    (i.type = "text/css"), (i.innerHTML = e);
    var r = n.getElementsByTagName("head")[0];
    try {
      r.appendChild(i);
    } catch (e) {}
  })(
    (function (e) {
      if ("undefined" != typeof window) {
        var t = document.createElement("style");
        return (
          t.setAttribute("type", "text/css"),
          (t.innerHTML = e),
          document.head.appendChild(t),
          e
        );
      }
    })(
      ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"
    )
  );
  var Pl = "Default",
    Ol = (function () {
      try {
        return !!window.localStorage;
      } catch (e) {
        return !1;
      }
    })(),
    Il = void 0,
    Nl = !0,
    Dl = void 0,
    Fl = !1,
    Ul = [],
    kl = function e(t) {
      var n = this,
        i = t || {};
      (this.domElement = document.createElement("div")),
        (this.__ul = document.createElement("ul")),
        this.domElement.appendChild(this.__ul),
        fl.addClass(this.domElement, "dg"),
        (this.__folders = {}),
        (this.__controllers = []),
        (this.__rememberedObjects = []),
        (this.__rememberedObjectIndecesToControllers = []),
        (this.__listening = []),
        (i = Yc.defaults(i, {
          closeOnTop: !1,
          autoPlace: !0,
          width: e.DEFAULT_WIDTH,
        })),
        (i = Yc.defaults(i, { resizable: i.autoPlace, hideable: i.autoPlace })),
        Yc.isUndefined(i.load)
          ? (i.load = { preset: Pl })
          : i.preset && (i.load.preset = i.preset),
        Yc.isUndefined(i.parent) && i.hideable && Ul.push(this),
        (i.resizable = Yc.isUndefined(i.parent) && i.resizable),
        i.autoPlace && Yc.isUndefined(i.scrollable) && (i.scrollable = !0);
      var r,
        o = Ol && "true" === localStorage.getItem(jl(0, "isLocal")),
        s = void 0,
        a = void 0;
      if (
        (Object.defineProperties(this, {
          parent: {
            get: function () {
              return i.parent;
            },
          },
          scrollable: {
            get: function () {
              return i.scrollable;
            },
          },
          autoPlace: {
            get: function () {
              return i.autoPlace;
            },
          },
          closeOnTop: {
            get: function () {
              return i.closeOnTop;
            },
          },
          preset: {
            get: function () {
              return n.parent ? n.getRoot().preset : i.load.preset;
            },
            set: function (e) {
              n.parent ? (n.getRoot().preset = e) : (i.load.preset = e),
                (function (e) {
                  for (var t = 0; t < e.__preset_select.length; t++)
                    e.__preset_select[t].value === e.preset &&
                      (e.__preset_select.selectedIndex = t);
                })(this),
                n.revert();
            },
          },
          width: {
            get: function () {
              return i.width;
            },
            set: function (e) {
              (i.width = e), Zl(n, e);
            },
          },
          name: {
            get: function () {
              return i.name;
            },
            set: function (e) {
              (i.name = e), a && (a.innerHTML = i.name);
            },
          },
          closed: {
            get: function () {
              return i.closed;
            },
            set: function (t) {
              (i.closed = t),
                i.closed
                  ? fl.addClass(n.__ul, e.CLASS_CLOSED)
                  : fl.removeClass(n.__ul, e.CLASS_CLOSED),
                this.onResize(),
                n.__closeButton &&
                  (n.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED);
            },
          },
          load: {
            get: function () {
              return i.load;
            },
          },
          useLocalStorage: {
            get: function () {
              return o;
            },
            set: function (e) {
              Ol &&
                ((o = e),
                e
                  ? fl.bind(window, "unload", s)
                  : fl.unbind(window, "unload", s),
                localStorage.setItem(jl(0, "isLocal"), e));
            },
          },
        }),
        Yc.isUndefined(i.parent))
      ) {
        if (
          ((this.closed = i.closed || !1),
          fl.addClass(this.domElement, e.CLASS_MAIN),
          fl.makeSelectable(this.domElement, !1),
          Ol && o)
        ) {
          n.useLocalStorage = !0;
          var c = localStorage.getItem(jl(0, "gui"));
          c && (i.load = JSON.parse(c));
        }
        (this.__closeButton = document.createElement("div")),
          (this.__closeButton.innerHTML = e.TEXT_CLOSED),
          fl.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON),
          i.closeOnTop
            ? (fl.addClass(this.__closeButton, e.CLASS_CLOSE_TOP),
              this.domElement.insertBefore(
                this.__closeButton,
                this.domElement.childNodes[0]
              ))
            : (fl.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM),
              this.domElement.appendChild(this.__closeButton)),
          fl.bind(this.__closeButton, "click", function () {
            n.closed = !n.closed;
          });
      } else {
        void 0 === i.closed && (i.closed = !0);
        var l = document.createTextNode(i.name);
        fl.addClass(l, "controller-name"),
          (a = Bl(n, l)),
          fl.addClass(this.__ul, e.CLASS_CLOSED),
          fl.addClass(a, "title"),
          fl.bind(a, "click", function (e) {
            return e.preventDefault(), (n.closed = !n.closed), !1;
          }),
          i.closed || (this.closed = !1);
      }
      i.autoPlace &&
        (Yc.isUndefined(i.parent) &&
          (Nl &&
            ((Dl = document.createElement("div")),
            fl.addClass(Dl, "dg"),
            fl.addClass(Dl, e.CLASS_AUTO_PLACE_CONTAINER),
            document.body.appendChild(Dl),
            (Nl = !1)),
          Dl.appendChild(this.domElement),
          fl.addClass(this.domElement, e.CLASS_AUTO_PLACE)),
        this.parent || Zl(n, i.width)),
        (this.__resizeHandler = function () {
          n.onResizeDebounced();
        }),
        fl.bind(window, "resize", this.__resizeHandler),
        fl.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
        fl.bind(this.__ul, "transitionend", this.__resizeHandler),
        fl.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
        this.onResize(),
        i.resizable && Yl(this),
        (s = function () {
          Ol &&
            "true" === localStorage.getItem(jl(0, "isLocal")) &&
            localStorage.setItem(
              jl(0, "gui"),
              JSON.stringify(n.getSaveObject())
            );
        }),
        (this.saveToLocalStorageIfPossible = s),
        i.parent ||
          (((r = n.getRoot()).width += 1),
          Yc.defer(function () {
            r.width -= 1;
          }));
    };
  function Bl(e, t, n) {
    var i = document.createElement("li");
    return (
      t && i.appendChild(t),
      n ? e.__ul.insertBefore(i, n) : e.__ul.appendChild(i),
      e.onResize(),
      i
    );
  }
  function zl(e) {
    fl.unbind(window, "resize", e.__resizeHandler),
      e.saveToLocalStorageIfPossible &&
        fl.unbind(window, "unload", e.saveToLocalStorageIfPossible);
  }
  function Hl(e, t) {
    var n = e.__preset_select[e.__preset_select.selectedIndex];
    n.innerHTML = t ? n.value + "*" : n.value;
  }
  function Gl(e, t) {
    var n = e.getRoot(),
      i = n.__rememberedObjects.indexOf(t.object);
    if (-1 !== i) {
      var r = n.__rememberedObjectIndecesToControllers[i];
      if (
        (void 0 === r &&
          ((r = {}), (n.__rememberedObjectIndecesToControllers[i] = r)),
        (r[t.property] = t),
        n.load && n.load.remembered)
      ) {
        var o = n.load.remembered,
          s = void 0;
        if (o[e.preset]) s = o[e.preset];
        else {
          if (!o.Default) return;
          s = o.Default;
        }
        if (s[i] && void 0 !== s[i][t.property]) {
          var a = s[i][t.property];
          (t.initialValue = a), t.setValue(a);
        }
      }
    }
  }
  function Vl(e, t, n, i) {
    if (void 0 === t[n])
      throw new Error('Object "' + t + '" has no property "' + n + '"');
    var r = void 0;
    if (i.color) r = new Sl(t, n);
    else {
      var o = [t, n].concat(i.factoryArgs);
      r = Ll.apply(e, o);
    }
    i.before instanceof hl && (i.before = i.before.__li),
      Gl(e, r),
      fl.addClass(r.domElement, "c");
    var s = document.createElement("span");
    fl.addClass(s, "property-name"), (s.innerHTML = r.property);
    var a = document.createElement("div");
    a.appendChild(s), a.appendChild(r.domElement);
    var c = Bl(e, a, i.before);
    return (
      fl.addClass(c, kl.CLASS_CONTROLLER_ROW),
      r instanceof Sl
        ? fl.addClass(c, "color")
        : fl.addClass(c, tl(r.getValue())),
      (function (e, t, n) {
        if (
          ((n.__li = t),
          (n.__gui = e),
          Yc.extend(n, {
            options: function (t) {
              if (arguments.length > 1) {
                var i = n.__li.nextElementSibling;
                return (
                  n.remove(),
                  Vl(e, n.object, n.property, {
                    before: i,
                    factoryArgs: [Yc.toArray(arguments)],
                  })
                );
              }
              if (Yc.isArray(t) || Yc.isObject(t)) {
                var r = n.__li.nextElementSibling;
                return (
                  n.remove(),
                  Vl(e, n.object, n.property, { before: r, factoryArgs: [t] })
                );
              }
            },
            name: function (e) {
              return (
                (n.__li.firstElementChild.firstElementChild.innerHTML = e), n
              );
            },
            listen: function () {
              return n.__gui.listen(n), n;
            },
            remove: function () {
              return n.__gui.remove(n), n;
            },
          }),
          n instanceof wl)
        ) {
          var i = new _l(n.object, n.property, {
            min: n.__min,
            max: n.__max,
            step: n.__step,
          });
          Yc.each(
            [
              "updateDisplay",
              "onChange",
              "onFinishChange",
              "step",
              "min",
              "max",
            ],
            function (e) {
              var t = n[e],
                r = i[e];
              n[e] = i[e] = function () {
                var e = Array.prototype.slice.call(arguments);
                return r.apply(i, e), t.apply(n, e);
              };
            }
          ),
            fl.addClass(t, "has-slider"),
            n.domElement.insertBefore(
              i.domElement,
              n.domElement.firstElementChild
            );
        } else if (n instanceof _l) {
          var r = function (t) {
            if (Yc.isNumber(n.__min) && Yc.isNumber(n.__max)) {
              var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                r = n.__gui.__listening.indexOf(n) > -1;
              n.remove();
              var o = Vl(e, n.object, n.property, {
                before: n.__li.nextElementSibling,
                factoryArgs: [n.__min, n.__max, n.__step],
              });
              return o.name(i), r && o.listen(), o;
            }
            return t;
          };
          (n.min = Yc.compose(r, n.min)), (n.max = Yc.compose(r, n.max));
        } else
          n instanceof ml
            ? (fl.bind(t, "click", function () {
                fl.fakeEvent(n.__checkbox, "click");
              }),
              fl.bind(n.__checkbox, "click", function (e) {
                e.stopPropagation();
              }))
            : n instanceof Ml
            ? (fl.bind(t, "click", function () {
                fl.fakeEvent(n.__button, "click");
              }),
              fl.bind(t, "mouseover", function () {
                fl.addClass(n.__button, "hover");
              }),
              fl.bind(t, "mouseout", function () {
                fl.removeClass(n.__button, "hover");
              }))
            : n instanceof Sl &&
              (fl.addClass(t, "color"),
              (n.updateDisplay = Yc.compose(function (e) {
                return (t.style.borderLeftColor = n.__color.toString()), e;
              }, n.updateDisplay)),
              n.updateDisplay());
        n.setValue = Yc.compose(function (t) {
          return (
            e.getRoot().__preset_select &&
              n.isModified() &&
              Hl(e.getRoot(), !0),
            t
          );
        }, n.setValue);
      })(e, c, r),
      e.__controllers.push(r),
      r
    );
  }
  function jl(e, t) {
    return document.location.href + "." + t;
  }
  function Wl(e, t, n) {
    var i = document.createElement("option");
    (i.innerHTML = t),
      (i.value = t),
      e.__preset_select.appendChild(i),
      n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1);
  }
  function Xl(e, t) {
    t.style.display = e.useLocalStorage ? "block" : "none";
  }
  function ql(e) {
    var t = (e.__save_row = document.createElement("li"));
    fl.addClass(e.domElement, "has-save"),
      e.__ul.insertBefore(t, e.__ul.firstChild),
      fl.addClass(t, "save-row");
    var n = document.createElement("span");
    (n.innerHTML = "&nbsp;"), fl.addClass(n, "button gears");
    var i = document.createElement("span");
    (i.innerHTML = "Save"), fl.addClass(i, "button"), fl.addClass(i, "save");
    var r = document.createElement("span");
    (r.innerHTML = "New"), fl.addClass(r, "button"), fl.addClass(r, "save-as");
    var o = document.createElement("span");
    (o.innerHTML = "Revert"),
      fl.addClass(o, "button"),
      fl.addClass(o, "revert");
    var s = (e.__preset_select = document.createElement("select"));
    if (
      (e.load && e.load.remembered
        ? Yc.each(e.load.remembered, function (t, n) {
            Wl(e, n, n === e.preset);
          })
        : Wl(e, Pl, !1),
      fl.bind(s, "change", function () {
        for (var t = 0; t < e.__preset_select.length; t++)
          e.__preset_select[t].innerHTML = e.__preset_select[t].value;
        e.preset = this.value;
      }),
      t.appendChild(s),
      t.appendChild(n),
      t.appendChild(i),
      t.appendChild(r),
      t.appendChild(o),
      Ol)
    ) {
      var a = document.getElementById("dg-local-explain"),
        c = document.getElementById("dg-local-storage");
      (document.getElementById("dg-save-locally").style.display = "block"),
        "true" === localStorage.getItem(jl(0, "isLocal")) &&
          c.setAttribute("checked", "checked"),
        Xl(e, a),
        fl.bind(c, "change", function () {
          (e.useLocalStorage = !e.useLocalStorage), Xl(e, a);
        });
    }
    var l = document.getElementById("dg-new-constructor");
    fl.bind(l, "keydown", function (e) {
      !e.metaKey || (67 !== e.which && 67 !== e.keyCode) || Il.hide();
    }),
      fl.bind(n, "click", function () {
        (l.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2)),
          Il.show(),
          l.focus(),
          l.select();
      }),
      fl.bind(i, "click", function () {
        e.save();
      }),
      fl.bind(r, "click", function () {
        var t = prompt("Enter a new preset name.");
        t && e.saveAs(t);
      }),
      fl.bind(o, "click", function () {
        e.revert();
      });
  }
  function Yl(e) {
    var t = void 0;
    function n(n) {
      return (
        n.preventDefault(),
        (e.width += t - n.clientX),
        e.onResize(),
        (t = n.clientX),
        !1
      );
    }
    function i() {
      fl.removeClass(e.__closeButton, kl.CLASS_DRAG),
        fl.unbind(window, "mousemove", n),
        fl.unbind(window, "mouseup", i);
    }
    function r(r) {
      return (
        r.preventDefault(),
        (t = r.clientX),
        fl.addClass(e.__closeButton, kl.CLASS_DRAG),
        fl.bind(window, "mousemove", n),
        fl.bind(window, "mouseup", i),
        !1
      );
    }
    (e.__resize_handle = document.createElement("div")),
      Yc.extend(e.__resize_handle.style, {
        width: "6px",
        marginLeft: "-3px",
        height: "200px",
        cursor: "ew-resize",
        position: "absolute",
      }),
      fl.bind(e.__resize_handle, "mousedown", r),
      fl.bind(e.__closeButton, "mousedown", r),
      e.domElement.insertBefore(
        e.__resize_handle,
        e.domElement.firstElementChild
      );
  }
  function Zl(e, t) {
    (e.domElement.style.width = t + "px"),
      e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"),
      e.__closeButton && (e.__closeButton.style.width = t + "px");
  }
  function Jl(e, t) {
    var n = {};
    return (
      Yc.each(e.__rememberedObjects, function (i, r) {
        var o = {},
          s = e.__rememberedObjectIndecesToControllers[r];
        Yc.each(s, function (e, n) {
          o[n] = t ? e.initialValue : e.getValue();
        }),
          (n[r] = o);
      }),
      n
    );
  }
  function Kl(e) {
    0 !== e.length &&
      Rl.call(window, function () {
        Kl(e);
      }),
      Yc.each(e, function (e) {
        e.updateDisplay();
      });
  }
  (kl.toggleHide = function () {
    (Fl = !Fl),
      Yc.each(Ul, function (e) {
        e.domElement.style.display = Fl ? "none" : "";
      });
  }),
    (kl.CLASS_AUTO_PLACE = "a"),
    (kl.CLASS_AUTO_PLACE_CONTAINER = "ac"),
    (kl.CLASS_MAIN = "main"),
    (kl.CLASS_CONTROLLER_ROW = "cr"),
    (kl.CLASS_TOO_TALL = "taller-than-window"),
    (kl.CLASS_CLOSED = "closed"),
    (kl.CLASS_CLOSE_BUTTON = "close-button"),
    (kl.CLASS_CLOSE_TOP = "close-top"),
    (kl.CLASS_CLOSE_BOTTOM = "close-bottom"),
    (kl.CLASS_DRAG = "drag"),
    (kl.DEFAULT_WIDTH = 245),
    (kl.TEXT_CLOSED = "Close Controls"),
    (kl.TEXT_OPEN = "Open Controls"),
    (kl._keydownHandler = function (e) {
      "text" === document.activeElement.type ||
        (72 !== e.which && 72 !== e.keyCode) ||
        kl.toggleHide();
    }),
    fl.bind(window, "keydown", kl._keydownHandler, !1),
    Yc.extend(kl.prototype, {
      add: function (e, t) {
        return Vl(this, e, t, {
          factoryArgs: Array.prototype.slice.call(arguments, 2),
        });
      },
      addColor: function (e, t) {
        return Vl(this, e, t, { color: !0 });
      },
      remove: function (e) {
        this.__ul.removeChild(e.__li),
          this.__controllers.splice(this.__controllers.indexOf(e), 1);
        var t = this;
        Yc.defer(function () {
          t.onResize();
        });
      },
      destroy: function () {
        if (this.parent)
          throw new Error(
            "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."
          );
        this.autoPlace && Dl.removeChild(this.domElement);
        var e = this;
        Yc.each(this.__folders, function (t) {
          e.removeFolder(t);
        }),
          fl.unbind(window, "keydown", kl._keydownHandler, !1),
          zl(this);
      },
      addFolder: function (e) {
        if (void 0 !== this.__folders[e])
          throw new Error(
            'You already have a folder in this GUI by the name "' + e + '"'
          );
        var t = { name: e, parent: this };
        (t.autoPlace = this.autoPlace),
          this.load &&
            this.load.folders &&
            this.load.folders[e] &&
            ((t.closed = this.load.folders[e].closed),
            (t.load = this.load.folders[e]));
        var n = new kl(t);
        this.__folders[e] = n;
        var i = Bl(this, n.domElement);
        return fl.addClass(i, "folder"), n;
      },
      removeFolder: function (e) {
        this.__ul.removeChild(e.domElement.parentElement),
          delete this.__folders[e.name],
          this.load &&
            this.load.folders &&
            this.load.folders[e.name] &&
            delete this.load.folders[e.name],
          zl(e);
        var t = this;
        Yc.each(e.__folders, function (t) {
          e.removeFolder(t);
        }),
          Yc.defer(function () {
            t.onResize();
          });
      },
      open: function () {
        this.closed = !1;
      },
      close: function () {
        this.closed = !0;
      },
      hide: function () {
        this.domElement.style.display = "none";
      },
      show: function () {
        this.domElement.style.display = "";
      },
      onResize: function () {
        var e = this.getRoot();
        if (e.scrollable) {
          var t = fl.getOffset(e.__ul).top,
            n = 0;
          Yc.each(e.__ul.childNodes, function (t) {
            (e.autoPlace && t === e.__save_row) || (n += fl.getHeight(t));
          }),
            window.innerHeight - t - 20 < n
              ? (fl.addClass(e.domElement, kl.CLASS_TOO_TALL),
                (e.__ul.style.height = window.innerHeight - t - 20 + "px"))
              : (fl.removeClass(e.domElement, kl.CLASS_TOO_TALL),
                (e.__ul.style.height = "auto"));
        }
        e.__resize_handle &&
          Yc.defer(function () {
            e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
          }),
          e.__closeButton && (e.__closeButton.style.width = e.width + "px");
      },
      onResizeDebounced: Yc.debounce(function () {
        this.onResize();
      }, 50),
      remember: function () {
        if (
          (Yc.isUndefined(Il) && ((Il = new Cl()).domElement.innerHTML = Al),
          this.parent)
        )
          throw new Error("You can only call remember on a top level GUI.");
        var e = this;
        Yc.each(Array.prototype.slice.call(arguments), function (t) {
          0 === e.__rememberedObjects.length && ql(e),
            -1 === e.__rememberedObjects.indexOf(t) &&
              e.__rememberedObjects.push(t);
        }),
          this.autoPlace && Zl(this, this.width);
      },
      getRoot: function () {
        for (var e = this; e.parent; ) e = e.parent;
        return e;
      },
      getSaveObject: function () {
        var e = this.load;
        return (
          (e.closed = this.closed),
          this.__rememberedObjects.length > 0 &&
            ((e.preset = this.preset),
            e.remembered || (e.remembered = {}),
            (e.remembered[this.preset] = Jl(this))),
          (e.folders = {}),
          Yc.each(this.__folders, function (t, n) {
            e.folders[n] = t.getSaveObject();
          }),
          e
        );
      },
      save: function () {
        this.load.remembered || (this.load.remembered = {}),
          (this.load.remembered[this.preset] = Jl(this)),
          Hl(this, !1),
          this.saveToLocalStorageIfPossible();
      },
      saveAs: function (e) {
        this.load.remembered ||
          ((this.load.remembered = {}),
          (this.load.remembered.Default = Jl(this, !0))),
          (this.load.remembered[e] = Jl(this)),
          (this.preset = e),
          Wl(this, e, !0),
          this.saveToLocalStorageIfPossible();
      },
      revert: function (e) {
        Yc.each(
          this.__controllers,
          function (t) {
            this.getRoot().load.remembered
              ? Gl(e || this.getRoot(), t)
              : t.setValue(t.initialValue),
              t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
          },
          this
        ),
          Yc.each(this.__folders, function (e) {
            e.revert(e);
          }),
          e || Hl(this.getRoot(), !1);
      },
      listen: function (e) {
        var t = 0 === this.__listening.length;
        this.__listening.push(e), t && Kl(this.__listening);
      },
      updateDisplay: function () {
        Yc.each(this.__controllers, function (e) {
          e.updateDisplay();
        }),
          Yc.each(this.__folders, function (e) {
            e.updateDisplay();
          });
      },
    });
  var Ql = kl;
  const $l = new ca(),
    eh =
      ($l.load("/textures/door/color.jpg"),
      $l.load("/textures/door/alpha.jpg"),
      $l.load("/textures/door/ambientOcclusion.jpg"),
      $l.load("/textures/door/height.jpg"),
      $l.load("/textures/door/normal.jpg"),
      $l.load("/textures/door/metalness.jpg"),
      $l.load("/textures/door/roughness.jpg"),
      $l.load("/textures/bricks/color.jpg"),
      $l.load("/textures/bricks/ambientOcclusion.jpg"),
      $l.load("/textures/bricks/normal.jpg"),
      $l.load("/textures/bricks/roughness.jpg"),
      $l.load("/textures/grass/color.jpg")),
    th = $l.load("/textures/grass/ambientOcclusion.jpg"),
    nh = $l.load("/textures/grass/normal.jpg"),
    ih = $l.load("/textures/grass/roughness.jpg"),
    rh = $l.load("/textures/tombstone/texture.jpg"),
    oh = $l.load("/textures/tombstone/texturereflection.jpg"),
    sh = $l.load("/textures/tombstone/rip.jpg");
  eh.repeat.set(8, 8),
    th.repeat.set(8, 8),
    nh.repeat.set(8, 8),
    ih.repeat.set(8, 8),
    (eh.wrapS = t),
    (th.wrapS = t),
    (nh.wrapS = t),
    (ih.wrapS = t),
    (eh.wrapT = t),
    (th.wrapT = t),
    (nh.wrapT = t),
    (ih.wrapT = t);
  const ah = new sn(
    new Tn(20, 20),
    new As({ map: eh, aoMap: th, normalMap: nh, roughnessMap: ih })
  );
  (ah.receiveShadow = !0),
    ah.geometry.setAttribute("uv2", new Lt(ah.geometry.attributes.uv.array, 2)),
    (ah.rotation.x = 0.5 * -Math.PI),
    (ah.position.y = 0);
  var ch = function (e, t) {
    var n, i, r, o, s, a;
    void 0 === t &&
      console.warn(
        'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
      ),
      t === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.target = new W()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.enableKeys = !0),
      (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
      (this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }),
      (this.touches = { ONE: 0, TWO: 2 }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = function () {
        return m.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return m.theta;
      }),
      (this.saveState = function () {
        c.target0.copy(c.target),
          c.position0.copy(c.object.position),
          (c.zoom0 = c.object.zoom);
      }),
      (this.reset = function () {
        c.target.copy(c.target0),
          c.object.position.copy(c.position0),
          (c.object.zoom = c.zoom0),
          c.object.updateProjectionMatrix(),
          c.dispatchEvent(l),
          c.update(),
          (p = d.NONE);
      }),
      (this.update =
        ((n = new W()),
        (i = new j().setFromUnitVectors(e.up, new W(0, 1, 0))),
        (r = i.clone().invert()),
        (o = new W()),
        (s = new j()),
        (a = 2 * Math.PI),
        function () {
          var e = c.object.position;
          n.copy(e).sub(c.target),
            n.applyQuaternion(i),
            m.setFromVector3(n),
            c.autoRotate &&
              p === d.NONE &&
              C(((2 * Math.PI) / 60 / 60) * c.autoRotateSpeed),
            c.enableDamping
              ? ((m.theta += g.theta * c.dampingFactor),
                (m.phi += g.phi * c.dampingFactor))
              : ((m.theta += g.theta), (m.phi += g.phi));
          var t = c.minAzimuthAngle,
            h = c.maxAzimuthAngle;
          return (
            isFinite(t) &&
              isFinite(h) &&
              (t < -Math.PI ? (t += a) : t > Math.PI && (t -= a),
              h < -Math.PI ? (h += a) : h > Math.PI && (h -= a),
              (m.theta =
                t <= h
                  ? Math.max(t, Math.min(h, m.theta))
                  : m.theta > (t + h) / 2
                  ? Math.max(t, m.theta)
                  : Math.min(h, m.theta))),
            (m.phi = Math.max(
              c.minPolarAngle,
              Math.min(c.maxPolarAngle, m.phi)
            )),
            m.makeSafe(),
            (m.radius *= v),
            (m.radius = Math.max(
              c.minDistance,
              Math.min(c.maxDistance, m.radius)
            )),
            !0 === c.enableDamping
              ? c.target.addScaledVector(y, c.dampingFactor)
              : c.target.add(y),
            n.setFromSpherical(m),
            n.applyQuaternion(r),
            e.copy(c.target).add(n),
            c.object.lookAt(c.target),
            !0 === c.enableDamping
              ? ((g.theta *= 1 - c.dampingFactor),
                (g.phi *= 1 - c.dampingFactor),
                y.multiplyScalar(1 - c.dampingFactor))
              : (g.set(0, 0, 0), y.set(0, 0, 0)),
            (v = 1),
            !!(
              x ||
              o.distanceToSquared(c.object.position) > f ||
              8 * (1 - s.dot(c.object.quaternion)) > f
            ) &&
              (c.dispatchEvent(l),
              o.copy(c.object.position),
              s.copy(c.object.quaternion),
              (x = !1),
              !0)
          );
        })),
      (this.dispose = function () {
        c.domElement.removeEventListener("contextmenu", ne, !1),
          c.domElement.removeEventListener("pointerdown", Y, !1),
          c.domElement.removeEventListener("wheel", K, !1),
          c.domElement.removeEventListener("touchstart", $, !1),
          c.domElement.removeEventListener("touchend", te, !1),
          c.domElement.removeEventListener("touchmove", ee, !1),
          c.domElement.ownerDocument.removeEventListener("pointermove", Z, !1),
          c.domElement.ownerDocument.removeEventListener("pointerup", J, !1),
          c.domElement.removeEventListener("keydown", Q, !1);
      });
    var c = this,
      l = { type: "change" },
      h = { type: "start" },
      u = { type: "end" },
      d = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      },
      p = d.NONE,
      f = 1e-6,
      m = new Cc(),
      g = new Cc(),
      v = 1,
      y = new W(),
      x = !1,
      _ = new N(),
      b = new N(),
      w = new N(),
      M = new N(),
      S = new N(),
      E = new N(),
      T = new N(),
      A = new N(),
      L = new N();
    function R() {
      return Math.pow(0.95, c.zoomSpeed);
    }
    function C(e) {
      g.theta -= e;
    }
    function P(e) {
      g.phi -= e;
    }
    var O = (function () {
        var e = new W();
        return function (t, n) {
          e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), y.add(e);
        };
      })(),
      I = (function () {
        var e = new W();
        return function (t, n) {
          !0 === c.screenSpacePanning
            ? e.setFromMatrixColumn(n, 1)
            : (e.setFromMatrixColumn(n, 0), e.crossVectors(c.object.up, e)),
            e.multiplyScalar(t),
            y.add(e);
        };
      })(),
      D = (function () {
        var e = new W();
        return function (t, n) {
          var i = c.domElement;
          if (c.object.isPerspectiveCamera) {
            var r = c.object.position;
            e.copy(r).sub(c.target);
            var o = e.length();
            (o *= Math.tan(((c.object.fov / 2) * Math.PI) / 180)),
              O((2 * t * o) / i.clientHeight, c.object.matrix),
              I((2 * n * o) / i.clientHeight, c.object.matrix);
          } else
            c.object.isOrthographicCamera
              ? (O(
                  (t * (c.object.right - c.object.left)) /
                    c.object.zoom /
                    i.clientWidth,
                  c.object.matrix
                ),
                I(
                  (n * (c.object.top - c.object.bottom)) /
                    c.object.zoom /
                    i.clientHeight,
                  c.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (c.enablePan = !1));
        };
      })();
    function F(e) {
      c.object.isPerspectiveCamera
        ? (v /= e)
        : c.object.isOrthographicCamera
        ? ((c.object.zoom = Math.max(
            c.minZoom,
            Math.min(c.maxZoom, c.object.zoom * e)
          )),
          c.object.updateProjectionMatrix(),
          (x = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (c.enableZoom = !1));
    }
    function U(e) {
      c.object.isPerspectiveCamera
        ? (v *= e)
        : c.object.isOrthographicCamera
        ? ((c.object.zoom = Math.max(
            c.minZoom,
            Math.min(c.maxZoom, c.object.zoom / e)
          )),
          c.object.updateProjectionMatrix(),
          (x = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (c.enableZoom = !1));
    }
    function k(e) {
      _.set(e.clientX, e.clientY);
    }
    function B(e) {
      M.set(e.clientX, e.clientY);
    }
    function z(e) {
      if (1 == e.touches.length) _.set(e.touches[0].pageX, e.touches[0].pageY);
      else {
        var t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
          n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
        _.set(t, n);
      }
    }
    function H(e) {
      if (1 == e.touches.length) M.set(e.touches[0].pageX, e.touches[0].pageY);
      else {
        var t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
          n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
        M.set(t, n);
      }
    }
    function G(e) {
      var t = e.touches[0].pageX - e.touches[1].pageX,
        n = e.touches[0].pageY - e.touches[1].pageY,
        i = Math.sqrt(t * t + n * n);
      T.set(0, i);
    }
    function V(e) {
      if (1 == e.touches.length) b.set(e.touches[0].pageX, e.touches[0].pageY);
      else {
        var t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
          n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
        b.set(t, n);
      }
      w.subVectors(b, _).multiplyScalar(c.rotateSpeed);
      var i = c.domElement;
      C((2 * Math.PI * w.x) / i.clientHeight),
        P((2 * Math.PI * w.y) / i.clientHeight),
        _.copy(b);
    }
    function X(e) {
      if (1 == e.touches.length) S.set(e.touches[0].pageX, e.touches[0].pageY);
      else {
        var t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
          n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
        S.set(t, n);
      }
      E.subVectors(S, M).multiplyScalar(c.panSpeed), D(E.x, E.y), M.copy(S);
    }
    function q(e) {
      var t = e.touches[0].pageX - e.touches[1].pageX,
        n = e.touches[0].pageY - e.touches[1].pageY,
        i = Math.sqrt(t * t + n * n);
      A.set(0, i),
        L.set(0, Math.pow(A.y / T.y, c.zoomSpeed)),
        F(L.y),
        T.copy(A);
    }
    function Y(e) {
      if (!1 !== c.enabled)
        switch (e.pointerType) {
          case "mouse":
          case "pen":
            !(function (e) {
              var t;
              switch (
                (e.preventDefault(),
                c.domElement.focus ? c.domElement.focus() : window.focus(),
                e.button)
              ) {
                case 0:
                  t = c.mouseButtons.LEFT;
                  break;
                case 1:
                  t = c.mouseButtons.MIDDLE;
                  break;
                case 2:
                  t = c.mouseButtons.RIGHT;
                  break;
                default:
                  t = -1;
              }
              switch (t) {
                case 1:
                  if (!1 === c.enableZoom) return;
                  !(function (e) {
                    T.set(e.clientX, e.clientY);
                  })(e),
                    (p = d.DOLLY);
                  break;
                case 0:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === c.enablePan) return;
                    B(e), (p = d.PAN);
                  } else {
                    if (!1 === c.enableRotate) return;
                    k(e), (p = d.ROTATE);
                  }
                  break;
                case 2:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === c.enableRotate) return;
                    k(e), (p = d.ROTATE);
                  } else {
                    if (!1 === c.enablePan) return;
                    B(e), (p = d.PAN);
                  }
                  break;
                default:
                  p = d.NONE;
              }
              p !== d.NONE &&
                (c.domElement.ownerDocument.addEventListener(
                  "pointermove",
                  Z,
                  !1
                ),
                c.domElement.ownerDocument.addEventListener("pointerup", J, !1),
                c.dispatchEvent(h));
            })(e);
        }
    }
    function Z(e) {
      if (!1 !== c.enabled)
        switch (e.pointerType) {
          case "mouse":
          case "pen":
            !(function (e) {
              if (!1 !== c.enabled)
                switch ((e.preventDefault(), p)) {
                  case d.ROTATE:
                    if (!1 === c.enableRotate) return;
                    !(function (e) {
                      b.set(e.clientX, e.clientY),
                        w.subVectors(b, _).multiplyScalar(c.rotateSpeed);
                      var t = c.domElement;
                      C((2 * Math.PI * w.x) / t.clientHeight),
                        P((2 * Math.PI * w.y) / t.clientHeight),
                        _.copy(b),
                        c.update();
                    })(e);
                    break;
                  case d.DOLLY:
                    if (!1 === c.enableZoom) return;
                    !(function (e) {
                      A.set(e.clientX, e.clientY),
                        L.subVectors(A, T),
                        L.y > 0 ? F(R()) : L.y < 0 && U(R()),
                        T.copy(A),
                        c.update();
                    })(e);
                    break;
                  case d.PAN:
                    if (!1 === c.enablePan) return;
                    !(function (e) {
                      S.set(e.clientX, e.clientY),
                        E.subVectors(S, M).multiplyScalar(c.panSpeed),
                        D(E.x, E.y),
                        M.copy(S),
                        c.update();
                    })(e);
                }
            })(e);
        }
    }
    function J(e) {
      switch (e.pointerType) {
        case "mouse":
        case "pen":
          c.domElement.ownerDocument.removeEventListener("pointermove", Z, !1),
            c.domElement.ownerDocument.removeEventListener("pointerup", J, !1),
            !1 !== c.enabled && (c.dispatchEvent(u), (p = d.NONE));
      }
    }
    function K(e) {
      !1 === c.enabled ||
        !1 === c.enableZoom ||
        (p !== d.NONE && p !== d.ROTATE) ||
        (e.preventDefault(),
        e.stopPropagation(),
        c.dispatchEvent(h),
        (function (e) {
          e.deltaY < 0 ? U(R()) : e.deltaY > 0 && F(R()), c.update();
        })(e),
        c.dispatchEvent(u));
    }
    function Q(e) {
      !1 !== c.enabled &&
        !1 !== c.enableKeys &&
        !1 !== c.enablePan &&
        (function (e) {
          var t = !1;
          switch (e.keyCode) {
            case c.keys.UP:
              D(0, c.keyPanSpeed), (t = !0);
              break;
            case c.keys.BOTTOM:
              D(0, -c.keyPanSpeed), (t = !0);
              break;
            case c.keys.LEFT:
              D(c.keyPanSpeed, 0), (t = !0);
              break;
            case c.keys.RIGHT:
              D(-c.keyPanSpeed, 0), (t = !0);
          }
          t && (e.preventDefault(), c.update());
        })(e);
    }
    function $(e) {
      if (!1 !== c.enabled) {
        switch ((e.preventDefault(), e.touches.length)) {
          case 1:
            switch (c.touches.ONE) {
              case 0:
                if (!1 === c.enableRotate) return;
                z(e), (p = d.TOUCH_ROTATE);
                break;
              case 1:
                if (!1 === c.enablePan) return;
                H(e), (p = d.TOUCH_PAN);
                break;
              default:
                p = d.NONE;
            }
            break;
          case 2:
            switch (c.touches.TWO) {
              case 2:
                if (!1 === c.enableZoom && !1 === c.enablePan) return;
                !(function (e) {
                  c.enableZoom && G(e), c.enablePan && H(e);
                })(e),
                  (p = d.TOUCH_DOLLY_PAN);
                break;
              case 3:
                if (!1 === c.enableZoom && !1 === c.enableRotate) return;
                !(function (e) {
                  c.enableZoom && G(e), c.enableRotate && z(e);
                })(e),
                  (p = d.TOUCH_DOLLY_ROTATE);
                break;
              default:
                p = d.NONE;
            }
            break;
          default:
            p = d.NONE;
        }
        p !== d.NONE && c.dispatchEvent(h);
      }
    }
    function ee(e) {
      if (!1 !== c.enabled)
        switch ((e.preventDefault(), e.stopPropagation(), p)) {
          case d.TOUCH_ROTATE:
            if (!1 === c.enableRotate) return;
            V(e), c.update();
            break;
          case d.TOUCH_PAN:
            if (!1 === c.enablePan) return;
            X(e), c.update();
            break;
          case d.TOUCH_DOLLY_PAN:
            if (!1 === c.enableZoom && !1 === c.enablePan) return;
            !(function (e) {
              c.enableZoom && q(e), c.enablePan && X(e);
            })(e),
              c.update();
            break;
          case d.TOUCH_DOLLY_ROTATE:
            if (!1 === c.enableZoom && !1 === c.enableRotate) return;
            !(function (e) {
              c.enableZoom && q(e), c.enableRotate && V(e);
            })(e),
              c.update();
            break;
          default:
            p = d.NONE;
        }
    }
    function te(e) {
      !1 !== c.enabled && (c.dispatchEvent(u), (p = d.NONE));
    }
    function ne(e) {
      !1 !== c.enabled && e.preventDefault();
    }
    c.domElement.addEventListener("contextmenu", ne, !1),
      c.domElement.addEventListener("pointerdown", Y, !1),
      c.domElement.addEventListener("wheel", K, !1),
      c.domElement.addEventListener("touchstart", $, !1),
      c.domElement.addEventListener("touchend", te, !1),
      c.domElement.addEventListener("touchmove", ee, !1),
      c.domElement.addEventListener("keydown", Q, !1),
      this.update();
  };
  (ch.prototype = Object.create(C.prototype)).constructor = ch;
  var lh = function (e, t) {
    ch.call(this, e, t),
      (this.screenSpacePanning = !1),
      (this.mouseButtons.LEFT = 2),
      (this.mouseButtons.RIGHT = 0),
      (this.touches.ONE = 1),
      (this.touches.TWO = 3);
  };
  (lh.prototype = Object.create(C.prototype)).constructor = lh;
  const hh = new Ga("#b9d5ff", 0.3),
    uh = new Ha("#b9d5ff", 0.12);
  (uh.castShadow = !0),
    (uh.shadow.mapSize.width = 256),
    (uh.shadow.mapSize.height = 256),
    (uh.shadow.camera.far = 15),
    uh.position.set(4, 5, -2);
  const dh = new ka(new dt("red"), 5, 7);
  (dh.castShadow = !0),
    (dh.shadow.mapSize.width = 256),
    (dh.shadow.mapSize.height = 256),
    (dh.shadow.camera.far = 7),
    dh.position.set(0, 2.2, 2.7);
  const ph = new ka(new dt("orange"), 1, 7);
  (ph.castShadow = !0),
    (ph.shadow.mapSize.width = 256),
    (ph.shadow.mapSize.height = 256),
    (ph.shadow.camera.far = 7),
    ph.position.set(6.5, 2.2, 2.7);
  const fh = new ka("#ff00ff", 3, 3);
  (fh.castShadow = !0),
    (fh.shadow.mapSize.width = 256),
    (fh.shadow.mapSize.height = 256),
    (fh.shadow.camera.far = 7);
  const mh = new ka("#00ffff", 3, 3);
  (mh.castShadow = !0),
    (mh.shadow.mapSize.width = 256),
    (mh.shadow.mapSize.height = 256),
    (mh.shadow.camera.far = 7);
  const gh = new ka("#ff7800", 3, 3);
  (gh.castShadow = !0),
    (gh.shadow.mapSize.width = 256),
    (gh.shadow.mapSize.height = 256),
    (gh.shadow.camera.far = 7);
  const vh = [
    {
      light: fh,
      getPosition: (e) => {
        const t = 0.5 * e;
        return [4 * Math.cos(t), 0.5 * Math.sin(3 * e) + 0.5, 4 * Math.sin(t)];
      },
    },
    {
      light: mh,
      getPosition: (e) => {
        const t = 0.32 * -e;
        return [
          5 * Math.cos(t),
          0.5 * Math.sin(4 * e) + Math.sin(2.5 * e) + 0.5,
          5 * Math.sin(t),
        ];
      },
    },
    {
      light: gh,
      getPosition: (e) => {
        const t = 0.18 * -e;
        return [
          Math.cos(t) * (7 + Math.sin(0.32 * e)),
          0.5 * Math.sin(4 * e) + Math.sin(2.5 * e) + 0.5,
          Math.sin(t) * (7 + Math.sin(0.5 * e)),
        ];
      },
    },
  ];
  var yh = (function () {
    function e(e) {
      ea.call(this, e),
        (this.dracoLoader = null),
        (this.ddsLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (e) {
          return new m(e);
        }),
        this.register(function (e) {
          return new v(e);
        }),
        this.register(function (e) {
          return new _(e);
        }),
        this.register(function (e) {
          return new g(e);
        }),
        this.register(function (e) {
          return new d(e);
        }),
        this.register(function (e) {
          return new b(e);
        });
    }
    function l() {
      var e = {};
      return {
        get: function (t) {
          return e[t];
        },
        add: function (t, n) {
          e[t] = n;
        },
        remove: function (t) {
          delete e[t];
        },
        removeAll: function () {
          e = {};
        },
      };
    }
    e.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: e,
      load: function (e, t, n, i) {
        var r,
          o = this;
        (r =
          "" !== this.resourcePath
            ? this.resourcePath
            : "" !== this.path
            ? this.path
            : Ya(e)),
          this.manager.itemStart(e);
        var s = function (t) {
            i ? i(t) : console.error(t),
              o.manager.itemError(e),
              o.manager.itemEnd(e);
          },
          a = new na(this.manager);
        a.setPath(this.path),
          a.setResponseType("arraybuffer"),
          a.setRequestHeader(this.requestHeader),
          a.setWithCredentials(this.withCredentials),
          a.load(
            e,
            function (n) {
              try {
                o.parse(
                  n,
                  r,
                  function (n) {
                    t(n), o.manager.itemEnd(e);
                  },
                  s
                );
              } catch (e) {
                s(e);
              }
            },
            n,
            s
          );
      },
      setDRACOLoader: function (e) {
        return (this.dracoLoader = e), this;
      },
      setDDSLoader: function (e) {
        return (this.ddsLoader = e), this;
      },
      setKTX2Loader: function (e) {
        return (this.ktx2Loader = e), this;
      },
      setMeshoptDecoder: function (e) {
        return (this.meshoptDecoder = e), this;
      },
      register: function (e) {
        return (
          -1 === this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.push(e),
          this
        );
      },
      unregister: function (e) {
        return (
          -1 !== this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
          this
        );
      },
      parse: function (e, t, n, i) {
        var r,
          o = {},
          s = {};
        if ("string" == typeof e) r = e;
        else if (qa(new Uint8Array(e, 0, 4)) === w) {
          try {
            o[h.KHR_BINARY_GLTF] = new M(e);
          } catch (e) {
            return void (i && i(e));
          }
          r = o[h.KHR_BINARY_GLTF].content;
        } else r = qa(new Uint8Array(e));
        var a = JSON.parse(r);
        if (void 0 === a.asset || a.asset.version[0] < 2)
          i &&
            i(
              new Error(
                "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
              )
            );
        else {
          var c = new X(a, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (var l = 0; l < this.pluginCallbacks.length; l++) {
            var d = this.pluginCallbacks[l](c);
            (s[d.name] = d), (o[d.name] = !0);
          }
          if (a.extensionsUsed)
            for (l = 0; l < a.extensionsUsed.length; ++l) {
              var f = a.extensionsUsed[l],
                m = a.extensionsRequired || [];
              switch (f) {
                case h.KHR_MATERIALS_UNLIT:
                  o[f] = new p();
                  break;
                case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  o[f] = new L();
                  break;
                case h.KHR_DRACO_MESH_COMPRESSION:
                  o[f] = new S(a, this.dracoLoader);
                  break;
                case h.MSFT_TEXTURE_DDS:
                  o[f] = new u(this.ddsLoader);
                  break;
                case h.KHR_TEXTURE_TRANSFORM:
                  o[f] = new T();
                  break;
                case h.KHR_MESH_QUANTIZATION:
                  o[f] = new R();
                  break;
                default:
                  m.indexOf(f) >= 0 &&
                    void 0 === s[f] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + f + '".'
                    );
              }
            }
          c.setExtensions(o), c.setPlugins(s), c.parse(n, i);
        }
      },
    });
    var h = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
        "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      MSFT_TEXTURE_DDS: "MSFT_texture_dds",
    };
    function u(e) {
      if (!e)
        throw new Error(
          "THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"
        );
      (this.name = h.MSFT_TEXTURE_DDS), (this.ddsLoader = e);
    }
    function d(e) {
      (this.parser = e),
        (this.name = h.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    function p() {
      this.name = h.KHR_MATERIALS_UNLIT;
    }
    function m(e) {
      (this.parser = e), (this.name = h.KHR_MATERIALS_CLEARCOAT);
    }
    function g(e) {
      (this.parser = e), (this.name = h.KHR_MATERIALS_TRANSMISSION);
    }
    function v(e) {
      (this.parser = e), (this.name = h.KHR_TEXTURE_BASISU);
    }
    function _(e) {
      (this.parser = e),
        (this.name = h.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    function b(e) {
      (this.name = h.EXT_MESHOPT_COMPRESSION), (this.parser = e);
    }
    (d.prototype._markDefs = function () {
      for (
        var e = this.parser,
          t = this.parser.json.nodes || [],
          n = 0,
          i = t.length;
        n < i;
        n++
      ) {
        var r = t[n];
        r.extensions &&
          r.extensions[this.name] &&
          void 0 !== r.extensions[this.name].light &&
          e._addNodeRef(this.cache, r.extensions[this.name].light);
      }
    }),
      (d.prototype._loadLight = function (e) {
        var t = this.parser,
          n = "light:" + e,
          i = t.cache.get(n);
        if (i) return i;
        var r,
          o = t.json,
          s = (((o.extensions && o.extensions[this.name]) || {}).lights || [])[
            e
          ],
          a = new dt(16777215);
        void 0 !== s.color && a.fromArray(s.color);
        var c = void 0 !== s.range ? s.range : 0;
        switch (s.type) {
          case "directional":
            (r = new Ha(a)).target.position.set(0, 0, -1), r.add(r.target);
            break;
          case "point":
            (r = new ka(a)).distance = c;
            break;
          case "spot":
            ((r = new Fa(a)).distance = c),
              (s.spot = s.spot || {}),
              (s.spot.innerConeAngle =
                void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
              (s.spot.outerConeAngle =
                void 0 !== s.spot.outerConeAngle
                  ? s.spot.outerConeAngle
                  : Math.PI / 4),
              (r.angle = s.spot.outerConeAngle),
              (r.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
              r.target.position.set(0, 0, -1),
              r.add(r.target);
            break;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unexpected light type: " + s.type
            );
        }
        return (
          r.position.set(0, 0, 0),
          (r.decay = 2),
          void 0 !== s.intensity && (r.intensity = s.intensity),
          (r.name = t.createUniqueName(s.name || "light_" + e)),
          (i = Promise.resolve(r)),
          t.cache.add(n, i),
          i
        );
      }),
      (d.prototype.createNodeAttachment = function (e) {
        var t = this,
          n = this.parser,
          i = n.json.nodes[e],
          r = ((i.extensions && i.extensions[this.name]) || {}).light;
        return void 0 === r
          ? null
          : this._loadLight(r).then(function (e) {
              return n._getNodeRef(t.cache, r, e);
            });
      }),
      (p.prototype.getMaterialType = function () {
        return gt;
      }),
      (p.prototype.extendParams = function (e, t, n) {
        var i = [];
        (e.color = new dt(1, 1, 1)), (e.opacity = 1);
        var r = t.pbrMetallicRoughness;
        if (r) {
          if (Array.isArray(r.baseColorFactor)) {
            var o = r.baseColorFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          void 0 !== r.baseColorTexture &&
            i.push(n.assignTexture(e, "map", r.baseColorTexture));
        }
        return Promise.all(i);
      }),
      (m.prototype.getMaterialType = function (e) {
        var t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Ls : null;
      }),
      (m.prototype.extendMaterialParams = function (e, t) {
        var n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        var r = [],
          o = i.extensions[this.name];
        if (
          (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
          void 0 !== o.clearcoatTexture &&
            r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
          void 0 !== o.clearcoatRoughnessFactor &&
            (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
          void 0 !== o.clearcoatRoughnessTexture &&
            r.push(
              n.assignTexture(
                t,
                "clearcoatRoughnessMap",
                o.clearcoatRoughnessTexture
              )
            ),
          void 0 !== o.clearcoatNormalTexture &&
            (r.push(
              n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
            ),
            void 0 !== o.clearcoatNormalTexture.scale))
        ) {
          var s = o.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new N(s, s);
        }
        return Promise.all(r);
      }),
      (g.prototype.getMaterialType = function (e) {
        var t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Ls : null;
      }),
      (g.prototype.extendMaterialParams = function (e, t) {
        var n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        var r = [],
          o = i.extensions[this.name];
        return (
          void 0 !== o.transmissionFactor &&
            (t.transmission = o.transmissionFactor),
          void 0 !== o.transmissionTexture &&
            r.push(
              n.assignTexture(t, "transmissionMap", o.transmissionTexture)
            ),
          Promise.all(r)
        );
      }),
      (v.prototype.loadTexture = function (e) {
        var t = this.parser,
          n = t.json,
          i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name]) return null;
        var r = i.extensions[this.name],
          o = n.images[r.source],
          s = t.options.ktx2Loader;
        if (!s) {
          if (
            n.extensionsRequired &&
            n.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
            );
          return null;
        }
        return t.loadTextureImage(e, o, s);
      }),
      (_.prototype.loadTexture = function (e) {
        var t = this.name,
          n = this.parser,
          i = n.json,
          r = i.textures[e];
        if (!r.extensions || !r.extensions[t]) return null;
        var o = r.extensions[t],
          s = i.images[o.source],
          a = s.uri ? n.options.manager.getHandler(s.uri) : n.textureLoader;
        return this.detectSupport().then(function (r) {
          if (r) return n.loadTextureImage(e, s, a);
          if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
            throw new Error(
              "THREE.GLTFLoader: WebP required by asset but unsupported."
            );
          return n.loadTexture(e);
        });
      }),
      (_.prototype.detectSupport = function () {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              var t = new Image();
              (t.src =
                "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                (t.onload = t.onerror =
                  function () {
                    e(1 === t.height);
                  });
            })),
          this.isSupported
        );
      }),
      (b.prototype.loadBufferView = function (e) {
        var t = this.parser.json,
          n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
          var i = n.extensions[this.name],
            r = this.parser.getDependency("buffer", i.buffer),
            o = this.parser.options.meshoptDecoder;
          if (!o || !o.supported) {
            if (
              t.extensionsRequired &&
              t.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
              );
            return null;
          }
          return Promise.all([r, o.ready]).then(function (e) {
            var t = i.byteOffset || 0,
              n = i.byteLength || 0,
              r = i.count,
              s = i.byteStride,
              a = new ArrayBuffer(r * s),
              c = new Uint8Array(e[0], t, n);
            return (
              o.decodeGltfBuffer(new Uint8Array(a), r, s, c, i.mode, i.filter),
              a
            );
          });
        }
        return null;
      });
    var w = "glTF";
    function M(e) {
      (this.name = h.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      var t = new DataView(e, 0, 12);
      if (
        ((this.header = {
          magic: qa(new Uint8Array(e.slice(0, 4))),
          version: t.getUint32(4, !0),
          length: t.getUint32(8, !0),
        }),
        this.header.magic !== w)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      for (var n = new DataView(e, 12), i = 0; i < n.byteLength; ) {
        var r = n.getUint32(i, !0);
        i += 4;
        var o = n.getUint32(i, !0);
        if (((i += 4), 1313821514 === o)) {
          var s = new Uint8Array(e, 12 + i, r);
          this.content = qa(s);
        } else if (5130562 === o) {
          var a = 12 + i;
          this.body = e.slice(a, a + r);
        }
        i += r;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
    function S(e, t) {
      if (!t)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = h.KHR_DRACO_MESH_COMPRESSION),
        (this.json = e),
        (this.dracoLoader = t),
        this.dracoLoader.preload();
    }
    function T() {
      this.name = h.KHR_TEXTURE_TRANSFORM;
    }
    function A(e) {
      As.call(this), (this.isGLTFSpecularGlossinessMaterial = !0);
      var t = [
          "#ifdef USE_SPECULARMAP",
          "\tuniform sampler2D specularMap;",
          "#endif",
        ].join("\n"),
        n = [
          "#ifdef USE_GLOSSINESSMAP",
          "\tuniform sampler2D glossinessMap;",
          "#endif",
        ].join("\n"),
        i = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
          "\ttexelSpecular = sRGBToLinear( texelSpecular );",
          "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tspecularFactor *= texelSpecular.rgb;",
          "#endif",
        ].join("\n"),
        r = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tglossinessFactor *= texelGlossiness.a;",
          "#endif",
        ].join("\n"),
        o = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.specularRoughness += geometryRoughness;",
          "material.specularRoughness = min( material.specularRoughness, 1.0 );",
          "material.specularColor = specularFactor;",
        ].join("\n"),
        s = {
          specular: { value: new dt().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null },
        };
      (this._extraUniforms = s),
        (this.onBeforeCompile = function (e) {
          for (var a in s) e.uniforms[a] = s[a];
          e.fragmentShader = e.fragmentShader
            .replace("uniform float roughness;", "uniform vec3 specular;")
            .replace("uniform float metalness;", "uniform float glossiness;")
            .replace("#include <roughnessmap_pars_fragment>", t)
            .replace("#include <metalnessmap_pars_fragment>", n)
            .replace("#include <roughnessmap_fragment>", i)
            .replace("#include <metalnessmap_fragment>", r)
            .replace("#include <lights_physical_fragment>", o);
        }),
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return s.specular.value;
            },
            set: function (e) {
              s.specular.value = e;
            },
          },
          specularMap: {
            get: function () {
              return s.specularMap.value;
            },
            set: function (e) {
              (s.specularMap.value = e),
                e
                  ? (this.defines.USE_SPECULARMAP = "")
                  : delete this.defines.USE_SPECULARMAP;
            },
          },
          glossiness: {
            get: function () {
              return s.glossiness.value;
            },
            set: function (e) {
              s.glossiness.value = e;
            },
          },
          glossinessMap: {
            get: function () {
              return s.glossinessMap.value;
            },
            set: function (e) {
              (s.glossinessMap.value = e),
                e
                  ? ((this.defines.USE_GLOSSINESSMAP = ""),
                    (this.defines.USE_UV = ""))
                  : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV);
            },
          },
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e);
    }
    function L() {
      return {
        name: h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        specularGlossinessParams: [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
          "refractionRatio",
        ],
        getMaterialType: function () {
          return A;
        },
        extendParams: function (e, t, n) {
          var i = t.extensions[this.name];
          (e.color = new dt(1, 1, 1)), (e.opacity = 1);
          var r = [];
          if (Array.isArray(i.diffuseFactor)) {
            var o = i.diffuseFactor;
            e.color.fromArray(o), (e.opacity = o[3]);
          }
          if (
            (void 0 !== i.diffuseTexture &&
              r.push(n.assignTexture(e, "map", i.diffuseTexture)),
            (e.emissive = new dt(0, 0, 0)),
            (e.glossiness =
              void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
            (e.specular = new dt(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              e.specular.fromArray(i.specularFactor),
            void 0 !== i.specularGlossinessTexture)
          ) {
            var s = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", s)),
              r.push(n.assignTexture(e, "specularMap", s));
          }
          return Promise.all(r);
        },
        createMaterial: function (e) {
          var t = new A(e);
          return (
            (t.fog = !0),
            (t.color = e.color),
            (t.map = void 0 === e.map ? null : e.map),
            (t.lightMap = null),
            (t.lightMapIntensity = 1),
            (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
            (t.aoMapIntensity = 1),
            (t.emissive = e.emissive),
            (t.emissiveIntensity = 1),
            (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
            (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
            (t.bumpScale = 1),
            (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
            (t.normalMapType = 0),
            e.normalScale && (t.normalScale = e.normalScale),
            (t.displacementMap = null),
            (t.displacementScale = 1),
            (t.displacementBias = 0),
            (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
            (t.specular = e.specular),
            (t.glossinessMap =
              void 0 === e.glossinessMap ? null : e.glossinessMap),
            (t.glossiness = e.glossiness),
            (t.alphaMap = null),
            (t.envMap = void 0 === e.envMap ? null : e.envMap),
            (t.envMapIntensity = 1),
            (t.refractionRatio = 0.98),
            t
          );
        },
      };
    }
    function R() {
      this.name = h.KHR_MESH_QUANTIZATION;
    }
    function C(e, t, n, i) {
      Us.call(this, e, t, n, i);
    }
    (S.prototype.decodePrimitive = function (e, t) {
      var n = this.json,
        i = this.dracoLoader,
        r = e.extensions[this.name].bufferView,
        o = e.extensions[this.name].attributes,
        s = {},
        a = {},
        c = {};
      for (var l in o) {
        var h = U[l] || l.toLowerCase();
        s[h] = o[l];
      }
      for (l in e.attributes)
        if (((h = U[l] || l.toLowerCase()), void 0 !== o[l])) {
          var u = n.accessors[e.attributes[l]],
            d = P[u.componentType];
          (c[h] = d), (a[h] = !0 === u.normalized);
        }
      return t.getDependency("bufferView", r).then(function (e) {
        return new Promise(function (t) {
          i.decodeDracoFile(
            e,
            function (e) {
              for (var n in e.attributes) {
                var i = e.attributes[n],
                  r = a[n];
                void 0 !== r && (i.normalized = r);
              }
              t(e);
            },
            s,
            c
          );
        });
      });
    }),
      (T.prototype.extendTexture = function (e, t) {
        return (
          (e = e.clone()),
          void 0 !== t.offset && e.offset.fromArray(t.offset),
          void 0 !== t.rotation && (e.rotation = t.rotation),
          void 0 !== t.scale && e.repeat.fromArray(t.scale),
          void 0 !== t.texCoord &&
            console.warn(
              'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
            ),
          (e.needsUpdate = !0),
          e
        );
      }),
      (A.prototype = Object.create(As.prototype)),
      (A.prototype.constructor = A),
      (A.prototype.copy = function (e) {
        return (
          As.prototype.copy.call(this, e),
          (this.specularMap = e.specularMap),
          this.specular.copy(e.specular),
          (this.glossinessMap = e.glossinessMap),
          (this.glossiness = e.glossiness),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this
        );
      }),
      (C.prototype = Object.create(Us.prototype)),
      (C.prototype.constructor = C),
      (C.prototype.copySampleValue_ = function (e) {
        for (
          var t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i,
            o = 0;
          o !== i;
          o++
        )
          t[o] = n[r + o];
        return t;
      }),
      (C.prototype.beforeStart_ = C.prototype.copySampleValue_),
      (C.prototype.afterEnd_ = C.prototype.copySampleValue_),
      (C.prototype.interpolate_ = function (e, t, n, i) {
        for (
          var r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = 2 * s,
            c = 3 * s,
            l = i - t,
            h = (n - t) / l,
            u = h * h,
            d = u * h,
            p = e * c,
            f = p - c,
            m = -2 * d + 3 * u,
            g = d - u,
            v = 1 - m,
            y = g - u + h,
            x = 0;
          x !== s;
          x++
        ) {
          var _ = o[f + x + s],
            b = o[f + x + a] * l,
            w = o[p + x + s],
            M = o[p + x] * l;
          r[x] = v * _ + y * b + m * w + g * M;
        }
        return r;
      });
    var P = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      },
      O = { 9728: r, 9729: a, 9984: o, 9985: 1007, 9986: s, 9987: c },
      D = { 33071: n, 33648: i, 10497: t },
      F = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
      U = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex",
      },
      k = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences",
      },
      B = { CUBICSPLINE: void 0, LINEAR: x, STEP: y };
    function z(e, t) {
      return "string" != typeof e || "" === e
        ? ""
        : (/^https?:\/\//i.test(t) &&
            /^\//.test(e) &&
            (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }
    function H(e, t, n) {
      for (var i in n.extensions)
        void 0 === e[i] &&
          ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
          (t.userData.gltfExtensions[i] = n.extensions[i]));
    }
    function G(e, t) {
      void 0 !== t.extras &&
        ("object" == typeof t.extras
          ? Object.assign(e.userData, t.extras)
          : console.warn(
              "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
            ));
    }
    function V(e, t) {
      if ((e.updateMorphTargets(), void 0 !== t.weights))
        for (var n = 0, i = t.weights.length; n < i; n++)
          e.morphTargetInfluences[n] = t.weights[n];
      if (t.extras && Array.isArray(t.extras.targetNames)) {
        var r = t.extras.targetNames;
        if (e.morphTargetInfluences.length === r.length)
          for (e.morphTargetDictionary = {}, n = 0, i = r.length; n < i; n++)
            e.morphTargetDictionary[r[n]] = n;
        else
          console.warn(
            "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
          );
      }
    }
    function j(e) {
      for (
        var t = "", n = Object.keys(e).sort(), i = 0, r = n.length;
        i < r;
        i++
      )
        t += n[i] + ":" + e[n[i]] + ";";
      return t;
    }
    function X(e, t) {
      (this.json = e || {}),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = t || {}),
        (this.cache = new l()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.nodeNamesUsed = {}),
        "undefined" != typeof createImageBitmap &&
        !1 === /Firefox/.test(navigator.userAgent)
          ? (this.textureLoader = new Qa(this.options.manager))
          : (this.textureLoader = new ca(this.options.manager)),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        (this.fileLoader = new na(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    function q(e, t, n) {
      var i = t.attributes,
        r = [];
      function o(t, i) {
        return n.getDependency("accessor", t).then(function (t) {
          e.setAttribute(i, t);
        });
      }
      for (var s in i) {
        var a = U[s] || s.toLowerCase();
        a in e.attributes || r.push(o(i[s], a));
      }
      if (void 0 !== t.indices && !e.index) {
        var c = n.getDependency("accessor", t.indices).then(function (t) {
          e.setIndex(t);
        });
        r.push(c);
      }
      return (
        G(e, t),
        (function (e, t, n) {
          var i = t.attributes,
            r = new Y();
          if (void 0 !== i.POSITION) {
            var o = (d = n.json.accessors[i.POSITION]).min,
              s = d.max;
            if (void 0 !== o && void 0 !== s) {
              r.set(new W(o[0], o[1], o[2]), new W(s[0], s[1], s[2]));
              var a = t.targets;
              if (void 0 !== a) {
                for (
                  var c = new W(), l = new W(), h = 0, u = a.length;
                  h < u;
                  h++
                ) {
                  var d,
                    p = a[h];
                  void 0 !== p.POSITION &&
                    ((o = (d = n.json.accessors[p.POSITION]).min),
                    (s = d.max),
                    void 0 !== o && void 0 !== s
                      ? (l.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                        l.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                        l.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                        c.max(l))
                      : console.warn(
                          "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                        ));
                }
                r.expandByVector(c);
              }
              e.boundingBox = r;
              var f = new he();
              r.getCenter(f.center),
                (f.radius = r.min.distanceTo(r.max) / 2),
                (e.boundingSphere = f);
            } else
              console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
          }
        })(e, t, n),
        Promise.all(r).then(function () {
          return void 0 !== t.targets
            ? (function (e, t, n) {
                for (
                  var i = !1, r = !1, o = 0, s = t.length;
                  o < s &&
                  (void 0 !== (l = t[o]).POSITION && (i = !0),
                  void 0 !== l.NORMAL && (r = !0),
                  !i || !r);
                  o++
                );
                if (!i && !r) return Promise.resolve(e);
                var a = [],
                  c = [];
                for (o = 0, s = t.length; o < s; o++) {
                  var l = t[o];
                  if (i) {
                    var h =
                      void 0 !== l.POSITION
                        ? n.getDependency("accessor", l.POSITION)
                        : e.attributes.position;
                    a.push(h);
                  }
                  r &&
                    ((h =
                      void 0 !== l.NORMAL
                        ? n.getDependency("accessor", l.NORMAL)
                        : e.attributes.normal),
                    c.push(h));
                }
                return Promise.all([Promise.all(a), Promise.all(c)]).then(
                  function (t) {
                    var n = t[0],
                      o = t[1];
                    return (
                      i && (e.morphAttributes.position = n),
                      r && (e.morphAttributes.normal = o),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  }
                );
              })(e, t.targets, n)
            : e;
        })
      );
    }
    function Z(e, t) {
      var n = e.getIndex();
      if (null === n) {
        var i = [],
          r = e.getAttribute("position");
        if (void 0 === r)
          return (
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            e
          );
        for (var o = 0; o < r.count; o++) i.push(o);
        e.setIndex(i), (n = e.getIndex());
      }
      var s = n.count - 2,
        a = [];
      if (2 === t)
        for (o = 1; o <= s; o++)
          a.push(n.getX(0)), a.push(n.getX(o)), a.push(n.getX(o + 1));
      else
        for (o = 0; o < s; o++)
          o % 2 == 0
            ? (a.push(n.getX(o)), a.push(n.getX(o + 1)), a.push(n.getX(o + 2)))
            : (a.push(n.getX(o + 2)), a.push(n.getX(o + 1)), a.push(n.getX(o)));
      a.length / 3 !== s &&
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      var c = e.clone();
      return c.setIndex(a), c;
    }
    return (
      (X.prototype.setExtensions = function (e) {
        this.extensions = e;
      }),
      (X.prototype.setPlugins = function (e) {
        this.plugins = e;
      }),
      (X.prototype.parse = function (e, t) {
        var n = this,
          i = this.json,
          r = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (e) {
            return e._markDefs && e._markDefs();
          }),
          Promise.all([
            this.getDependencies("scene"),
            this.getDependencies("animation"),
            this.getDependencies("camera"),
          ])
            .then(function (t) {
              var o = {
                scene: t[0][i.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: i.asset,
                parser: n,
                userData: {},
              };
              H(r, o, i), G(o, i), e(o);
            })
            .catch(t);
      }),
      (X.prototype._markDefs = function () {
        for (
          var e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [],
            i = 0,
            r = t.length;
          i < r;
          i++
        )
          for (var o = t[i].joints, s = 0, a = o.length; s < a; s++)
            e[o[s]].isBone = !0;
        for (var c = 0, l = e.length; c < l; c++) {
          var h = e[c];
          void 0 !== h.mesh &&
            (this._addNodeRef(this.meshCache, h.mesh),
            void 0 !== h.skin && (n[h.mesh].isSkinnedMesh = !0)),
            void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera);
        }
      }),
      (X.prototype._addNodeRef = function (e, t) {
        void 0 !== t &&
          (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }),
      (X.prototype._getNodeRef = function (e, t, n) {
        if (e.refs[t] <= 1) return n;
        var i = n.clone();
        return (i.name += "_instance_" + e.uses[t]++), i;
      }),
      (X.prototype._invokeOne = function (e) {
        var t = Object.values(this.plugins);
        t.push(this);
        for (var n = 0; n < t.length; n++) {
          var i = e(t[n]);
          if (i) return i;
        }
      }),
      (X.prototype._invokeAll = function (e) {
        var t = Object.values(this.plugins);
        t.unshift(this);
        for (var n = [], i = 0; i < t.length; i++) {
          var r = e(t[i]);
          r && n.push(r);
        }
        return n;
      }),
      (X.prototype.getDependency = function (e, t) {
        var n = e + ":" + t,
          i = this.cache.get(n);
        if (!i) {
          switch (e) {
            case "scene":
              i = this.loadScene(t);
              break;
            case "node":
              i = this.loadNode(t);
              break;
            case "mesh":
              i = this._invokeOne(function (e) {
                return e.loadMesh && e.loadMesh(t);
              });
              break;
            case "accessor":
              i = this.loadAccessor(t);
              break;
            case "bufferView":
              i = this._invokeOne(function (e) {
                return e.loadBufferView && e.loadBufferView(t);
              });
              break;
            case "buffer":
              i = this.loadBuffer(t);
              break;
            case "material":
              i = this._invokeOne(function (e) {
                return e.loadMaterial && e.loadMaterial(t);
              });
              break;
            case "texture":
              i = this._invokeOne(function (e) {
                return e.loadTexture && e.loadTexture(t);
              });
              break;
            case "skin":
              i = this.loadSkin(t);
              break;
            case "animation":
              i = this.loadAnimation(t);
              break;
            case "camera":
              i = this.loadCamera(t);
              break;
            default:
              throw new Error("Unknown type: " + e);
          }
          this.cache.add(n, i);
        }
        return i;
      }),
      (X.prototype.getDependencies = function (e) {
        var t = this.cache.get(e);
        if (!t) {
          var n = this,
            i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
          (t = Promise.all(
            i.map(function (t, i) {
              return n.getDependency(e, i);
            })
          )),
            this.cache.add(e, t);
        }
        return t;
      }),
      (X.prototype.loadBuffer = function (e) {
        var t = this.json.buffers[e],
          n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
          throw new Error(
            "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
          );
        if (void 0 === t.uri && 0 === e)
          return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);
        var i = this.options;
        return new Promise(function (e, r) {
          n.load(z(t.uri, i.path), e, void 0, function () {
            r(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
              )
            );
          });
        });
      }),
      (X.prototype.loadBufferView = function (e) {
        var t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (e) {
          var n = t.byteLength || 0,
            i = t.byteOffset || 0;
          return e.slice(i, i + n);
        });
      }),
      (X.prototype.loadAccessor = function (e) {
        var t = this,
          n = this.json,
          i = this.json.accessors[e];
        if (void 0 === i.bufferView && void 0 === i.sparse)
          return Promise.resolve(null);
        var r = [];
        return (
          void 0 !== i.bufferView
            ? r.push(this.getDependency("bufferView", i.bufferView))
            : r.push(null),
          void 0 !== i.sparse &&
            (r.push(
              this.getDependency("bufferView", i.sparse.indices.bufferView)
            ),
            r.push(
              this.getDependency("bufferView", i.sparse.values.bufferView)
            )),
          Promise.all(r).then(function (e) {
            var r,
              o = e[0],
              s = F[i.type],
              a = P[i.componentType],
              c = a.BYTES_PER_ELEMENT,
              l = c * s,
              h = i.byteOffset || 0,
              u =
                void 0 !== i.bufferView
                  ? n.bufferViews[i.bufferView].byteStride
                  : void 0,
              d = !0 === i.normalized;
            if (u && u !== l) {
              var p = Math.floor(h / u),
                f =
                  "InterleavedBuffer:" +
                  i.bufferView +
                  ":" +
                  i.componentType +
                  ":" +
                  p +
                  ":" +
                  i.count,
                m = t.cache.get(f);
              m ||
                ((m = new Nr(new a(o, p * u, (i.count * u) / c), u / c)),
                t.cache.add(f, m)),
                (r = new Fr(m, s, (h % u) / c, d));
            } else r = new xt(null === o ? new a(i.count * s) : new a(o, h, i.count * s), s, d);
            if (void 0 !== i.sparse) {
              var g = F.SCALAR,
                v = P[i.sparse.indices.componentType],
                y = i.sparse.indices.byteOffset || 0,
                x = i.sparse.values.byteOffset || 0,
                _ = new v(e[1], y, i.sparse.count * g),
                b = new a(e[2], x, i.sparse.count * s);
              null !== o &&
                (r = new xt(r.array.slice(), r.itemSize, r.normalized));
              for (var w = 0, M = _.length; w < M; w++) {
                var S = _[w];
                if (
                  (r.setX(S, b[w * s]),
                  s >= 2 && r.setY(S, b[w * s + 1]),
                  s >= 3 && r.setZ(S, b[w * s + 2]),
                  s >= 4 && r.setW(S, b[w * s + 3]),
                  s >= 5)
                )
                  throw new Error(
                    "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                  );
              }
            }
            return r;
          })
        );
      }),
      (X.prototype.loadTexture = function (e) {
        var t,
          n,
          i = this.json,
          r = this.options,
          o = i.textures[e],
          s = o.extensions || {};
        return (
          (t = s[h.MSFT_TEXTURE_DDS]
            ? i.images[s[h.MSFT_TEXTURE_DDS].source]
            : i.images[o.source]).uri && (n = r.manager.getHandler(t.uri)),
          n ||
            (n = s[h.MSFT_TEXTURE_DDS]
              ? this.extensions[h.MSFT_TEXTURE_DDS].ddsLoader
              : this.textureLoader),
          this.loadTextureImage(e, t, n)
        );
      }),
      (X.prototype.loadTextureImage = function (e, n, i) {
        var r = this,
          o = this.json,
          s = this.options,
          l = o.textures[e],
          h = self.URL || self.webkitURL,
          u = n.uri,
          d = !1,
          p = !0;
        return (
          "image/jpeg" === n.mimeType && (p = !1),
          void 0 !== n.bufferView &&
            (u = r.getDependency("bufferView", n.bufferView).then(function (e) {
              if ("image/png" === n.mimeType) {
                var t = new DataView(e, 25, 1).getUint8(0, !1);
                p = 6 === t || 4 === t || 3 === t;
              }
              d = !0;
              var i = new Blob([e], { type: n.mimeType });
              return (u = h.createObjectURL(i));
            })),
          Promise.resolve(u)
            .then(function (e) {
              return new Promise(function (t, n) {
                var r = t;
                !0 === i.isImageBitmapLoader &&
                  (r = function (e) {
                    t(new ko(e));
                  }),
                  i.load(z(e, s.path), r, void 0, n);
              });
            })
            .then(function (n) {
              !0 === d && h.revokeObjectURL(u),
                (n.flipY = !1),
                l.name && (n.name = l.name),
                p || (n.format = f);
              var i = (o.samplers || {})[l.sampler] || {};
              return (
                (n.magFilter = O[i.magFilter] || a),
                (n.minFilter = O[i.minFilter] || c),
                (n.wrapS = D[i.wrapS] || t),
                (n.wrapT = D[i.wrapT] || t),
                r.associations.set(n, { type: "textures", index: e }),
                n
              );
            })
        );
      }),
      (X.prototype.assignTexture = function (e, t, n) {
        var i = this;
        return this.getDependency("texture", n.index).then(function (r) {
          if (
            (void 0 === n.texCoord ||
              0 == n.texCoord ||
              ("aoMap" === t && 1 == n.texCoord) ||
              console.warn(
                "THREE.GLTFLoader: Custom UV set " +
                  n.texCoord +
                  " for texture " +
                  t +
                  " not yet supported."
              ),
            i.extensions[h.KHR_TEXTURE_TRANSFORM])
          ) {
            var o =
              void 0 !== n.extensions
                ? n.extensions[h.KHR_TEXTURE_TRANSFORM]
                : void 0;
            if (o) {
              var s = i.associations.get(r);
              (r = i.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(r, o)),
                i.associations.set(r, s);
            }
          }
          e[t] = r;
        });
      }),
      (X.prototype.assignFinalMaterial = function (e) {
        var t = e.geometry,
          n = e.material,
          i = void 0 !== t.attributes.tangent,
          r = void 0 !== t.attributes.color,
          o = void 0 === t.attributes.normal,
          s = !0 === e.isSkinnedMesh,
          a = Object.keys(t.morphAttributes).length > 0,
          c = a && void 0 !== t.morphAttributes.normal;
        if (e.isPoints) {
          var l = "PointsMaterial:" + n.uuid,
            h = this.cache.get(l);
          h ||
            ((h = new Ro()),
            mt.prototype.copy.call(h, n),
            h.color.copy(n.color),
            (h.map = n.map),
            (h.sizeAttenuation = !1),
            this.cache.add(l, h)),
            (n = h);
        } else if (e.isLine) {
          l = "LineBasicMaterial:" + n.uuid;
          var u = this.cache.get(l);
          u ||
            ((u = new yo()),
            mt.prototype.copy.call(u, n),
            u.color.copy(n.color),
            this.cache.add(l, u)),
            (n = u);
        }
        if (i || r || o || s || a) {
          (l = "ClonedMaterial:" + n.uuid + ":"),
            n.isGLTFSpecularGlossinessMaterial && (l += "specular-glossiness:"),
            s && (l += "skinning:"),
            i && (l += "vertex-tangents:"),
            r && (l += "vertex-colors:"),
            o && (l += "flat-shading:"),
            a && (l += "morph-targets:"),
            c && (l += "morph-normals:");
          var d = this.cache.get(l);
          d ||
            ((d = n.clone()),
            s && (d.skinning = !0),
            i && (d.vertexTangents = !0),
            r && (d.vertexColors = !0),
            o && (d.flatShading = !0),
            a && (d.morphTargets = !0),
            c && (d.morphNormals = !0),
            this.cache.add(l, d),
            this.associations.set(d, this.associations.get(n))),
            (n = d);
        }
        n.aoMap &&
          void 0 === t.attributes.uv2 &&
          void 0 !== t.attributes.uv &&
          t.setAttribute("uv2", t.attributes.uv),
          n.normalScale && !i && (n.normalScale.y = -n.normalScale.y),
          n.clearcoatNormalScale &&
            !i &&
            (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y),
          (e.material = n);
      }),
      (X.prototype.getMaterialType = function () {
        return As;
      }),
      (X.prototype.loadMaterial = function (e) {
        var t,
          n = this,
          i = this.json,
          r = this.extensions,
          o = i.materials[e],
          s = {},
          a = o.extensions || {},
          c = [];
        if (a[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          var l = r[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          (t = l.getMaterialType()), c.push(l.extendParams(s, o, n));
        } else if (a[h.KHR_MATERIALS_UNLIT]) {
          var u = r[h.KHR_MATERIALS_UNLIT];
          (t = u.getMaterialType()), c.push(u.extendParams(s, o, n));
        } else {
          var d = o.pbrMetallicRoughness || {};
          if (
            ((s.color = new dt(1, 1, 1)),
            (s.opacity = 1),
            Array.isArray(d.baseColorFactor))
          ) {
            var p = d.baseColorFactor;
            s.color.fromArray(p), (s.opacity = p[3]);
          }
          void 0 !== d.baseColorTexture &&
            c.push(n.assignTexture(s, "map", d.baseColorTexture)),
            (s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1),
            (s.roughness =
              void 0 !== d.roughnessFactor ? d.roughnessFactor : 1),
            void 0 !== d.metallicRoughnessTexture &&
              (c.push(
                n.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)
              ),
              c.push(
                n.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture)
              )),
            (t = this._invokeOne(function (t) {
              return t.getMaterialType && t.getMaterialType(e);
            })),
            c.push(
              Promise.all(
                this._invokeAll(function (t) {
                  return t.extendMaterialParams && t.extendMaterialParams(e, s);
                })
              )
            );
        }
        !0 === o.doubleSided && (s.side = 2);
        var f = o.alphaMode || "OPAQUE";
        return (
          "BLEND" === f
            ? ((s.transparent = !0), (s.depthWrite = !1))
            : ((s.transparent = !1),
              "MASK" === f &&
                (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : 0.5)),
          void 0 !== o.normalTexture &&
            t !== gt &&
            (c.push(n.assignTexture(s, "normalMap", o.normalTexture)),
            (s.normalScale = new N(1, 1)),
            void 0 !== o.normalTexture.scale &&
              s.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)),
          void 0 !== o.occlusionTexture &&
            t !== gt &&
            (c.push(n.assignTexture(s, "aoMap", o.occlusionTexture)),
            void 0 !== o.occlusionTexture.strength &&
              (s.aoMapIntensity = o.occlusionTexture.strength)),
          void 0 !== o.emissiveFactor &&
            t !== gt &&
            (s.emissive = new dt().fromArray(o.emissiveFactor)),
          void 0 !== o.emissiveTexture &&
            t !== gt &&
            c.push(n.assignTexture(s, "emissiveMap", o.emissiveTexture)),
          Promise.all(c).then(function () {
            var i;
            return (
              (i =
                t === A
                  ? r[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s)
                  : new t(s)),
              o.name && (i.name = o.name),
              i.map && (i.map.encoding = E),
              i.emissiveMap && (i.emissiveMap.encoding = E),
              G(i, o),
              n.associations.set(i, { type: "materials", index: e }),
              o.extensions && H(r, i, o),
              i
            );
          })
        );
      }),
      (X.prototype.createUniqueName = function (e) {
        for (
          var t = bc.sanitizeNodeName(e || ""), n = t, i = 1;
          this.nodeNamesUsed[n];
          ++i
        )
          n = t + "_" + i;
        return (this.nodeNamesUsed[n] = !0), n;
      }),
      (X.prototype.loadGeometries = function (e) {
        var t = this,
          n = this.extensions,
          i = this.primitiveCache;
        function r(e) {
          return n[h.KHR_DRACO_MESH_COMPRESSION]
            .decodePrimitive(e, t)
            .then(function (n) {
              return q(n, e, t);
            });
        }
        for (var o, s, a = [], c = 0, l = e.length; c < l; c++) {
          var u,
            d = e[c],
            p =
              (void 0,
              (s =
                (o = d).extensions &&
                o.extensions[h.KHR_DRACO_MESH_COMPRESSION])
                ? "draco:" +
                  s.bufferView +
                  ":" +
                  s.indices +
                  ":" +
                  j(s.attributes)
                : o.indices + ":" + j(o.attributes) + ":" + o.mode),
            f = i[p];
          f
            ? a.push(f.promise)
            : ((u =
                d.extensions && d.extensions[h.KHR_DRACO_MESH_COMPRESSION]
                  ? r(d)
                  : q(new Ht(), d, t)),
              (i[p] = { primitive: d, promise: u }),
              a.push(u));
        }
        return Promise.all(a);
      }),
      (X.prototype.loadMesh = function (e) {
        for (
          var t,
            n = this,
            i = this.json,
            r = this.extensions,
            o = i.meshes[e],
            s = o.primitives,
            a = [],
            c = 0,
            l = s.length;
          c < l;
          c++
        ) {
          var h =
            void 0 === s[c].material
              ? (void 0 === (t = this.cache).DefaultMaterial &&
                  (t.DefaultMaterial = new As({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0,
                  })),
                t.DefaultMaterial)
              : this.getDependency("material", s[c].material);
          a.push(h);
        }
        return (
          a.push(n.loadGeometries(s)),
          Promise.all(a).then(function (t) {
            for (
              var i = t.slice(0, t.length - 1),
                a = t[t.length - 1],
                c = [],
                l = 0,
                h = a.length;
              l < h;
              l++
            ) {
              var u,
                d = a[l],
                p = s[l],
                f = i[l];
              if (
                4 === p.mode ||
                5 === p.mode ||
                6 === p.mode ||
                void 0 === p.mode
              )
                !0 !==
                  (u = !0 === o.isSkinnedMesh ? new ao(d, f) : new sn(d, f))
                    .isSkinnedMesh ||
                  u.geometry.attributes.skinWeight.normalized ||
                  u.normalizeSkinWeights(),
                  5 === p.mode
                    ? (u.geometry = Z(u.geometry, 1))
                    : 6 === p.mode && (u.geometry = Z(u.geometry, 2));
              else if (1 === p.mode) u = new Ao(d, f);
              else if (3 === p.mode) u = new So(d, f);
              else if (2 === p.mode) u = new Lo(d, f);
              else {
                if (0 !== p.mode)
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + p.mode
                  );
                u = new No(d, f);
              }
              Object.keys(u.geometry.morphAttributes).length > 0 && V(u, o),
                (u.name = n.createUniqueName(o.name || "mesh_" + e)),
                G(u, o),
                p.extensions && H(r, u, p),
                n.assignFinalMaterial(u),
                c.push(u);
            }
            if (1 === c.length) return c[0];
            var m = new Tr();
            for (l = 0, h = c.length; l < h; l++) m.add(c[l]);
            return m;
          })
        );
      }),
      (X.prototype.loadCamera = function (e) {
        var t,
          n = this.json.cameras[e],
          i = n[n.type];
        if (i)
          return (
            "perspective" === n.type
              ? (t = new mn(
                  I.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : "orthographic" === n.type &&
                (t = new Ba(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            G(t, n),
            Promise.resolve(t)
          );
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
      }),
      (X.prototype.loadSkin = function (e) {
        var t = this.json.skins[e],
          n = { joints: t.joints };
        return void 0 === t.inverseBindMatrices
          ? Promise.resolve(n)
          : this.getDependency("accessor", t.inverseBindMatrices).then(
              function (e) {
                return (n.inverseBindMatrices = e), n;
              }
            );
      }),
      (X.prototype.loadAnimation = function (e) {
        for (
          var t = this.json.animations[e],
            n = [],
            i = [],
            r = [],
            o = [],
            s = [],
            a = 0,
            c = t.channels.length;
          a < c;
          a++
        ) {
          var l = t.channels[a],
            h = t.samplers[l.sampler],
            u = l.target,
            d = void 0 !== u.node ? u.node : u.id,
            p = void 0 !== t.parameters ? t.parameters[h.input] : h.input,
            f = void 0 !== t.parameters ? t.parameters[h.output] : h.output;
          n.push(this.getDependency("node", d)),
            i.push(this.getDependency("accessor", p)),
            r.push(this.getDependency("accessor", f)),
            o.push(h),
            s.push(u);
        }
        return Promise.all([
          Promise.all(n),
          Promise.all(i),
          Promise.all(r),
          Promise.all(o),
          Promise.all(s),
        ]).then(function (n) {
          for (
            var i = n[0],
              r = n[1],
              o = n[2],
              s = n[3],
              a = n[4],
              c = [],
              l = 0,
              h = i.length;
            l < h;
            l++
          ) {
            var u = i[l],
              d = r[l],
              p = o[l],
              f = s[l],
              m = a[l];
            if (void 0 !== u) {
              var g;
              switch (
                (u.updateMatrix(), (u.matrixAutoUpdate = !0), k[m.path])
              ) {
                case k.weights:
                  g = js;
                  break;
                case k.rotation:
                  g = Xs;
                  break;
                default:
                  g = Ys;
              }
              var v = u.name ? u.name : u.uuid,
                y = void 0 !== f.interpolation ? B[f.interpolation] : x,
                _ = [];
              k[m.path] === k.weights
                ? u.traverse(function (e) {
                    !0 === e.isMesh &&
                      e.morphTargetInfluences &&
                      _.push(e.name ? e.name : e.uuid);
                  })
                : _.push(v);
              var b = p.array;
              if (p.normalized) {
                var w;
                if (b.constructor === Int8Array) w = 1 / 127;
                else if (b.constructor === Uint8Array) w = 1 / 255;
                else if (b.constructor == Int16Array) w = 1 / 32767;
                else {
                  if (b.constructor !== Uint16Array)
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported output accessor component type."
                    );
                  w = 1 / 65535;
                }
                for (
                  var M = new Float32Array(b.length), S = 0, E = b.length;
                  S < E;
                  S++
                )
                  M[S] = b[S] * w;
                b = M;
              }
              for (S = 0, E = _.length; S < E; S++) {
                var T = new g(_[S] + "." + k[m.path], d.array, b, y);
                "CUBICSPLINE" === f.interpolation &&
                  ((T.createInterpolant = function (e) {
                    return new C(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      e
                    );
                  }),
                  (T.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                    !0)),
                  c.push(T);
              }
            }
          }
          return new Zs(t.name ? t.name : "animation_" + e, void 0, c);
        });
      }),
      (X.prototype.loadNode = function (e) {
        var t,
          n = this.json,
          i = this.extensions,
          r = this,
          o = n.nodes[e],
          s = o.name ? r.createUniqueName(o.name) : "";
        return ((t = []),
        void 0 !== o.mesh &&
          t.push(
            r.getDependency("mesh", o.mesh).then(function (e) {
              var t = r._getNodeRef(r.meshCache, o.mesh, e);
              return (
                void 0 !== o.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (var t = 0, n = o.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = o.weights[t];
                  }),
                t
              );
            })
          ),
        void 0 !== o.camera &&
          t.push(
            r.getDependency("camera", o.camera).then(function (e) {
              return r._getNodeRef(r.cameraCache, o.camera, e);
            })
          ),
        r
          ._invokeAll(function (t) {
            return t.createNodeAttachment && t.createNodeAttachment(e);
          })
          .forEach(function (e) {
            t.push(e);
          }),
        Promise.all(t)).then(function (t) {
          var n;
          if (
            (n =
              !0 === o.isBone
                ? new co()
                : t.length > 1
                ? new Tr()
                : 1 === t.length
                ? t[0]
                : new je()) !== t[0]
          )
            for (var a = 0, c = t.length; a < c; a++) n.add(t[a]);
          if (
            (o.name && ((n.userData.name = o.name), (n.name = s)),
            G(n, o),
            o.extensions && H(i, n, o),
            void 0 !== o.matrix)
          ) {
            var l = new xe();
            l.fromArray(o.matrix), n.applyMatrix4(l);
          } else void 0 !== o.translation && n.position.fromArray(o.translation), void 0 !== o.rotation && n.quaternion.fromArray(o.rotation), void 0 !== o.scale && n.scale.fromArray(o.scale);
          return r.associations.set(n, { type: "nodes", index: e }), n;
        });
      }),
      (X.prototype.loadScene = (function () {
        function e(t, n, i, r) {
          var o = i.nodes[t];
          return r
            .getDependency("node", t)
            .then(function (e) {
              return void 0 === o.skin
                ? e
                : r
                    .getDependency("skin", o.skin)
                    .then(function (e) {
                      for (
                        var n = [], i = 0, o = (t = e).joints.length;
                        i < o;
                        i++
                      )
                        n.push(r.getDependency("node", t.joints[i]));
                      return Promise.all(n);
                    })
                    .then(function (n) {
                      return (
                        e.traverse(function (e) {
                          if (e.isMesh) {
                            for (
                              var i = [], r = [], o = 0, s = n.length;
                              o < s;
                              o++
                            ) {
                              var a = n[o];
                              if (a) {
                                i.push(a);
                                var c = new xe();
                                void 0 !== t.inverseBindMatrices &&
                                  c.fromArray(
                                    t.inverseBindMatrices.array,
                                    16 * o
                                  ),
                                  r.push(c);
                              } else
                                console.warn(
                                  'THREE.GLTFLoader: Joint "%s" could not be found.',
                                  t.joints[o]
                                );
                            }
                            e.bind(new uo(i, r), e.matrixWorld);
                          }
                        }),
                        e
                      );
                    });
              var t;
            })
            .then(function (t) {
              n.add(t);
              var s = [];
              if (o.children)
                for (var a = o.children, c = 0, l = a.length; c < l; c++) {
                  var h = a[c];
                  s.push(e(h, t, i, r));
                }
              return Promise.all(s);
            });
        }
        return function (t) {
          var n = this.json,
            i = this.extensions,
            r = this.json.scenes[t],
            o = new Tr();
          r.name && (o.name = this.createUniqueName(r.name)),
            G(o, r),
            r.extensions && H(i, o, r);
          for (var s = r.nodes || [], a = [], c = 0, l = s.length; c < l; c++)
            a.push(e(s[c], o, n, this));
          return Promise.all(a).then(function () {
            return o;
          });
        };
      })()),
      e
    );
  })();
  const xh = "w",
    _h = "a",
    bh = "s",
    wh = "d",
    Mh = "shift",
    Sh = [xh, _h, bh, wh];
  class Eh {
    model;
    mixer;
    animationsMap = new Map();
    orbitControl;
    camera;
    toggleRun = !0;
    currentAction;
    walkDirection = new W();
    rotateAngle = new W(0, 1, 0);
    rotateQuarternion = new j();
    cameraTarget = new W();
    fadeDuration = 0.2;
    runVelocity = 5;
    walkVelocity = 2;
    constructor(e, t, n, i, r, o) {
      (this.model = e),
        (this.mixer = t),
        (this.animationsMap = n),
        (this.currentAction = o),
        this.animationsMap.forEach((e, t) => {
          t == o && e.play();
        }),
        (this.orbitControl = i),
        (this.camera = r),
        this.updateCameraTarget(0, 0);
    }
    switchRunToggle() {
      this.toggleRun = !this.toggleRun;
    }
    update(e, t) {
      const n = Sh.some((e) => 1 == t[e]);
      let i = "";
      if (
        ((i = n && this.toggleRun ? "Run" : n ? "Walk" : "Idle"),
        this.currentAction != i)
      ) {
        const e = this.animationsMap.get(i);
        this.animationsMap.get(this.currentAction).fadeOut(this.fadeDuration),
          e.reset().fadeIn(this.fadeDuration).play(),
          (this.currentAction = i);
      }
      if (
        (this.mixer.update(e),
        "Run" == this.currentAction || "Walk" == this.currentAction)
      ) {
        let n = Math.atan2(
            this.camera.position.x - this.model.position.x,
            this.camera.position.z - this.model.position.z
          ),
          i = this.directionOffset(t);
        this.rotateQuarternion.setFromAxisAngle(this.rotateAngle, n + i),
          this.model.quaternion.rotateTowards(this.rotateQuarternion, 0.2),
          this.camera.getWorldDirection(this.walkDirection),
          (this.walkDirection.y = 0),
          this.walkDirection.normalize(),
          this.walkDirection.applyAxisAngle(this.rotateAngle, i);
        const r =
            "Run" == this.currentAction ? this.runVelocity : this.walkVelocity,
          o = this.walkDirection.x * r * e,
          s = this.walkDirection.z * r * e;
        (this.model.position.x += o),
          (this.model.position.z += s),
          this.updateCameraTarget(o, s);
      }
    }
    updateCameraTarget(e, t) {
      (this.camera.position.x += e),
        (this.camera.position.z += t),
        (this.cameraTarget.x = this.model.position.x),
        (this.cameraTarget.y = this.model.position.y + 1),
        (this.cameraTarget.z = this.model.position.z),
        (this.orbitControl.target = this.cameraTarget);
    }
    directionOffset(e) {
      let t = 0;
      return (
        e.w
          ? e.a
            ? (t = Math.PI / 4)
            : e.d && (t = -Math.PI / 4)
          : e.s
          ? (t = e.a
              ? Math.PI / 4 + Math.PI / 2
              : e.d
              ? -Math.PI / 4 - Math.PI / 2
              : Math.PI)
          : e.a
          ? (t = Math.PI / 2)
          : e.d && (t = -Math.PI / 2),
        t
      );
    }
  }
  var Th = {},
    Ah = void 0,
    Lh = Th;
  function Rh(e, t) {
    var n,
      i = e.split("."),
      r = Lh;
    !(i[0] in r) && r.execScript && r.execScript("var " + i[0]);
    for (; i.length && (n = i.shift()); )
      i.length || t === Ah ? (r = r[n] ? r[n] : (r[n] = {})) : (r[n] = t);
  }
  var Ch =
    "undefined" != typeof Uint8Array &&
    "undefined" != typeof Uint16Array &&
    "undefined" != typeof Uint32Array &&
    "undefined" != typeof DataView;
  function Ph(e) {
    var t,
      n,
      i,
      r,
      o,
      s,
      a,
      c,
      l,
      h,
      u = e.length,
      d = 0,
      p = Number.POSITIVE_INFINITY;
    for (c = 0; c < u; ++c) e[c] > d && (d = e[c]), e[c] < p && (p = e[c]);
    for (
      t = 1 << d, n = new (Ch ? Uint32Array : Array)(t), i = 1, r = 0, o = 2;
      i <= d;

    ) {
      for (c = 0; c < u; ++c)
        if (e[c] === i) {
          for (s = 0, a = r, l = 0; l < i; ++l)
            (s = (s << 1) | (1 & a)), (a >>= 1);
          for (h = (i << 16) | c, l = s; l < t; l += o) n[l] = h;
          ++r;
        }
      ++i, (r <<= 1), (o <<= 1);
    }
    return [n, d, p];
  }
  function Oh(e, t) {
    switch (
      ((this.g = []),
      (this.h = 32768),
      (this.d = this.f = this.a = this.l = 0),
      (this.input = Ch ? new Uint8Array(e) : e),
      (this.m = !1),
      (this.i = Nh),
      (this.r = !1),
      (!t && (t = {})) ||
        (t.index && (this.a = t.index),
        t.bufferSize && (this.h = t.bufferSize),
        t.bufferType && (this.i = t.bufferType),
        t.resize && (this.r = t.resize)),
      this.i)
    ) {
      case Ih:
        (this.b = 32768),
          (this.c = new (Ch ? Uint8Array : Array)(32768 + this.h + 258));
        break;
      case Nh:
        (this.b = 0),
          (this.c = new (Ch ? Uint8Array : Array)(this.h)),
          (this.e = this.z),
          (this.n = this.v),
          (this.j = this.w);
        break;
      default:
        throw Error("invalid inflate mode");
    }
  }
  var Ih = 0,
    Nh = 1,
    Dh = { t: Ih, s: Nh };
  Oh.prototype.k = function () {
    for (; !this.m; ) {
      var e = eu(this, 3);
      switch ((1 & e && (this.m = !0), (e >>>= 1))) {
        case 0:
          var t = this.input,
            n = this.a,
            i = this.c,
            r = this.b,
            o = t.length,
            s = Ah,
            a = i.length,
            c = Ah;
          if (((this.d = this.f = 0), n + 1 >= o))
            throw Error("invalid uncompressed block header: LEN");
          if (((s = t[n++] | (t[n++] << 8)), n + 1 >= o))
            throw Error("invalid uncompressed block header: NLEN");
          if (s === ~(t[n++] | (t[n++] << 8)))
            throw Error("invalid uncompressed block header: length verify");
          if (n + s > t.length) throw Error("input buffer is broken");
          switch (this.i) {
            case Ih:
              for (; r + s > i.length; ) {
                if (((s -= c = a - r), Ch))
                  i.set(t.subarray(n, n + c), r), (r += c), (n += c);
                else for (; c--; ) i[r++] = t[n++];
                (this.b = r), (i = this.e()), (r = this.b);
              }
              break;
            case Nh:
              for (; r + s > i.length; ) i = this.e({ p: 2 });
              break;
            default:
              throw Error("invalid inflate mode");
          }
          if (Ch) i.set(t.subarray(n, n + s), r), (r += s), (n += s);
          else for (; s--; ) i[r++] = t[n++];
          (this.a = n), (this.b = r), (this.c = i);
          break;
        case 1:
          this.j(Kh, $h);
          break;
        case 2:
          var l,
            h,
            u,
            d,
            p = eu(this, 5) + 257,
            f = eu(this, 5) + 1,
            m = eu(this, 4) + 4,
            g = new (Ch ? Uint8Array : Array)(Bh.length),
            v = Ah,
            y = Ah,
            x = Ah,
            _ = Ah,
            b = Ah;
          for (b = 0; b < m; ++b) g[Bh[b]] = eu(this, 3);
          if (!Ch) for (b = m, m = g.length; b < m; ++b) g[Bh[b]] = 0;
          for (
            l = Ph(g),
              v = new (Ch ? Uint8Array : Array)(p + f),
              b = 0,
              d = p + f;
            b < d;

          )
            switch (((y = tu(this, l)), y)) {
              case 16:
                for (_ = 3 + eu(this, 2); _--; ) v[b++] = x;
                break;
              case 17:
                for (_ = 3 + eu(this, 3); _--; ) v[b++] = 0;
                x = 0;
                break;
              case 18:
                for (_ = 11 + eu(this, 7); _--; ) v[b++] = 0;
                x = 0;
                break;
              default:
                x = v[b++] = y;
            }
          (h = Ph(Ch ? v.subarray(0, p) : v.slice(0, p))),
            (u = Ph(Ch ? v.subarray(p) : v.slice(p))),
            this.j(h, u);
          break;
        default:
          throw Error("unknown BTYPE: " + e);
      }
    }
    return this.n();
  };
  var Fh,
    Uh,
    kh = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    Bh = Ch ? new Uint16Array(kh) : kh,
    zh = [
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258,
    ],
    Hh = Ch ? new Uint16Array(zh) : zh,
    Gh = [
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
      5, 5, 5, 0, 0, 0,
    ],
    Vh = Ch ? new Uint8Array(Gh) : Gh,
    jh = [
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,
    ],
    Wh = Ch ? new Uint16Array(jh) : jh,
    Xh = [
      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
      11, 11, 12, 12, 13, 13,
    ],
    qh = Ch ? new Uint8Array(Xh) : Xh,
    Yh = new (Ch ? Uint8Array : Array)(288);
  for (Fh = 0, Uh = Yh.length; Fh < Uh; ++Fh)
    Yh[Fh] = 143 >= Fh ? 8 : 255 >= Fh ? 9 : 279 >= Fh ? 7 : 8;
  var Zh,
    Jh,
    Kh = Ph(Yh),
    Qh = new (Ch ? Uint8Array : Array)(30);
  for (Zh = 0, Jh = Qh.length; Zh < Jh; ++Zh) Qh[Zh] = 5;
  var $h = Ph(Qh);
  function eu(e, t) {
    for (var n, i = e.f, r = e.d, o = e.input, s = e.a, a = o.length; r < t; ) {
      if (s >= a) throw Error("input buffer is broken");
      (i |= o[s++] << r), (r += 8);
    }
    return (
      (n = i & ((1 << t) - 1)), (e.f = i >>> t), (e.d = r - t), (e.a = s), n
    );
  }
  function tu(e, t) {
    for (
      var n,
        i,
        r = e.f,
        o = e.d,
        s = e.input,
        a = e.a,
        c = s.length,
        l = t[0],
        h = t[1];
      o < h && !(a >= c);

    )
      (r |= s[a++] << o), (o += 8);
    if ((i = (n = l[r & ((1 << h) - 1)]) >>> 16) > o)
      throw Error("invalid code length: " + i);
    return (e.f = r >> i), (e.d = o - i), (e.a = a), 65535 & n;
  }
  function nu(e, t) {
    var n, i;
    if (
      ((this.input = e),
      (this.a = 0),
      (!t && (t = {})) ||
        (t.index && (this.a = t.index), t.verify && (this.A = t.verify)),
      (n = e[this.a++]),
      (i = e[this.a++]),
      (15 & n) !== iu)
    )
      throw Error("unsupported compression method");
    if (((this.method = iu), 0 != ((n << 8) + i) % 31))
      throw Error("invalid fcheck flag:" + (((n << 8) + i) % 31));
    if (32 & i) throw Error("fdict flag is not supported");
    this.q = new Oh(e, {
      index: this.a,
      bufferSize: t.bufferSize,
      bufferType: t.bufferType,
      resize: t.resize,
    });
  }
  (Oh.prototype.j = function (e, t) {
    var n = this.c,
      i = this.b;
    this.o = e;
    for (var r, o, s, a, c = n.length - 258; 256 !== (r = tu(this, e)); )
      if (256 > r)
        i >= c && ((this.b = i), (n = this.e()), (i = this.b)), (n[i++] = r);
      else
        for (
          a = Hh[(o = r - 257)],
            0 < Vh[o] && (a += eu(this, Vh[o])),
            r = tu(this, t),
            s = Wh[r],
            0 < qh[r] && (s += eu(this, qh[r])),
            i >= c && ((this.b = i), (n = this.e()), (i = this.b));
          a--;

        )
          n[i] = n[i++ - s];
    for (; 8 <= this.d; ) (this.d -= 8), this.a--;
    this.b = i;
  }),
    (Oh.prototype.w = function (e, t) {
      var n = this.c,
        i = this.b;
      this.o = e;
      for (var r, o, s, a, c = n.length; 256 !== (r = tu(this, e)); )
        if (256 > r) i >= c && (c = (n = this.e()).length), (n[i++] = r);
        else
          for (
            a = Hh[(o = r - 257)],
              0 < Vh[o] && (a += eu(this, Vh[o])),
              r = tu(this, t),
              s = Wh[r],
              0 < qh[r] && (s += eu(this, qh[r])),
              i + a > c && (c = (n = this.e()).length);
            a--;

          )
            n[i] = n[i++ - s];
      for (; 8 <= this.d; ) (this.d -= 8), this.a--;
      this.b = i;
    }),
    (Oh.prototype.e = function () {
      var e,
        t,
        n = new (Ch ? Uint8Array : Array)(this.b - 32768),
        i = this.b - 32768,
        r = this.c;
      if (Ch) n.set(r.subarray(32768, n.length));
      else for (e = 0, t = n.length; e < t; ++e) n[e] = r[e + 32768];
      if ((this.g.push(n), (this.l += n.length), Ch))
        r.set(r.subarray(i, i + 32768));
      else for (e = 0; 32768 > e; ++e) r[e] = r[i + e];
      return (this.b = 32768), r;
    }),
    (Oh.prototype.z = function (e) {
      var t,
        n,
        i,
        r = (this.input.length / this.a + 1) | 0,
        o = this.input,
        s = this.c;
      return (
        e &&
          ("number" == typeof e.p && (r = e.p),
          "number" == typeof e.u && (r += e.u)),
        (n =
          2 > r
            ? (i = (((o.length - this.a) / this.o[2] / 2) * 258) | 0) < s.length
              ? s.length + i
              : s.length << 1
            : s.length * r),
        Ch ? (t = new Uint8Array(n)).set(s) : (t = s),
        (this.c = t)
      );
    }),
    (Oh.prototype.n = function () {
      var e,
        t,
        n,
        i,
        r,
        o = 0,
        s = this.c,
        a = this.g,
        c = new (Ch ? Uint8Array : Array)(this.l + (this.b - 32768));
      if (0 === a.length)
        return Ch
          ? this.c.subarray(32768, this.b)
          : this.c.slice(32768, this.b);
      for (t = 0, n = a.length; t < n; ++t)
        for (i = 0, r = (e = a[t]).length; i < r; ++i) c[o++] = e[i];
      for (t = 32768, n = this.b; t < n; ++t) c[o++] = s[t];
      return (this.g = []), (this.buffer = c);
    }),
    (Oh.prototype.v = function () {
      var e,
        t = this.b;
      return (
        Ch
          ? this.r
            ? (e = new Uint8Array(t)).set(this.c.subarray(0, t))
            : (e = this.c.subarray(0, t))
          : (this.c.length > t && (this.c.length = t), (e = this.c)),
        (this.buffer = e)
      );
    }),
    (nu.prototype.k = function () {
      var e,
        t,
        n = this.input;
      if (((e = this.q.k()), (this.a = this.q.a), this.A)) {
        t =
          ((n[this.a++] << 24) |
            (n[this.a++] << 16) |
            (n[this.a++] << 8) |
            n[this.a++]) >>>
          0;
        var i = e;
        if ("string" == typeof i) {
          var r,
            o,
            s = i.split("");
          for (r = 0, o = s.length; r < o; r++)
            s[r] = (255 & s[r].charCodeAt(0)) >>> 0;
          i = s;
        }
        for (var a, c = 1, l = 0, h = i.length, u = 0; 0 < h; ) {
          h -= a = 1024 < h ? 1024 : h;
          do {
            l += c += i[u++];
          } while (--a);
          (c %= 65521), (l %= 65521);
        }
        if (t !== ((l << 16) | c) >>> 0)
          throw Error("invalid adler-32 checksum");
      }
      return e;
    });
  var iu = 8;
  Rh("Zlib.Inflate", nu),
    Rh("Zlib.Inflate.prototype.decompress", nu.prototype.k);
  var ru,
    ou,
    su,
    au,
    cu = { ADAPTIVE: Dh.s, BLOCK: Dh.t };
  if (Object.keys) ru = Object.keys(cu);
  else for (ou in ((ru = []), (su = 0), cu)) ru[su++] = ou;
  for (su = 0, au = ru.length; su < au; ++su)
    Rh("Zlib.Inflate.BufferType." + (ou = ru[su]), cu[ou]);
  var lu = Th.Zlib.Inflate,
    hu = {
      findSpan: function (e, t, n) {
        var i = n.length - e - 1;
        if (t >= n[i]) return i - 1;
        if (t <= n[e]) return e;
        for (
          var r = e, o = i, s = Math.floor((r + o) / 2);
          t < n[s] || t >= n[s + 1];

        )
          t < n[s] ? (o = s) : (r = s), (s = Math.floor((r + o) / 2));
        return s;
      },
      calcBasisFunctions: function (e, t, n, i) {
        var r = [],
          o = [],
          s = [];
        r[0] = 1;
        for (var a = 1; a <= n; ++a) {
          (o[a] = t - i[e + 1 - a]), (s[a] = i[e + a] - t);
          for (var c = 0, l = 0; l < a; ++l) {
            var h = s[l + 1],
              u = o[a - l],
              d = r[l] / (h + u);
            (r[l] = c + h * d), (c = u * d);
          }
          r[a] = c;
        }
        return r;
      },
      calcBSplinePoint: function (e, t, n, i) {
        for (
          var r = this.findSpan(e, i, t),
            o = this.calcBasisFunctions(r, i, e, t),
            s = new H(0, 0, 0, 0),
            a = 0;
          a <= e;
          ++a
        ) {
          var c = n[r - e + a],
            l = o[a],
            h = c.w * l;
          (s.x += c.x * h),
            (s.y += c.y * h),
            (s.z += c.z * h),
            (s.w += c.w * l);
        }
        return s;
      },
      calcBasisFunctionDerivatives: function (e, t, n, i, r) {
        for (var o = [], s = 0; s <= n; ++s) o[s] = 0;
        var a = [];
        for (s = 0; s <= i; ++s) a[s] = o.slice(0);
        var c = [];
        for (s = 0; s <= n; ++s) c[s] = o.slice(0);
        c[0][0] = 1;
        for (var l = o.slice(0), h = o.slice(0), u = 1; u <= n; ++u) {
          (l[u] = t - r[e + 1 - u]), (h[u] = r[e + u] - t);
          for (var d = 0, p = 0; p < u; ++p) {
            var f = h[p + 1],
              m = l[u - p];
            c[u][p] = f + m;
            var g = c[p][u - 1] / c[u][p];
            (c[p][u] = d + f * g), (d = m * g);
          }
          c[u][u] = d;
        }
        for (u = 0; u <= n; ++u) a[0][u] = c[u][n];
        for (p = 0; p <= n; ++p) {
          var v = 0,
            y = 1,
            x = [];
          for (s = 0; s <= n; ++s) x[s] = o.slice(0);
          x[0][0] = 1;
          for (var _ = 1; _ <= i; ++_) {
            var b = 0,
              w = p - _,
              M = n - _;
            p >= _ &&
              ((x[y][0] = x[v][0] / c[M + 1][w]), (b = x[y][0] * c[w][M]));
            var S = p - 1 <= M ? _ - 1 : n - p;
            for (u = w >= -1 ? 1 : -w; u <= S; ++u)
              (x[y][u] = (x[v][u] - x[v][u - 1]) / c[M + 1][w + u]),
                (b += x[y][u] * c[w + u][M]);
            p <= M &&
              ((x[y][_] = -x[v][_ - 1] / c[M + 1][p]),
              (b += x[y][_] * c[p][M])),
              (a[_][p] = b),
              (u = v),
              (v = y),
              (y = u);
          }
        }
        for (p = n, _ = 1; _ <= i; ++_) {
          for (u = 0; u <= n; ++u) a[_][u] *= p;
          p *= n - _;
        }
        return a;
      },
      calcBSplineDerivatives: function (e, t, n, i, r) {
        for (
          var o = r < e ? r : e,
            s = [],
            a = this.findSpan(e, i, t),
            c = this.calcBasisFunctionDerivatives(a, i, e, o, t),
            l = [],
            h = 0;
          h < n.length;
          ++h
        ) {
          var u = (p = n[h].clone()).w;
          (p.x *= u), (p.y *= u), (p.z *= u), (l[h] = p);
        }
        for (var d = 0; d <= o; ++d) {
          for (
            var p = l[a - e].clone().multiplyScalar(c[d][0]), f = 1;
            f <= e;
            ++f
          )
            p.add(l[a - e + f].clone().multiplyScalar(c[d][f]));
          s[d] = p;
        }
        for (d = o + 1; d <= r + 1; ++d) s[d] = new H(0, 0, 0);
        return s;
      },
      calcKoverI: function (e, t) {
        for (var n = 1, i = 2; i <= e; ++i) n *= i;
        var r = 1;
        for (i = 2; i <= t; ++i) r *= i;
        for (i = 2; i <= e - t; ++i) r *= i;
        return n / r;
      },
      calcRationalCurveDerivatives: function (e) {
        for (var t = e.length, n = [], i = [], r = 0; r < t; ++r) {
          var o = e[r];
          (n[r] = new W(o.x, o.y, o.z)), (i[r] = o.w);
        }
        for (var s = [], a = 0; a < t; ++a) {
          var c = n[a].clone();
          for (r = 1; r <= a; ++r)
            c.sub(
              s[a - r].clone().multiplyScalar(this.calcKoverI(a, r) * i[r])
            );
          s[a] = c.divideScalar(i[0]);
        }
        return s;
      },
      calcNURBSDerivatives: function (e, t, n, i, r) {
        var o = this.calcBSplineDerivatives(e, t, n, i, r);
        return this.calcRationalCurveDerivatives(o);
      },
      calcSurfacePoint: function (e, t, n, i, r, o, s, a) {
        for (
          var c = this.findSpan(e, o, n),
            l = this.findSpan(t, s, i),
            h = this.calcBasisFunctions(c, o, e, n),
            u = this.calcBasisFunctions(l, s, t, i),
            d = [],
            p = 0;
          p <= t;
          ++p
        ) {
          d[p] = new H(0, 0, 0, 0);
          for (var f = 0; f <= e; ++f) {
            var m = r[c - e + f][l - t + p].clone(),
              g = m.w;
            (m.x *= g),
              (m.y *= g),
              (m.z *= g),
              d[p].add(m.multiplyScalar(h[f]));
          }
        }
        var v = new H(0, 0, 0, 0);
        for (p = 0; p <= t; ++p) v.add(d[p].multiplyScalar(u[p]));
        v.divideScalar(v.w), a.set(v.x, v.y, v.z);
      },
    },
    uu = function (e, t, n, i, r) {
      la.call(this),
        (this.degree = e),
        (this.knots = t),
        (this.controlPoints = []),
        (this.startKnot = i || 0),
        (this.endKnot = r || this.knots.length - 1);
      for (var o = 0; o < n.length; ++o) {
        var s = n[o];
        this.controlPoints[o] = new H(s.x, s.y, s.z, s.w);
      }
    };
  ((uu.prototype = Object.create(la.prototype)).constructor = uu),
    (uu.prototype.getPoint = function (e, t) {
      var n = t || new W(),
        i =
          this.knots[this.startKnot] +
          e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
        r = hu.calcBSplinePoint(this.degree, this.knots, this.controlPoints, i);
      return 1 != r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z);
    }),
    (uu.prototype.getTangent = function (e, t) {
      var n = t || new W(),
        i =
          this.knots[0] +
          e * (this.knots[this.knots.length - 1] - this.knots[0]),
        r = hu.calcNURBSDerivatives(
          this.degree,
          this.knots,
          this.controlPoints,
          i,
          1
        );
      return n.copy(r[1]).normalize(), n;
    });
  var du = (function () {
    var e, i, r;
    function o(e) {
      ea.call(this, e);
    }
    function s(e, t) {
      (this.textureLoader = e), (this.manager = t);
    }
    function a() {}
    function c() {}
    function l() {}
    function h() {}
    function u(e, t) {
      (this.dv = new DataView(e)),
        (this.offset = 0),
        (this.littleEndian = void 0 === t || t);
    }
    function d() {}
    function p(e) {
      var t = e.match(/FBXVersion: (\d+)/);
      if (t) return parseInt(t[1]);
      throw new Error(
        "THREE.FBXLoader: Cannot find the version number for the file given."
      );
    }
    function f(e) {
      return e / 46186158e3;
    }
    (o.prototype = Object.assign(Object.create(ea.prototype), {
      constructor: o,
      load: function (e, t, n, i) {
        var r = this,
          o = "" === r.path ? Ya(e) : r.path,
          s = new na(this.manager);
        s.setPath(r.path),
          s.setResponseType("arraybuffer"),
          s.setRequestHeader(r.requestHeader),
          s.setWithCredentials(r.withCredentials),
          s.load(
            e,
            function (n) {
              try {
                t(r.parse(n, o));
              } catch (t) {
                i ? i(t) : console.error(t), r.manager.itemError(e);
              }
            },
            n,
            i
          );
      },
      parse: function (t, n) {
        if (
          ((o = "Kaydara FBX Binary  \0"),
          (r = t).byteLength >= o.length && o === w(r, 0, o.length))
        )
          e = new h().parse(t);
        else {
          var i = w(t);
          if (
            !(function (e) {
              var t = [
                  "K",
                  "a",
                  "y",
                  "d",
                  "a",
                  "r",
                  "a",
                  "\\",
                  "F",
                  "B",
                  "X",
                  "\\",
                  "B",
                  "i",
                  "n",
                  "a",
                  "r",
                  "y",
                  "\\",
                  "\\",
                ],
                n = 0;
              function i(t) {
                var i = e[t - 1];
                return (e = e.slice(n + t)), n++, i;
              }
              for (var r = 0; r < t.length; ++r) if (i(1) === t[r]) return !1;
              return !0;
            })(i)
          )
            throw new Error("THREE.FBXLoader: Unknown format.");
          if (p(i) < 7e3)
            throw new Error(
              "THREE.FBXLoader: FBX version not supported, FileVersion: " + p(i)
            );
          e = new l().parse(i);
        }
        var r, o;
        return new s(
          new ca(this.manager)
            .setPath(this.resourcePath || n)
            .setCrossOrigin(this.crossOrigin),
          this.manager
        ).parse(e);
      },
    })),
      (s.prototype = {
        constructor: s,
        parse: function () {
          i = this.parseConnections();
          var e = this.parseImages(),
            t = this.parseTextures(e),
            n = this.parseMaterials(t),
            o = this.parseDeformers(),
            s = new a().parse(o);
          return this.parseScene(o, s, n), r;
        },
        parseConnections: function () {
          var t = new Map();
          return (
            "Connections" in e &&
              e.Connections.connections.forEach(function (e) {
                var n = e[0],
                  i = e[1],
                  r = e[2];
                t.has(n) || t.set(n, { parents: [], children: [] });
                var o = { ID: i, relationship: r };
                t.get(n).parents.push(o),
                  t.has(i) || t.set(i, { parents: [], children: [] });
                var s = { ID: n, relationship: r };
                t.get(i).children.push(s);
              }),
            t
          );
        },
        parseImages: function () {
          var t = {},
            n = {};
          if ("Video" in e.Objects) {
            var i = e.Objects.Video;
            for (var r in i) {
              var o = i[r];
              if (
                ((t[(l = parseInt(r))] = o.RelativeFilename || o.Filename),
                "Content" in o)
              ) {
                var s =
                    o.Content instanceof ArrayBuffer &&
                    o.Content.byteLength > 0,
                  a = "string" == typeof o.Content && "" !== o.Content;
                if (s || a) {
                  var c = this.parseImage(i[r]);
                  n[o.RelativeFilename || o.Filename] = c;
                }
              }
            }
          }
          for (var l in t) {
            var h = t[l];
            void 0 !== n[h] ? (t[l] = n[h]) : (t[l] = t[l].split("\\").pop());
          }
          return t;
        },
        parseImage: function (e) {
          var t,
            n = e.Content,
            i = e.RelativeFilename || e.Filename,
            r = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
          switch (r) {
            case "bmp":
              t = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              t = "image/jpeg";
              break;
            case "png":
              t = "image/png";
              break;
            case "tif":
              t = "image/tiff";
              break;
            case "tga":
              null === this.manager.getHandler(".tga") &&
                console.warn("FBXLoader: TGA loader not found, skipping ", i),
                (t = "image/tga");
              break;
            default:
              return void console.warn(
                'FBXLoader: Image type "' + r + '" is not supported.'
              );
          }
          if ("string" == typeof n) return "data:" + t + ";base64," + n;
          var o = new Uint8Array(n);
          return window.URL.createObjectURL(new Blob([o], { type: t }));
        },
        parseTextures: function (t) {
          var n = new Map();
          if ("Texture" in e.Objects) {
            var i = e.Objects.Texture;
            for (var r in i) {
              var o = this.parseTexture(i[r], t);
              n.set(parseInt(r), o);
            }
          }
          return n;
        },
        parseTexture: function (e, i) {
          var r = this.loadTexture(e, i);
          (r.ID = e.id), (r.name = e.attrName);
          var o = e.WrapModeU,
            s = e.WrapModeV,
            a = void 0 !== o ? o.value : 0,
            c = void 0 !== s ? s.value : 0;
          if (
            ((r.wrapS = 0 === a ? t : n),
            (r.wrapT = 0 === c ? t : n),
            "Scaling" in e)
          ) {
            var l = e.Scaling.value;
            (r.repeat.x = l[0]), (r.repeat.y = l[1]);
          }
          return r;
        },
        loadTexture: function (e, t) {
          var n,
            r,
            o = this.textureLoader.path,
            s = i.get(e.id).children;
          void 0 !== s &&
            s.length > 0 &&
            void 0 !== t[s[0].ID] &&
            ((0 !== (n = t[s[0].ID]).indexOf("blob:") &&
              0 !== n.indexOf("data:")) ||
              this.textureLoader.setPath(void 0));
          var a = e.FileName.slice(-3).toLowerCase();
          if ("tga" === a) {
            var c = this.manager.getHandler(".tga");
            null === c
              ? (console.warn(
                  "FBXLoader: TGA loader not found, creating placeholder texture for",
                  e.RelativeFilename
                ),
                (r = new B()))
              : (r = c.load(n));
          } else
            "psd" === a
              ? (console.warn(
                  "FBXLoader: PSD textures are not supported, creating placeholder texture for",
                  e.RelativeFilename
                ),
                (r = new B()))
              : (r = this.textureLoader.load(n));
          return this.textureLoader.setPath(o), r;
        },
        parseMaterials: function (t) {
          var n = new Map();
          if ("Material" in e.Objects) {
            var i = e.Objects.Material;
            for (var r in i) {
              var o = this.parseMaterial(i[r], t);
              null !== o && n.set(parseInt(r), o);
            }
          }
          return n;
        },
        parseMaterial: function (e, t) {
          var n = e.id,
            r = e.attrName,
            o = e.ShadingModel;
          if (("object" == typeof o && (o = o.value), !i.has(n))) return null;
          var s,
            a = this.parseParameters(e, t, n);
          switch (o.toLowerCase()) {
            case "phong":
              s = new Rs();
              break;
            case "lambert":
              s = new Os();
              break;
            default:
              console.warn(
                'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
                o
              ),
                (s = new Rs());
          }
          return s.setValues(a), (s.name = r), s;
        },
        parseParameters: function (e, t, n) {
          var r = {};
          e.BumpFactor && (r.bumpScale = e.BumpFactor.value),
            e.Diffuse
              ? (r.color = new dt().fromArray(e.Diffuse.value))
              : !e.DiffuseColor ||
                ("Color" !== e.DiffuseColor.type &&
                  "ColorRGB" !== e.DiffuseColor.type) ||
                (r.color = new dt().fromArray(e.DiffuseColor.value)),
            e.DisplacementFactor &&
              (r.displacementScale = e.DisplacementFactor.value),
            e.Emissive
              ? (r.emissive = new dt().fromArray(e.Emissive.value))
              : !e.EmissiveColor ||
                ("Color" !== e.EmissiveColor.type &&
                  "ColorRGB" !== e.EmissiveColor.type) ||
                (r.emissive = new dt().fromArray(e.EmissiveColor.value)),
            e.EmissiveFactor &&
              (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
            e.Opacity && (r.opacity = parseFloat(e.Opacity.value)),
            r.opacity < 1 && (r.transparent = !0),
            e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value),
            e.Shininess && (r.shininess = e.Shininess.value),
            e.Specular
              ? (r.specular = new dt().fromArray(e.Specular.value))
              : e.SpecularColor &&
                "Color" === e.SpecularColor.type &&
                (r.specular = new dt().fromArray(e.SpecularColor.value));
          var o = this;
          return (
            i.get(n).children.forEach(function (e) {
              var n = e.relationship;
              switch (n) {
                case "Bump":
                  r.bumpMap = o.getTexture(t, e.ID);
                  break;
                case "Maya|TEX_ao_map":
                  r.aoMap = o.getTexture(t, e.ID);
                  break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                  (r.map = o.getTexture(t, e.ID)), (r.map.encoding = E);
                  break;
                case "DisplacementColor":
                  r.displacementMap = o.getTexture(t, e.ID);
                  break;
                case "EmissiveColor":
                  (r.emissiveMap = o.getTexture(t, e.ID)),
                    (r.emissiveMap.encoding = E);
                  break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                  r.normalMap = o.getTexture(t, e.ID);
                  break;
                case "ReflectionColor":
                  (r.envMap = o.getTexture(t, e.ID)),
                    (r.envMap.mapping = 303),
                    (r.envMap.encoding = E);
                  break;
                case "SpecularColor":
                  (r.specularMap = o.getTexture(t, e.ID)),
                    (r.specularMap.encoding = E);
                  break;
                case "TransparentColor":
                case "TransparencyFactor":
                  (r.alphaMap = o.getTexture(t, e.ID)), (r.transparent = !0);
                  break;
                default:
                  console.warn(
                    "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
                    n
                  );
              }
            }),
            r
          );
        },
        getTexture: function (t, n) {
          return (
            "LayeredTexture" in e.Objects &&
              n in e.Objects.LayeredTexture &&
              (console.warn(
                "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
              ),
              (n = i.get(n).children[0].ID)),
            t.get(n)
          );
        },
        parseDeformers: function () {
          var t = {},
            n = {};
          if ("Deformer" in e.Objects) {
            var r = e.Objects.Deformer;
            for (var o in r) {
              var s = r[o],
                a = i.get(parseInt(o));
              if ("Skin" === s.attrType) {
                var c = this.parseSkeleton(a, r);
                (c.ID = o),
                  a.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
                    ),
                  (c.geometryID = a.parents[0].ID),
                  (t[o] = c);
              } else if ("BlendShape" === s.attrType) {
                var l = { id: o };
                (l.rawTargets = this.parseMorphTargets(a, r)),
                  (l.id = o),
                  a.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
                    ),
                  (n[o] = l);
              }
            }
          }
          return { skeletons: t, morphTargets: n };
        },
        parseSkeleton: function (e, t) {
          var n = [];
          return (
            e.children.forEach(function (e) {
              var i = t[e.ID];
              if ("Cluster" === i.attrType) {
                var r = {
                  ID: e.ID,
                  indices: [],
                  weights: [],
                  transformLink: new xe().fromArray(i.TransformLink.a),
                };
                "Indexes" in i &&
                  ((r.indices = i.Indexes.a), (r.weights = i.Weights.a)),
                  n.push(r);
              }
            }),
            { rawBones: n, bones: [] }
          );
        },
        parseMorphTargets: function (e, t) {
          for (var n = [], r = 0; r < e.children.length; r++) {
            var o = e.children[r],
              s = t[o.ID],
              a = {
                name: s.attrName,
                initialWeight: s.DeformPercent,
                id: s.id,
                fullWeights: s.FullWeights.a,
              };
            if ("BlendShapeChannel" !== s.attrType) return;
            (a.geoID = i.get(parseInt(o.ID)).children.filter(function (e) {
              return void 0 === e.relationship;
            })[0].ID),
              n.push(a);
          }
          return n;
        },
        parseScene: function (t, n, o) {
          r = new Tr();
          var s = this.parseModels(t.skeletons, n, o),
            a = e.Objects.Model,
            l = this;
          s.forEach(function (e) {
            var t = a[e.ID];
            l.setLookAtProperties(e, t),
              i.get(e.ID).parents.forEach(function (t) {
                var n = s.get(t.ID);
                void 0 !== n && n.add(e);
              }),
              null === e.parent && r.add(e);
          }),
            this.bindSkeleton(t.skeletons, n, s),
            this.createAmbientLight(),
            this.setupMorphMaterials(),
            r.traverse(function (e) {
              if (e.userData.transformData) {
                e.parent &&
                  (e.userData.transformData.parentMatrixWorld =
                    e.parent.matrix);
                var t = x(e.userData.transformData);
                e.applyMatrix4(t);
              }
            });
          var h = new c().parse();
          1 === r.children.length &&
            r.children[0].isGroup &&
            ((r.children[0].animations = h), (r = r.children[0])),
            (r.animations = h);
        },
        parseModels: function (t, n, r) {
          var o = new Map(),
            s = e.Objects.Model;
          for (var a in s) {
            var c = parseInt(a),
              l = s[a],
              h = i.get(c),
              u = this.buildSkeleton(h, t, c, l.attrName);
            if (!u) {
              switch (l.attrType) {
                case "Camera":
                  u = this.createCamera(h);
                  break;
                case "Light":
                  u = this.createLight(h);
                  break;
                case "Mesh":
                  u = this.createMesh(h, n, r);
                  break;
                case "NurbsCurve":
                  u = this.createCurve(h, n);
                  break;
                case "LimbNode":
                case "Root":
                  u = new co();
                  break;
                default:
                  u = new Tr();
              }
              (u.name = l.attrName ? bc.sanitizeNodeName(l.attrName) : ""),
                (u.ID = c);
            }
            this.getTransformData(u, l), o.set(c, u);
          }
          return o;
        },
        buildSkeleton: function (e, t, n, i) {
          var r = null;
          return (
            e.parents.forEach(function (e) {
              for (var o in t) {
                var s = t[o];
                s.rawBones.forEach(function (t, o) {
                  if (t.ID === e.ID) {
                    var a = r;
                    (r = new co()).matrixWorld.copy(t.transformLink),
                      (r.name = i ? bc.sanitizeNodeName(i) : ""),
                      (r.ID = n),
                      (s.bones[o] = r),
                      null !== a && r.add(a);
                  }
                });
              }
            }),
            r
          );
        },
        createCamera: function (t) {
          var n, i;
          if (
            (t.children.forEach(function (t) {
              var n = e.Objects.NodeAttribute[t.ID];
              void 0 !== n && (i = n);
            }),
            void 0 === i)
          )
            n = new je();
          else {
            var r = 0;
            void 0 !== i.CameraProjectionType &&
              1 === i.CameraProjectionType.value &&
              (r = 1);
            var o = 1;
            void 0 !== i.NearPlane && (o = i.NearPlane.value / 1e3);
            var s = 1e3;
            void 0 !== i.FarPlane && (s = i.FarPlane.value / 1e3);
            var a = window.innerWidth,
              c = window.innerHeight;
            void 0 !== i.AspectWidth &&
              void 0 !== i.AspectHeight &&
              ((a = i.AspectWidth.value), (c = i.AspectHeight.value));
            var l = a / c,
              h = 45;
            void 0 !== i.FieldOfView && (h = i.FieldOfView.value);
            var u = i.FocalLength ? i.FocalLength.value : null;
            switch (r) {
              case 0:
                (n = new mn(h, l, o, s)), null !== u && n.setFocalLength(u);
                break;
              case 1:
                n = new Ba(-a / 2, a / 2, c / 2, -c / 2, o, s);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + r + "."),
                  (n = new je());
            }
          }
          return n;
        },
        createLight: function (t) {
          var n, i;
          if (
            (t.children.forEach(function (t) {
              var n = e.Objects.NodeAttribute[t.ID];
              void 0 !== n && (i = n);
            }),
            void 0 === i)
          )
            n = new je();
          else {
            var r;
            r = void 0 === i.LightType ? 0 : i.LightType.value;
            var o = 16777215;
            void 0 !== i.Color && (o = new dt().fromArray(i.Color.value));
            var s = void 0 === i.Intensity ? 1 : i.Intensity.value / 100;
            void 0 !== i.CastLightOnObject &&
              0 === i.CastLightOnObject.value &&
              (s = 0);
            var a = 0;
            switch (
              (void 0 !== i.FarAttenuationEnd &&
                (a =
                  void 0 !== i.EnableFarAttenuation &&
                  0 === i.EnableFarAttenuation.value
                    ? 0
                    : i.FarAttenuationEnd.value),
              r)
            ) {
              case 0:
                n = new ka(o, s, a, 1);
                break;
              case 1:
                n = new Ha(o, s);
                break;
              case 2:
                var c = Math.PI / 3;
                void 0 !== i.InnerAngle && (c = I.degToRad(i.InnerAngle.value));
                var l = 0;
                void 0 !== i.OuterAngle &&
                  ((l = I.degToRad(i.OuterAngle.value)), (l = Math.max(l, 1))),
                  (n = new Fa(o, s, a, c, l, 1));
                break;
              default:
                console.warn(
                  "THREE.FBXLoader: Unknown light type " +
                    i.LightType.value +
                    ", defaulting to a PointLight."
                ),
                  (n = new ka(o, s));
            }
            void 0 !== i.CastShadows &&
              1 === i.CastShadows.value &&
              (n.castShadow = !0);
          }
          return n;
        },
        createMesh: function (e, t, n) {
          var i,
            r = null,
            o = null,
            s = [];
          return (
            e.children.forEach(function (e) {
              t.has(e.ID) && (r = t.get(e.ID)),
                n.has(e.ID) && s.push(n.get(e.ID));
            }),
            s.length > 1
              ? (o = s)
              : s.length > 0
              ? (o = s[0])
              : ((o = new Rs({ color: 13421772 })), s.push(o)),
            "color" in r.attributes &&
              s.forEach(function (e) {
                e.vertexColors = !0;
              }),
            r.FBX_Deformer
              ? (s.forEach(function (e) {
                  e.skinning = !0;
                }),
                (i = new ao(r, o)).normalizeSkinWeights())
              : (i = new sn(r, o)),
            i
          );
        },
        createCurve: function (e, t) {
          return new So(
            e.children.reduce(function (e, n) {
              return t.has(n.ID) && (e = t.get(n.ID)), e;
            }, null),
            new yo({ color: 3342591, linewidth: 1 })
          );
        },
        getTransformData: function (e, t) {
          var n = {};
          "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)),
            (n.eulerOrder =
              "RotationOrder" in t ? _(t.RotationOrder.value) : "ZYX"),
            "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value),
            "PreRotation" in t && (n.preRotation = t.PreRotation.value),
            "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value),
            "PostRotation" in t && (n.postRotation = t.PostRotation.value),
            "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value),
            "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value),
            "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value),
            "RotationOffset" in t &&
              (n.rotationOffset = t.RotationOffset.value),
            "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value),
            (e.userData.transformData = n);
        },
        setLookAtProperties: function (t, n) {
          "LookAtProperty" in n &&
            i.get(t.ID).children.forEach(function (n) {
              if ("LookAtProperty" === n.relationship) {
                var i = e.Objects.Model[n.ID];
                if ("Lcl_Translation" in i) {
                  var o = i.Lcl_Translation.value;
                  void 0 !== t.target
                    ? (t.target.position.fromArray(o), r.add(t.target))
                    : t.lookAt(new W().fromArray(o));
                }
              }
            });
        },
        bindSkeleton: function (e, t, n) {
          var r = this.parsePoseNodes();
          for (var o in e) {
            var s = e[o];
            i.get(parseInt(s.ID)).parents.forEach(function (e) {
              if (t.has(e.ID)) {
                var o = e.ID;
                i.get(o).parents.forEach(function (e) {
                  n.has(e.ID) && n.get(e.ID).bind(new uo(s.bones), r[e.ID]);
                });
              }
            });
          }
        },
        parsePoseNodes: function () {
          var t = {};
          if ("Pose" in e.Objects) {
            var n = e.Objects.Pose;
            for (var i in n)
              if ("BindPose" === n[i].attrType) {
                var r = n[i].PoseNode;
                Array.isArray(r)
                  ? r.forEach(function (e) {
                      t[e.Node] = new xe().fromArray(e.Matrix.a);
                    })
                  : (t[r.Node] = new xe().fromArray(r.Matrix.a));
              }
          }
          return t;
        },
        createAmbientLight: function () {
          if ("GlobalSettings" in e && "AmbientColor" in e.GlobalSettings) {
            var t = e.GlobalSettings.AmbientColor.value,
              n = t[0],
              i = t[1],
              o = t[2];
            if (0 !== n || 0 !== i || 0 !== o) {
              var s = new dt(n, i, o);
              r.add(new Ga(s, 1));
            }
          }
        },
        setupMorphMaterials: function () {
          var e = this;
          r.traverse(function (t) {
            t.isMesh &&
              t.geometry.morphAttributes.position &&
              t.geometry.morphAttributes.position.length &&
              (Array.isArray(t.material)
                ? t.material.forEach(function (n, i) {
                    e.setupMorphMaterial(t, n, i);
                  })
                : e.setupMorphMaterial(t, t.material));
          });
        },
        setupMorphMaterial: function (e, t, n) {
          var i = e.uuid,
            o = t.uuid,
            s = !1;
          if (
            (r.traverse(function (e) {
              e.isMesh &&
                (Array.isArray(e.material)
                  ? e.material.forEach(function (t) {
                      t.uuid === o && e.uuid !== i && (s = !0);
                    })
                  : e.material.uuid === o && e.uuid !== i && (s = !0));
            }),
            !0 === s)
          ) {
            var a = t.clone();
            (a.morphTargets = !0),
              void 0 === n ? (e.material = a) : (e.material[n] = a);
          } else t.morphTargets = !0;
        },
      }),
      (a.prototype = {
        constructor: a,
        parse: function (t) {
          var n = new Map();
          if ("Geometry" in e.Objects) {
            var r = e.Objects.Geometry;
            for (var o in r) {
              var s = i.get(parseInt(o)),
                a = this.parseGeometry(s, r[o], t);
              n.set(parseInt(o), a);
            }
          }
          return n;
        },
        parseGeometry: function (e, t, n) {
          switch (t.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(e, t, n);
            case "NurbsCurve":
              return this.parseNurbsGeometry(t);
          }
        },
        parseMeshGeometry: function (t, n, i) {
          var r = i.skeletons,
            o = [],
            s = t.parents.map(function (t) {
              return e.Objects.Model[t.ID];
            });
          if (0 !== s.length) {
            var a = t.children.reduce(function (e, t) {
              return void 0 !== r[t.ID] && (e = r[t.ID]), e;
            }, null);
            t.children.forEach(function (e) {
              void 0 !== i.morphTargets[e.ID] && o.push(i.morphTargets[e.ID]);
            });
            var c = s[0],
              l = {};
            "RotationOrder" in c && (l.eulerOrder = _(c.RotationOrder.value)),
              "InheritType" in c &&
                (l.inheritType = parseInt(c.InheritType.value)),
              "GeometricTranslation" in c &&
                (l.translation = c.GeometricTranslation.value),
              "GeometricRotation" in c &&
                (l.rotation = c.GeometricRotation.value),
              "GeometricScaling" in c && (l.scale = c.GeometricScaling.value);
            var h = x(l);
            return this.genGeometry(n, a, o, h);
          }
        },
        genGeometry: function (e, t, n, i) {
          var r = new Ht();
          e.attrName && (r.name = e.attrName);
          var o = this.parseGeoNode(e, t),
            s = this.genBuffers(o),
            a = new Lt(s.vertex, 3);
          if (
            (a.applyMatrix4(i),
            r.setAttribute("position", a),
            s.colors.length > 0 && r.setAttribute("color", new Lt(s.colors, 3)),
            t &&
              (r.setAttribute("skinIndex", new St(s.weightsIndices, 4)),
              r.setAttribute("skinWeight", new Lt(s.vertexWeights, 4)),
              (r.FBX_Deformer = t)),
            s.normal.length > 0)
          ) {
            var c = new D().getNormalMatrix(i),
              l = new Lt(s.normal, 3);
            l.applyNormalMatrix(c), r.setAttribute("normal", l);
          }
          if (
            (s.uvs.forEach(function (e, t) {
              var n = "uv" + (t + 1).toString();
              0 === t && (n = "uv"), r.setAttribute(n, new Lt(s.uvs[t], 2));
            }),
            o.material && "AllSame" !== o.material.mappingType)
          ) {
            var h = s.materialIndex[0],
              u = 0;
            if (
              (s.materialIndex.forEach(function (e, t) {
                e !== h && (r.addGroup(u, t - u, h), (h = e), (u = t));
              }),
              r.groups.length > 0)
            ) {
              var d = r.groups[r.groups.length - 1],
                p = d.start + d.count;
              p !== s.materialIndex.length &&
                r.addGroup(p, s.materialIndex.length - p, h);
            }
            0 === r.groups.length &&
              r.addGroup(0, s.materialIndex.length, s.materialIndex[0]);
          }
          return this.addMorphTargets(r, e, n, i), r;
        },
        parseGeoNode: function (e, t) {
          var n = {};
          if (
            ((n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : []),
            (n.vertexIndices =
              void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : []),
            e.LayerElementColor &&
              (n.color = this.parseVertexColors(e.LayerElementColor[0])),
            e.LayerElementMaterial &&
              (n.material = this.parseMaterialIndices(
                e.LayerElementMaterial[0]
              )),
            e.LayerElementNormal &&
              (n.normal = this.parseNormals(e.LayerElementNormal[0])),
            e.LayerElementUV)
          ) {
            n.uv = [];
            for (var i = 0; e.LayerElementUV[i]; )
              e.LayerElementUV[i].UV &&
                n.uv.push(this.parseUVs(e.LayerElementUV[i])),
                i++;
          }
          return (
            (n.weightTable = {}),
            null !== t &&
              ((n.skeleton = t),
              t.rawBones.forEach(function (e, t) {
                e.indices.forEach(function (i, r) {
                  void 0 === n.weightTable[i] && (n.weightTable[i] = []),
                    n.weightTable[i].push({ id: t, weight: e.weights[r] });
                });
              })),
            n
          );
        },
        genBuffers: function (e) {
          var t = {
              vertex: [],
              normal: [],
              colors: [],
              uvs: [],
              materialIndex: [],
              vertexWeights: [],
              weightsIndices: [],
            },
            n = 0,
            i = 0,
            r = !1,
            o = [],
            s = [],
            a = [],
            c = [],
            l = [],
            h = [],
            u = this;
          return (
            e.vertexIndices.forEach(function (d, p) {
              var f = !1;
              d < 0 && ((d ^= -1), (f = !0));
              var m = [],
                v = [];
              if ((o.push(3 * d, 3 * d + 1, 3 * d + 2), e.color)) {
                var y = g(p, n, d, e.color);
                a.push(y[0], y[1], y[2]);
              }
              if (e.skeleton) {
                if (
                  (void 0 !== e.weightTable[d] &&
                    e.weightTable[d].forEach(function (e) {
                      v.push(e.weight), m.push(e.id);
                    }),
                  v.length > 4)
                ) {
                  r ||
                    (console.warn(
                      "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
                    ),
                    (r = !0));
                  var x = [0, 0, 0, 0],
                    _ = [0, 0, 0, 0];
                  v.forEach(function (e, t) {
                    var n = e,
                      i = m[t];
                    _.forEach(function (e, t, r) {
                      if (n > e) {
                        (r[t] = n), (n = e);
                        var o = x[t];
                        (x[t] = i), (i = o);
                      }
                    });
                  }),
                    (m = x),
                    (v = _);
                }
                for (; v.length < 4; ) v.push(0), m.push(0);
                for (var b = 0; b < 4; ++b) l.push(v[b]), h.push(m[b]);
              }
              if (
                (e.normal &&
                  ((y = g(p, n, d, e.normal)), s.push(y[0], y[1], y[2])),
                e.material && "AllSame" !== e.material.mappingType)
              )
                var w = g(p, n, d, e.material)[0];
              e.uv &&
                e.uv.forEach(function (e, t) {
                  var i = g(p, n, d, e);
                  void 0 === c[t] && (c[t] = []),
                    c[t].push(i[0]),
                    c[t].push(i[1]);
                }),
                i++,
                f &&
                  (u.genFace(t, e, o, w, s, a, c, l, h, i),
                  n++,
                  (i = 0),
                  (o = []),
                  (s = []),
                  (a = []),
                  (c = []),
                  (l = []),
                  (h = []));
            }),
            t
          );
        },
        genFace: function (e, t, n, i, r, o, s, a, c, l) {
          for (var h = 2; h < l; h++)
            e.vertex.push(t.vertexPositions[n[0]]),
              e.vertex.push(t.vertexPositions[n[1]]),
              e.vertex.push(t.vertexPositions[n[2]]),
              e.vertex.push(t.vertexPositions[n[3 * (h - 1)]]),
              e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 2]]),
              e.vertex.push(t.vertexPositions[n[3 * h]]),
              e.vertex.push(t.vertexPositions[n[3 * h + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * h + 2]]),
              t.skeleton &&
                (e.vertexWeights.push(a[0]),
                e.vertexWeights.push(a[1]),
                e.vertexWeights.push(a[2]),
                e.vertexWeights.push(a[3]),
                e.vertexWeights.push(a[4 * (h - 1)]),
                e.vertexWeights.push(a[4 * (h - 1) + 1]),
                e.vertexWeights.push(a[4 * (h - 1) + 2]),
                e.vertexWeights.push(a[4 * (h - 1) + 3]),
                e.vertexWeights.push(a[4 * h]),
                e.vertexWeights.push(a[4 * h + 1]),
                e.vertexWeights.push(a[4 * h + 2]),
                e.vertexWeights.push(a[4 * h + 3]),
                e.weightsIndices.push(c[0]),
                e.weightsIndices.push(c[1]),
                e.weightsIndices.push(c[2]),
                e.weightsIndices.push(c[3]),
                e.weightsIndices.push(c[4 * (h - 1)]),
                e.weightsIndices.push(c[4 * (h - 1) + 1]),
                e.weightsIndices.push(c[4 * (h - 1) + 2]),
                e.weightsIndices.push(c[4 * (h - 1) + 3]),
                e.weightsIndices.push(c[4 * h]),
                e.weightsIndices.push(c[4 * h + 1]),
                e.weightsIndices.push(c[4 * h + 2]),
                e.weightsIndices.push(c[4 * h + 3])),
              t.color &&
                (e.colors.push(o[0]),
                e.colors.push(o[1]),
                e.colors.push(o[2]),
                e.colors.push(o[3 * (h - 1)]),
                e.colors.push(o[3 * (h - 1) + 1]),
                e.colors.push(o[3 * (h - 1) + 2]),
                e.colors.push(o[3 * h]),
                e.colors.push(o[3 * h + 1]),
                e.colors.push(o[3 * h + 2])),
              t.material &&
                "AllSame" !== t.material.mappingType &&
                (e.materialIndex.push(i),
                e.materialIndex.push(i),
                e.materialIndex.push(i)),
              t.normal &&
                (e.normal.push(r[0]),
                e.normal.push(r[1]),
                e.normal.push(r[2]),
                e.normal.push(r[3 * (h - 1)]),
                e.normal.push(r[3 * (h - 1) + 1]),
                e.normal.push(r[3 * (h - 1) + 2]),
                e.normal.push(r[3 * h]),
                e.normal.push(r[3 * h + 1]),
                e.normal.push(r[3 * h + 2])),
              t.uv &&
                t.uv.forEach(function (t, n) {
                  void 0 === e.uvs[n] && (e.uvs[n] = []),
                    e.uvs[n].push(s[n][0]),
                    e.uvs[n].push(s[n][1]),
                    e.uvs[n].push(s[n][2 * (h - 1)]),
                    e.uvs[n].push(s[n][2 * (h - 1) + 1]),
                    e.uvs[n].push(s[n][2 * h]),
                    e.uvs[n].push(s[n][2 * h + 1]);
                });
        },
        addMorphTargets: function (t, n, i, r) {
          if (0 !== i.length) {
            (t.morphTargetsRelative = !0), (t.morphAttributes.position = []);
            var o = this;
            i.forEach(function (i) {
              i.rawTargets.forEach(function (i) {
                var s = e.Objects.Geometry[i.geoID];
                void 0 !== s && o.genMorphGeometry(t, n, s, r, i.name);
              });
            });
          }
        },
        genMorphGeometry: function (e, t, n, i, r) {
          for (
            var o =
                void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
              s = void 0 !== n.Vertices ? n.Vertices.a : [],
              a = void 0 !== n.Indexes ? n.Indexes.a : [],
              c = 3 * e.attributes.position.count,
              l = new Float32Array(c),
              h = 0;
            h < a.length;
            h++
          ) {
            var u = 3 * a[h];
            (l[u] = s[3 * h]),
              (l[u + 1] = s[3 * h + 1]),
              (l[u + 2] = s[3 * h + 2]);
          }
          var d = { vertexIndices: o, vertexPositions: l },
            p = new Lt(this.genBuffers(d).vertex, 3);
          (p.name = r || n.attrName),
            p.applyMatrix4(i),
            e.morphAttributes.position.push(p);
        },
        parseNormals: function (e) {
          var t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.Normals.a,
            r = [];
          return (
            "IndexToDirect" === n &&
              ("NormalIndex" in e
                ? (r = e.NormalIndex.a)
                : "NormalsIndex" in e && (r = e.NormalsIndex.a)),
            {
              dataSize: 3,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        },
        parseUVs: function (e) {
          var t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.UV.a,
            r = [];
          return (
            "IndexToDirect" === n && (r = e.UVIndex.a),
            {
              dataSize: 2,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        },
        parseVertexColors: function (e) {
          var t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.Colors.a,
            r = [];
          return (
            "IndexToDirect" === n && (r = e.ColorIndex.a),
            {
              dataSize: 4,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        },
        parseMaterialIndices: function (e) {
          var t = e.MappingInformationType,
            n = e.ReferenceInformationType;
          if ("NoMappingInformation" === t)
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType: n,
            };
          for (var i = e.Materials.a, r = [], o = 0; o < i.length; ++o)
            r.push(o);
          return {
            dataSize: 1,
            buffer: i,
            indices: r,
            mappingType: t,
            referenceType: n,
          };
        },
        parseNurbsGeometry: function (e) {
          if (void 0 === uu)
            return (
              console.error(
                "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
              ),
              new Ht()
            );
          var t = parseInt(e.Order);
          if (isNaN(t))
            return (
              console.error(
                "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
                e.Order,
                e.id
              ),
              new Ht()
            );
          for (
            var n,
              i,
              r = t - 1,
              o = e.KnotVector.a,
              s = [],
              a = e.Points.a,
              c = 0,
              l = a.length;
            c < l;
            c += 4
          )
            s.push(new H().fromArray(a, c));
          if ("Closed" === e.Form) s.push(s[0]);
          else if ("Periodic" === e.Form)
            for (n = r, i = o.length - 1 - n, c = 0; c < r; ++c) s.push(s[c]);
          var h = new uu(r, o, s, n, i).getPoints(7 * s.length),
            u = new Float32Array(3 * h.length);
          h.forEach(function (e, t) {
            e.toArray(u, 3 * t);
          });
          var d = new Ht();
          return d.setAttribute("position", new xt(u, 3)), d;
        },
      }),
      (c.prototype = {
        constructor: c,
        parse: function () {
          var e = [],
            t = this.parseClips();
          if (void 0 !== t)
            for (var n in t) {
              var i = t[n],
                r = this.addClip(i);
              e.push(r);
            }
          return e;
        },
        parseClips: function () {
          if (void 0 !== e.Objects.AnimationCurve) {
            var t = this.parseAnimationCurveNodes();
            this.parseAnimationCurves(t);
            var n = this.parseAnimationLayers(t);
            return this.parseAnimStacks(n);
          }
        },
        parseAnimationCurveNodes: function () {
          var t = e.Objects.AnimationCurveNode,
            n = new Map();
          for (var i in t) {
            var r = t[i];
            if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
              var o = { id: r.id, attr: r.attrName, curves: {} };
              n.set(o.id, o);
            }
          }
          return n;
        },
        parseAnimationCurves: function (t) {
          var n = e.Objects.AnimationCurve;
          for (var r in n) {
            var o = {
                id: n[r].id,
                times: n[r].KeyTime.a.map(f),
                values: n[r].KeyValueFloat.a,
              },
              s = i.get(o.id);
            if (void 0 !== s) {
              var a = s.parents[0].ID,
                c = s.parents[0].relationship;
              c.match(/X/)
                ? (t.get(a).curves.x = o)
                : c.match(/Y/)
                ? (t.get(a).curves.y = o)
                : c.match(/Z/)
                ? (t.get(a).curves.z = o)
                : c.match(/d|DeformPercent/) &&
                  t.has(a) &&
                  (t.get(a).curves.morph = o);
            }
          }
        },
        parseAnimationLayers: function (t) {
          var n = e.Objects.AnimationLayer,
            o = new Map();
          for (var s in n) {
            var a = [],
              c = i.get(parseInt(s));
            void 0 !== c &&
              (c.children.forEach(function (n, o) {
                if (t.has(n.ID)) {
                  var s = t.get(n.ID);
                  if (
                    void 0 !== s.curves.x ||
                    void 0 !== s.curves.y ||
                    void 0 !== s.curves.z
                  ) {
                    if (
                      void 0 === a[o] &&
                      void 0 !==
                        (p = i.get(n.ID).parents.filter(function (e) {
                          return void 0 !== e.relationship;
                        })[0].ID)
                    ) {
                      if (void 0 === (l = e.Objects.Model[p.toString()]))
                        return void console.warn(
                          "THREE.FBXLoader: Encountered a unused curve.",
                          n
                        );
                      var c = {
                        modelName: l.attrName
                          ? bc.sanitizeNodeName(l.attrName)
                          : "",
                        ID: l.id,
                        initialPosition: [0, 0, 0],
                        initialRotation: [0, 0, 0],
                        initialScale: [1, 1, 1],
                      };
                      r.traverse(function (e) {
                        e.ID === l.id &&
                          ((c.transform = e.matrix),
                          e.userData.transformData &&
                            (c.eulerOrder =
                              e.userData.transformData.eulerOrder));
                      }),
                        c.transform || (c.transform = new xe()),
                        "PreRotation" in l &&
                          (c.preRotation = l.PreRotation.value),
                        "PostRotation" in l &&
                          (c.postRotation = l.PostRotation.value),
                        (a[o] = c);
                    }
                    a[o] && (a[o][s.attr] = s);
                  } else if (void 0 !== s.curves.morph) {
                    if (void 0 === a[o]) {
                      var l,
                        h = i.get(n.ID).parents.filter(function (e) {
                          return void 0 !== e.relationship;
                        })[0].ID,
                        u = i.get(h).parents[0].ID,
                        d = i.get(u).parents[0].ID,
                        p = i.get(d).parents[0].ID;
                      (c = {
                        modelName: (l = e.Objects.Model[p]).attrName
                          ? bc.sanitizeNodeName(l.attrName)
                          : "",
                        morphName: e.Objects.Deformer[h].attrName,
                      }),
                        (a[o] = c);
                    }
                    a[o][s.attr] = s;
                  }
                }
              }),
              o.set(parseInt(s), a));
          }
          return o;
        },
        parseAnimStacks: function (t) {
          var n = e.Objects.AnimationStack,
            r = {};
          for (var o in n) {
            var s = i.get(parseInt(o)).children;
            s.length > 1 &&
              console.warn(
                "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
              );
            var a = t.get(s[0].ID);
            r[o] = { name: n[o].attrName, layer: a };
          }
          return r;
        },
        addClip: function (e) {
          var t = [],
            n = this;
          return (
            e.layer.forEach(function (e) {
              t = t.concat(n.generateTracks(e));
            }),
            new Zs(e.name, -1, t)
          );
        },
        generateTracks: function (e) {
          var t = [],
            n = new W(),
            i = new j(),
            r = new W();
          if (
            (e.transform && e.transform.decompose(n, i, r),
            (n = n.toArray()),
            (i = new Ae().setFromQuaternion(i, e.eulerOrder).toArray()),
            (r = r.toArray()),
            void 0 !== e.T && Object.keys(e.T.curves).length > 0)
          ) {
            var o = this.generateVectorTrack(
              e.modelName,
              e.T.curves,
              n,
              "position"
            );
            void 0 !== o && t.push(o);
          }
          if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
            var s = this.generateRotationTrack(
              e.modelName,
              e.R.curves,
              i,
              e.preRotation,
              e.postRotation,
              e.eulerOrder
            );
            void 0 !== s && t.push(s);
          }
          if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
            var a = this.generateVectorTrack(
              e.modelName,
              e.S.curves,
              r,
              "scale"
            );
            void 0 !== a && t.push(a);
          }
          if (void 0 !== e.DeformPercent) {
            var c = this.generateMorphTrack(e);
            void 0 !== c && t.push(c);
          }
          return t;
        },
        generateVectorTrack: function (e, t, n, i) {
          var r = this.getTimesForAllAxes(t);
          return new Ys(e + "." + i, r, this.getKeyframeTrackValues(r, t, n));
        },
        generateRotationTrack: function (e, t, n, i, r, o) {
          void 0 !== t.x &&
            (this.interpolateRotations(t.x),
            (t.x.values = t.x.values.map(I.degToRad))),
            void 0 !== t.y &&
              (this.interpolateRotations(t.y),
              (t.y.values = t.y.values.map(I.degToRad))),
            void 0 !== t.z &&
              (this.interpolateRotations(t.z),
              (t.z.values = t.z.values.map(I.degToRad)));
          var s = this.getTimesForAllAxes(t),
            a = this.getKeyframeTrackValues(s, t, n);
          void 0 !== i &&
            ((i = i.map(I.degToRad)).push(o),
            (i = new Ae().fromArray(i)),
            (i = new j().setFromEuler(i))),
            void 0 !== r &&
              ((r = r.map(I.degToRad)).push(o),
              (r = new Ae().fromArray(r)),
              (r = new j().setFromEuler(r).invert()));
          for (
            var c = new j(), l = new Ae(), h = [], u = 0;
            u < a.length;
            u += 3
          )
            l.set(a[u], a[u + 1], a[u + 2], o),
              c.setFromEuler(l),
              void 0 !== i && c.premultiply(i),
              void 0 !== r && c.multiply(r),
              c.toArray(h, (u / 3) * 4);
          return new Xs(e + ".quaternion", s, h);
        },
        generateMorphTrack: function (e) {
          var t = e.DeformPercent.curves.morph,
            n = t.values.map(function (e) {
              return e / 100;
            }),
            i = r.getObjectByName(e.modelName).morphTargetDictionary[
              e.morphName
            ];
          return new js(
            e.modelName + ".morphTargetInfluences[" + i + "]",
            t.times,
            n
          );
        },
        getTimesForAllAxes: function (e) {
          var t = [];
          if (
            (void 0 !== e.x && (t = t.concat(e.x.times)),
            void 0 !== e.y && (t = t.concat(e.y.times)),
            void 0 !== e.z && (t = t.concat(e.z.times)),
            (t = t.sort(function (e, t) {
              return e - t;
            })).length > 1)
          ) {
            for (var n = 1, i = t[0], r = 1; r < t.length; r++) {
              var o = t[r];
              o !== i && ((t[n] = o), (i = o), n++);
            }
            t = t.slice(0, n);
          }
          return t;
        },
        getKeyframeTrackValues: function (e, t, n) {
          var i = n,
            r = [],
            o = -1,
            s = -1,
            a = -1;
          return (
            e.forEach(function (e) {
              if (
                (t.x && (o = t.x.times.indexOf(e)),
                t.y && (s = t.y.times.indexOf(e)),
                t.z && (a = t.z.times.indexOf(e)),
                -1 !== o)
              ) {
                var n = t.x.values[o];
                r.push(n), (i[0] = n);
              } else r.push(i[0]);
              if (-1 !== s) {
                var c = t.y.values[s];
                r.push(c), (i[1] = c);
              } else r.push(i[1]);
              if (-1 !== a) {
                var l = t.z.values[a];
                r.push(l), (i[2] = l);
              } else r.push(i[2]);
            }),
            r
          );
        },
        interpolateRotations: function (e) {
          for (var t = 1; t < e.values.length; t++) {
            var n = e.values[t - 1],
              i = e.values[t] - n,
              r = Math.abs(i);
            if (r >= 180) {
              for (
                var o = r / 180,
                  s = i / o,
                  a = n + s,
                  c = e.times[t - 1],
                  l = (e.times[t] - c) / o,
                  h = c + l,
                  u = [],
                  d = [];
                h < e.times[t];

              )
                u.push(h), (h += l), d.push(a), (a += s);
              (e.times = M(e.times, t, u)), (e.values = M(e.values, t, d));
            }
          }
        },
      }),
      (l.prototype = {
        constructor: l,
        getPrevNode: function () {
          return this.nodeStack[this.currentIndent - 2];
        },
        getCurrentNode: function () {
          return this.nodeStack[this.currentIndent - 1];
        },
        getCurrentProp: function () {
          return this.currentProp;
        },
        pushStack: function (e) {
          this.nodeStack.push(e), (this.currentIndent += 1);
        },
        popStack: function () {
          this.nodeStack.pop(), (this.currentIndent -= 1);
        },
        setCurrentProp: function (e, t) {
          (this.currentProp = e), (this.currentPropName = t);
        },
        parse: function (e) {
          (this.currentIndent = 0),
            (this.allNodes = new d()),
            (this.nodeStack = []),
            (this.currentProp = []),
            (this.currentPropName = "");
          var t = this,
            n = e.split(/[\r\n]+/);
          return (
            n.forEach(function (e, i) {
              var r = e.match(/^[\s\t]*;/),
                o = e.match(/^[\s\t]*$/);
              if (!r && !o) {
                var s = e.match(
                    "^\\t{" + t.currentIndent + "}(\\w+):(.*){",
                    ""
                  ),
                  a = e.match(
                    "^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"
                  ),
                  c = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
                s
                  ? t.parseNodeBegin(e, s)
                  : a
                  ? t.parseNodeProperty(e, a, n[++i])
                  : c
                  ? t.popStack()
                  : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
              }
            }),
            this.allNodes
          );
        },
        parseNodeBegin: function (e, t) {
          var n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            i = t[2].split(",").map(function (e) {
              return e.trim().replace(/^"/, "").replace(/"$/, "");
            }),
            r = { name: n },
            o = this.parseNodeAttr(i),
            s = this.getCurrentNode();
          0 === this.currentIndent
            ? this.allNodes.add(n, r)
            : n in s
            ? ("PoseNode" === n
                ? s.PoseNode.push(r)
                : void 0 !== s[n].id && ((s[n] = {}), (s[n][s[n].id] = s[n])),
              "" !== o.id && (s[n][o.id] = r))
            : "number" == typeof o.id
            ? ((s[n] = {}), (s[n][o.id] = r))
            : "Properties70" !== n && (s[n] = "PoseNode" === n ? [r] : r),
            "number" == typeof o.id && (r.id = o.id),
            "" !== o.name && (r.attrName = o.name),
            "" !== o.type && (r.attrType = o.type),
            this.pushStack(r);
        },
        parseNodeAttr: function (e) {
          var t = e[0];
          "" !== e[0] && ((t = parseInt(e[0])), isNaN(t) && (t = e[0]));
          var n = "",
            i = "";
          return (
            e.length > 1 && ((n = e[1].replace(/^(\w+)::/, "")), (i = e[2])),
            { id: t, name: n, type: i }
          );
        },
        parseNodeProperty: function (e, t, n) {
          var i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
            r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
          "Content" === i &&
            "," === r &&
            (r = n.replace(/"/g, "").replace(/,$/, "").trim());
          var o = this.getCurrentNode();
          if ("Properties70" !== o.name) {
            if ("C" === i) {
              var s = r.split(",").slice(1),
                a = parseInt(s[0]),
                c = parseInt(s[1]),
                l = r.split(",").slice(3);
              (i = "connections"),
                (function (e, t) {
                  for (var n = 0, i = e.length, r = t.length; n < r; n++, i++)
                    e[i] = t[n];
                })(
                  (r = [a, c]),
                  (l = l.map(function (e) {
                    return e.trim().replace(/^"/, "");
                  }))
                ),
                void 0 === o[i] && (o[i] = []);
            }
            "Node" === i && (o.id = r),
              i in o && Array.isArray(o[i])
                ? o[i].push(r)
                : "a" !== i
                ? (o[i] = r)
                : (o.a = r),
              this.setCurrentProp(o, i),
              "a" === i && "," !== r.slice(-1) && (o.a = b(r));
          } else this.parseNodeSpecialProperty(e, i, r);
        },
        parseNodePropertyContinued: function (e) {
          var t = this.getCurrentNode();
          (t.a += e), "," !== e.slice(-1) && (t.a = b(t.a));
        },
        parseNodeSpecialProperty: function (e, t, n) {
          var i = n.split('",').map(function (e) {
              return e.trim().replace(/^\"/, "").replace(/\s/, "_");
            }),
            r = i[0],
            o = i[1],
            s = i[2],
            a = i[3],
            c = i[4];
          switch (o) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              c = parseFloat(c);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              c = b(c);
          }
          (this.getPrevNode()[r] = { type: o, type2: s, flag: a, value: c }),
            this.setCurrentProp(this.getPrevNode(), r);
        },
      }),
      (h.prototype = {
        constructor: h,
        parse: function (e) {
          var t = new u(e);
          t.skip(23);
          var n = t.getUint32();
          if (n < 6400)
            throw new Error(
              "THREE.FBXLoader: FBX version not supported, FileVersion: " + n
            );
          for (var i = new d(); !this.endOfContent(t); ) {
            var r = this.parseNode(t, n);
            null !== r && i.add(r.name, r);
          }
          return i;
        },
        endOfContent: function (e) {
          return e.size() % 16 == 0
            ? ((e.getOffset() + 160 + 16) & -16) >= e.size()
            : e.getOffset() + 160 + 16 >= e.size();
        },
        parseNode: function (e, t) {
          var n = {},
            i = t >= 7500 ? e.getUint64() : e.getUint32(),
            r = t >= 7500 ? e.getUint64() : e.getUint32();
          t >= 7500 ? e.getUint64() : e.getUint32();
          var o = e.getUint8(),
            s = e.getString(o);
          if (0 === i) return null;
          for (var a = [], c = 0; c < r; c++) a.push(this.parseProperty(e));
          var l = a.length > 0 ? a[0] : "",
            h = a.length > 1 ? a[1] : "",
            u = a.length > 2 ? a[2] : "";
          for (
            n.singleProperty = 1 === r && e.getOffset() === i;
            i > e.getOffset();

          ) {
            var d = this.parseNode(e, t);
            null !== d && this.parseSubNode(s, n, d);
          }
          return (
            (n.propertyList = a),
            "number" == typeof l && (n.id = l),
            "" !== h && (n.attrName = h),
            "" !== u && (n.attrType = u),
            "" !== s && (n.name = s),
            n
          );
        },
        parseSubNode: function (e, t, n) {
          if (!0 === n.singleProperty) {
            var i = n.propertyList[0];
            Array.isArray(i) ? ((t[n.name] = n), (n.a = i)) : (t[n.name] = i);
          } else if ("Connections" === e && "C" === n.name) {
            var r = [];
            n.propertyList.forEach(function (e, t) {
              0 !== t && r.push(e);
            }),
              void 0 === t.connections && (t.connections = []),
              t.connections.push(r);
          } else if ("Properties70" === n.name)
            Object.keys(n).forEach(function (e) {
              t[e] = n[e];
            });
          else if ("Properties70" === e && "P" === n.name) {
            var o,
              s = n.propertyList[0],
              a = n.propertyList[1],
              c = n.propertyList[2],
              l = n.propertyList[3];
            0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")),
              0 === a.indexOf("Lcl ") && (a = a.replace("Lcl ", "Lcl_")),
              (o =
                "Color" === a ||
                "ColorRGB" === a ||
                "Vector" === a ||
                "Vector3D" === a ||
                0 === a.indexOf("Lcl_")
                  ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]]
                  : n.propertyList[4]),
              (t[s] = { type: a, type2: c, flag: l, value: o });
          } else
            void 0 === t[n.name]
              ? "number" == typeof n.id
                ? ((t[n.name] = {}), (t[n.name][n.id] = n))
                : (t[n.name] = n)
              : "PoseNode" === n.name
              ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
                t[n.name].push(n))
              : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n);
        },
        parseProperty: function (e) {
          var t = e.getString(1);
          switch (t) {
            case "C":
              return e.getBoolean();
            case "D":
              return e.getFloat64();
            case "F":
              return e.getFloat32();
            case "I":
              return e.getInt32();
            case "L":
              return e.getInt64();
            case "R":
              var n = e.getUint32();
              return e.getArrayBuffer(n);
            case "S":
              return (n = e.getUint32()), e.getString(n);
            case "Y":
              return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              var i = e.getUint32(),
                r = e.getUint32(),
                o = e.getUint32();
              if (0 === r)
                switch (t) {
                  case "b":
                  case "c":
                    return e.getBooleanArray(i);
                  case "d":
                    return e.getFloat64Array(i);
                  case "f":
                    return e.getFloat32Array(i);
                  case "i":
                    return e.getInt32Array(i);
                  case "l":
                    return e.getInt64Array(i);
                }
              void 0 === lu &&
                console.error(
                  "THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js"
                );
              var s = new u(
                new lu(new Uint8Array(e.getArrayBuffer(o))).decompress().buffer
              );
              switch (t) {
                case "b":
                case "c":
                  return s.getBooleanArray(i);
                case "d":
                  return s.getFloat64Array(i);
                case "f":
                  return s.getFloat32Array(i);
                case "i":
                  return s.getInt32Array(i);
                case "l":
                  return s.getInt64Array(i);
              }
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + t);
          }
        },
      }),
      (u.prototype = {
        constructor: u,
        getOffset: function () {
          return this.offset;
        },
        size: function () {
          return this.dv.buffer.byteLength;
        },
        skip: function (e) {
          this.offset += e;
        },
        getBoolean: function () {
          return 1 == (1 & this.getUint8());
        },
        getBooleanArray: function (e) {
          for (var t = [], n = 0; n < e; n++) t.push(this.getBoolean());
          return t;
        },
        getUint8: function () {
          var e = this.dv.getUint8(this.offset);
          return (this.offset += 1), e;
        },
        getInt16: function () {
          var e = this.dv.getInt16(this.offset, this.littleEndian);
          return (this.offset += 2), e;
        },
        getInt32: function () {
          var e = this.dv.getInt32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        },
        getInt32Array: function (e) {
          for (var t = [], n = 0; n < e; n++) t.push(this.getInt32());
          return t;
        },
        getUint32: function () {
          var e = this.dv.getUint32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        },
        getInt64: function () {
          var e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            2147483648 & t
              ? ((t = 4294967295 & ~t),
                4294967295 == (e = 4294967295 & ~e) &&
                  (t = (t + 1) & 4294967295),
                -(4294967296 * t + (e = (e + 1) & 4294967295)))
              : 4294967296 * t + e
          );
        },
        getInt64Array: function (e) {
          for (var t = [], n = 0; n < e; n++) t.push(this.getInt64());
          return t;
        },
        getUint64: function () {
          var e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            4294967296 * t + e
          );
        },
        getFloat32: function () {
          var e = this.dv.getFloat32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        },
        getFloat32Array: function (e) {
          for (var t = [], n = 0; n < e; n++) t.push(this.getFloat32());
          return t;
        },
        getFloat64: function () {
          var e = this.dv.getFloat64(this.offset, this.littleEndian);
          return (this.offset += 8), e;
        },
        getFloat64Array: function (e) {
          for (var t = [], n = 0; n < e; n++) t.push(this.getFloat64());
          return t;
        },
        getArrayBuffer: function (e) {
          var t = this.dv.buffer.slice(this.offset, this.offset + e);
          return (this.offset += e), t;
        },
        getString: function (e) {
          for (var t = [], n = 0; n < e; n++) t[n] = this.getUint8();
          var i = t.indexOf(0);
          return i >= 0 && (t = t.slice(0, i)), qa(new Uint8Array(t));
        },
      }),
      (d.prototype = {
        constructor: d,
        add: function (e, t) {
          this[e] = t;
        },
      });
    var m = [];
    function g(e, t, n, i) {
      var r;
      switch (i.mappingType) {
        case "ByPolygonVertex":
          r = e;
          break;
        case "ByPolygon":
          r = t;
          break;
        case "ByVertice":
          r = n;
          break;
        case "AllSame":
          r = i.indices[0];
          break;
        default:
          console.warn(
            "THREE.FBXLoader: unknown attribute mapping type " + i.mappingType
          );
      }
      "IndexToDirect" === i.referenceType && (r = i.indices[r]);
      var o = r * i.dataSize,
        s = o + i.dataSize;
      return (function (e, t, n, i) {
        for (var r = n, o = 0; r < i; r++, o++) e[o] = t[r];
        return e;
      })(m, i.buffer, o, s);
    }
    var v = new Ae(),
      y = new W();
    function x(e) {
      var t,
        n = new xe(),
        i = new xe(),
        r = new xe(),
        o = new xe(),
        s = new xe(),
        a = new xe(),
        c = new xe(),
        l = new xe(),
        h = new xe(),
        u = new xe(),
        d = new xe(),
        p = e.inheritType ? e.inheritType : 0;
      e.translation && n.setPosition(y.fromArray(e.translation)),
        e.preRotation &&
          ((t = e.preRotation.map(I.degToRad)).push(e.eulerOrder),
          i.makeRotationFromEuler(v.fromArray(t))),
        e.rotation &&
          ((t = e.rotation.map(I.degToRad)).push(e.eulerOrder),
          r.makeRotationFromEuler(v.fromArray(t))),
        e.postRotation &&
          ((t = e.postRotation.map(I.degToRad)).push(e.eulerOrder),
          o.makeRotationFromEuler(v.fromArray(t))),
        e.scale && s.scale(y.fromArray(e.scale)),
        e.scalingOffset && c.setPosition(y.fromArray(e.scalingOffset)),
        e.scalingPivot && a.setPosition(y.fromArray(e.scalingPivot)),
        e.rotationOffset && l.setPosition(y.fromArray(e.rotationOffset)),
        e.rotationPivot && h.setPosition(y.fromArray(e.rotationPivot)),
        e.parentMatrixWorld && (u = e.parentMatrixWorld);
      var f = i.multiply(r).multiply(o),
        m = new xe();
      u.extractRotation(m), new xe().copyPosition(u);
      var g = new xe();
      g.copy(m).invert().multiply(u);
      var x = new xe();
      if (0 === p) x.copy(m).multiply(f).multiply(g).multiply(s);
      else if (1 === p) x.copy(m).multiply(g).multiply(f).multiply(s);
      else {
        var _ = new xe();
        _.copy(s).invert();
        var b = new xe().multiply(g).multiply(_);
        x.copy(m).multiply(f).multiply(b).multiply(s);
      }
      var w = new xe();
      w.copy(h).invert();
      var M = new xe();
      M.copy(a).invert();
      var S = new xe();
      S.copy(n)
        .multiply(l)
        .multiply(h)
        .multiply(i)
        .multiply(r)
        .multiply(o)
        .multiply(w)
        .multiply(c)
        .multiply(a)
        .multiply(s)
        .multiply(M);
      var E = new xe().copyPosition(S),
        T = new xe().copy(u).multiply(E);
      return d.copyPosition(T), new xe().multiply(d).multiply(x);
    }
    function _(e) {
      var t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
      return 6 === (e = e || 0)
        ? (console.warn(
            "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
          ),
          t[0])
        : t[e];
    }
    function b(e) {
      return e.split(",").map(function (e) {
        return parseFloat(e);
      });
    }
    function w(e, t, n) {
      return (
        void 0 === t && (t = 0),
        void 0 === n && (n = e.byteLength),
        qa(new Uint8Array(e, t, n))
      );
    }
    function M(e, t, n) {
      return e.slice(0, t).concat(n).concat(e.slice(t));
    }
    return o;
  })();
  new Ql();
  const pu = document.querySelector("canvas.webgl"),
    fu = new Ir(),
    mu = new Tr(),
    gu = new ln(0.6, 0.7, 0.1),
    vu = [
      new As({ map: rh }),
      new As({ map: rh }),
      new As({ map: rh }),
      new As({ map: rh }),
      new As({ map: sh }),
      new As({ map: rh }),
      new As({ envMap: oh }),
    ];
  for (let e = 0; e < 50; e++) {
    const e = Math.random() * Math.PI * 2,
      t = 3 + 6 * Math.random(),
      n = Math.cos(e) * t,
      i = Math.sin(e) * t,
      r = new sn(gu, vu);
    (r.castShadow = !0),
      r.position.set(n, 0.3, i),
      (r.rotation.z = 0.4 * (Math.random() - 0.5)),
      (r.rotation.y = 0.4 * (Math.random() - 0.5)),
      mu.add(r);
  }
  const yu = new Or("#262837", 1, 15);
  (fu.fog = yu), fu.add(hh, uh, dh, ah, mu);
  const xu = { width: window.innerWidth, height: window.innerHeight };
  window.addEventListener("resize", () => {
    (xu.width = window.innerWidth),
      (xu.height = window.innerHeight),
      (_u.aspect = xu.width / xu.height),
      _u.updateProjectionMatrix(),
      wu.setSize(xu.width, xu.height),
      wu.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });
  const _u = new mn(75, xu.width / xu.height, 0.1, 100);
  (_u.position.x = 4), (_u.position.y = 2), (_u.position.z = 5), fu.add(_u);
  const bu = new ch(_u, pu);
  (bu.enableDamping = !0),
    (bu.minDistance = 5),
    (bu.maxDistance = 7.5),
    (bu.enablePan = !1),
    (bu.maxPolarAngle = Math.PI / 2 - 0.05),
    bu.update();
  const wu = new Cr({ canvas: pu });
  (wu.shadowMap.enabled = !0),
    (wu.shadowMap.type = 2),
    wu.setClearColor("#262837"),
    wu.setSize(xu.width, xu.height),
    wu.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  const Mu = new (class {
    constructor(e) {
      (this.autoStart = void 0 === e || e),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = lc()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const t = lc();
        (e = (t - this.oldTime) / 1e3),
          (this.oldTime = t),
          (this.elapsedTime += e);
      }
      return e;
    }
  })();
  let Su = !0,
    Eu = 0,
    Tu = !0;
  const Au = () => {
      if (Su) {
        const e = Mu.getElapsedTime() * (Tu ? 1 : -1);
        for (let t = 0; t < vh.length; t++) {
          const n = new W(),
            i = new W();
          Ou[t].children[1].getWorldPosition(n),
            Ou[t].position.set(...vh[t].getPosition(e)),
            Ou[t].children[1].getWorldPosition(i);
          let r = i.sub(n);
          r.setY(2), Ou[t].children[1].lookAt(Ou[t].localToWorld(r));
        }
      }
      let e = Mu.getDelta();
      characterControls && characterControls.update(e, Lu),
        bu.update(),
        wu.render(fu, _u),
        window.requestAnimationFrame(Au);
    },
    Lu = {},
    Ru = new (class {
      map = new Map();
      constructor() {
        const e = document.createElement("div"),
          t = document.createElement("div"),
          n = document.createElement("div"),
          i = document.createElement("div"),
          r = document.createElement("div");
        this.map.set(xh, e),
          this.map.set(_h, t),
          this.map.set(bh, n),
          this.map.set(wh, i),
          this.map.set(Mh, r),
          this.map.forEach((e, t) => {
            (e.style.color = "blue"),
              (e.style.fontSize = "50px"),
              (e.style.fontWeight = "800"),
              (e.style.position = "absolute"),
              (e.textContent = t);
          }),
          this.updatePosition(),
          this.map.forEach((e, t) => {
            document.body.append(e);
          });
      }
      updatePosition() {
        (this.map.get(xh).style.top = window.innerHeight - 150 + "px"),
          (this.map.get(_h).style.top = window.innerHeight - 100 + "px"),
          (this.map.get(bh).style.top = window.innerHeight - 100 + "px"),
          (this.map.get(wh).style.top = window.innerHeight - 100 + "px"),
          (this.map.get(Mh).style.top = window.innerHeight - 100 + "px"),
          (this.map.get(xh).style.left = "300px"),
          (this.map.get(_h).style.left = "200px"),
          (this.map.get(bh).style.left = "300px"),
          (this.map.get(wh).style.left = "400px"),
          (this.map.get(Mh).style.left = "50px");
      }
      down(e) {
        this.map.get(e.toLowerCase()) &&
          (this.map.get(e.toLowerCase()).style.color = "red");
      }
      up(e) {
        this.map.get(e.toLowerCase()) &&
          (this.map.get(e.toLowerCase()).style.color = "blue");
      }
    })();
  document.addEventListener("keydown", (e) => {
    Ru.down(e.key),
      e.shiftKey && characterControls
        ? characterControls.switchRunToggle()
        : (Lu[e.key.toLowerCase()] = !0);
  }),
    document.addEventListener("keyup", (e) => {
      if ("Space" === e.code || "KeyR" === e.code)
        return "KeyR" === e.code
          ? void (Tu = !Tu)
          : ((Su = !Su),
            Mu.running
              ? ((Eu = Mu.getElapsedTime()), void (Mu.running = !1))
              : (Mu.start(), void (Mu.elapsedTime = Eu)));
      Ru.up(e.key), (Lu[e.key.toLowerCase()] = !1);
    });
  const Cu = new Qs();
  (Cu.onStart = function (e, t, n) {
    console.log(
      "Started loading file: " + e + ".\nLoaded " + t + " of " + n + " files."
    );
  }),
    (Cu.onLoad = function () {
      console.log("Loading complete!");
    }),
    (Cu.onProgress = function (e, t, n) {
      console.log(
        "Loading file: " + e + ".\nLoaded " + t + " of " + n + " files."
      );
    }),
    (Cu.onError = function (e) {
      console.log("There was an error loading " + e);
    });
  const Pu = new yh();
  let Ou = [];
  Pu.load(
    "/models/boo_halloween2019/scene.gltf",
    (e) => {
      for (let t = 0; t < vh.length; t++) {
        const n = new Tr(fu).add(vh[t].light, e.scene.clone().children[0]);
        fu.add(n), Ou.push(n);
      }
      Au();
    },
    (e) => {
      console.log((e.loaded / e.total) * 100 + "% loaded");
    },
    (e) => {
      console.log("An error happened"), console.log(e);
    }
  ),
    Pu.load(
      "models/house/scene.gltf",
      function (e) {
        const t = e.scene;
        t.position,
          t.position.set(0, 0.1, 0),
          t.scale.set(0.01, 0.01, 0.01),
          fu.add(t);
      },
      void 0,
      function (e) {
        console.error(e);
      }
    );
  const Iu = new du();
  Iu.setPath("./models/zombie/"),
    Iu.load("mremireh_o_desbiens.fbx", (e) => {
      e.scale.setScalar(0.005),
        e.position.set(2, 0.1, 2),
        e.traverse((e) => {
          e.isMMesh && (e.castShadow = !0);
        }),
        fu.add(e);
      const t = e.animations,
        n = new Mc(e),
        i = new Map();
      t
        .filter((e) => "TPose" != e.name)
        .forEach((e) => {
          i.set(e.name, n.clipAction(e));
        }),
        (characterControls = new Eh(e, n, i, bu, _u, "Idle"));
    });
  const Nu = 400,
    Du = 0.075,
    Fu = 20,
    Uu = 2,
    ku = -5,
    Bu = 10,
    zu = "#FFFFFF",
    Hu = "#FFFFFF";
  let Gu = null,
    Vu = null,
    ju = null;
  (() => {
    null !== ju && (Gu.dispose(), Vu.dispose(), fu.remove(ju)), (Gu = new Ht());
    const e = new Float32Array(3 * Nu),
      t = new Float32Array(3 * Nu),
      n = new dt(zu),
      i = new dt(Hu);
    for (let r = 0; r < Nu; r++) {
      const o = 3 * r,
        s = Math.random() * Fu,
        a = ((r % Uu) / Uu) * Math.PI * 2,
        c = s * ku,
        l = Math.pow(Math.random(), Bu) * (Math.random() < 0.5 ? 1 : -1),
        h = Math.pow(Math.random(), Bu) * (Math.random() < 0.5 ? 1 : -1),
        u = Math.pow(Math.random(), Bu) * (Math.random() < 0.5 ? 1 : -1);
      (e[o] = Math.cos(a + c) * s + l),
        (e[o + 1] = h),
        (e[o + 2] = Math.sin(a + c) * s + u);
      const d = n.clone();
      d.lerp(i, s / Fu), (t[o] = d.r), (t[o + 1] = d.g), (t[o + 2] = d.b);
    }
    Gu.setAttribute("position", new xt(e, 3)),
      Gu.setAttribute("colors", new xt(t, 3)),
      (Vu = new Ro({
        size: Du,
        sizeAttenuation: !0,
        depthWrite: !1,
        blending: 2,
        vertexColors: !0,
      })),
      (ju = new No(Gu, Vu)),
      (ju.position.y = 7.5),
      fu.add(ju);
  })();
})();
//# sourceMappingURL=bundle.699e4502c0e330456ef4.js.map
